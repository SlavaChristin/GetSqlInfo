<?xml version="1.0"?>
<Queries>
    <!--//////
   
// CACHESTORE_SQLCP  SQL Plans         
// These are cached SQL statements or batches that aren't in stored procedures, functions and triggers
// Watch out for high values for CACHESTORE_SQLCP

// CACHESTORE_OBJCP  Object Plans      
// These are compiled plans for stored procedures, functions and triggers



// Find single-use, ad-hoc queries that are bloating the plan cache (Query 30) (Ad hoc Queries)-->
    <Query id="30" name="Ad hoc Queries" description="Find single-use, ad-hoc queries that are bloating the plan cache" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server" sqlVersionFilter="9.0.0+" longTextColumns="QueryText"><![CDATA[
SELECT TOP(50) [text] AS [QueryText], cp.cacheobjtype, cp.objtype, cp.size_in_bytes/1024 AS [Plan Size in KB]
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) 
WHERE cp.cacheobjtype = N'Compiled Plan' 
AND cp.objtype IN (N'Adhoc', N'Prepared') 
AND cp.usecounts = 1
ORDER BY cp.size_in_bytes DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// CACHESTORE_SQLCP  SQL Plans         
// These are cached SQL statements or batches that aren't in stored procedures, functions and triggers
// Watch out for high values for CACHESTORE_SQLCP

// CACHESTORE_OBJCP  Object Plans      
// These are compiled plans for stored procedures, functions and triggers



// Find single-use, ad-hoc and prepared queries that are bloating the plan cache  (Query 39) (Ad hoc Queries)-->
    <Query id="39" name="Ad hoc Queries" description="Find single-use, ad-hoc and prepared queries that are bloating the plan cache" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server" longTextColumns="QueryText"><![CDATA[
SELECT TOP(50) [text] AS [QueryText], cp.cacheobjtype, cp.objtype, cp.size_in_bytes/1024 AS [Plan Size in KB]
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) 
WHERE cp.cacheobjtype = N'Compiled Plan' 
AND cp.objtype IN (N'Adhoc', N'Prepared') 
AND cp.usecounts = 1
ORDER BY cp.size_in_bytes DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// CACHESTORE_SQLCP  SQL Plans         
// These are cached SQL statements or batches that aren't in stored procedures, functions and triggers
// Watch out for high values for CACHESTORE_SQLCP

// CACHESTORE_OBJCP  Object Plans      
// These are compiled plans for stored procedures, functions and triggers



// Find single-use, ad-hoc and prepared queries that are bloating the plan cache  (Query 35) (Ad hoc Queries)-->
    <Query id="35" name="Ad hoc Queries" description="Find single-use, ad-hoc and prepared queries that are bloating the plan cache" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server" longTextColumns="QueryText"><![CDATA[
SELECT TOP(50) [text] AS [QueryText], cp.cacheobjtype, cp.objtype, cp.size_in_bytes/1024 AS [Plan Size in KB]
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) 
WHERE cp.cacheobjtype = N'Compiled Plan' 
AND cp.objtype IN (N'Adhoc', N'Prepared') 
AND cp.usecounts = 1
ORDER BY cp.size_in_bytes DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// MEMORYCLERK_SQLBUFFERPOOL was new for SQL Server 2012. It should be your highest consumer of memory

// CACHESTORE_SQLCP  SQL Plans         
// These are cached SQL statements or batches that aren't in stored procedures, functions and triggers
// Watch out for high values for CACHESTORE_SQLCP
// Enabling 'optimize for ad hoc workloads' at the instance level can help reduce this

// CACHESTORE_OBJCP  Object Plans      
// These are compiled plans for stored procedures, functions and triggers



// Find single-use, ad-hoc and prepared queries that are bloating the plan cache  (Query 40) (Ad hoc Queries)-->
    <Query id="40" name="Ad hoc Queries" description="Find single-use, ad-hoc and prepared queries that are bloating the plan cache" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server" longTextColumns="QueryText"><![CDATA[
SELECT TOP(50) [text] AS [QueryText], cp.cacheobjtype, cp.objtype, cp.size_in_bytes/1024 AS [Plan Size in KB]
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) 
WHERE cp.cacheobjtype = N'Compiled Plan' 
AND cp.objtype IN (N'Adhoc', N'Prepared') 
AND cp.usecounts = 1
ORDER BY cp.size_in_bytes DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// MEMORYCLERK_SQLBUFFERPOOL was new for SQL Server 2012. It should be your highest consumer of memory

// CACHESTORE_SQLCP  SQL Plans         
// These are cached SQL statements or batches that aren't in stored procedures, functions and triggers
// Watch out for high values for CACHESTORE_SQLCP
// Enabling 'optimize for ad hoc workloads' at the instance level can help reduce this

// CACHESTORE_OBJCP  Object Plans      
// These are compiled plans for stored procedures, functions and triggers



// Find single-use, ad-hoc and prepared queries that are bloating the plan cache  (Query 45) (Ad hoc Queries)-->
    <Query id="45" name="Ad hoc Queries" description="Find single-use, ad-hoc and prepared queries that are bloating the plan cache" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server" longTextColumns="QueryText"><![CDATA[
SELECT TOP(50) [text] AS [QueryText], cp.cacheobjtype, cp.objtype, cp.size_in_bytes/1024 AS [Plan Size in KB]
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) 
WHERE cp.cacheobjtype = N'Compiled Plan' 
AND cp.objtype IN (N'Adhoc', N'Prepared') 
AND cp.usecounts = 1
ORDER BY cp.size_in_bytes DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// MEMORYCLERK_SQLBUFFERPOOL was new for SQL Server 2012. It should be your highest consumer of memory

// CACHESTORE_SQLCP  SQL Plans         
// These are cached SQL statements or batches that aren't in stored procedures, functions and triggers
// Watch out for high values for CACHESTORE_SQLCP
// Enabling 'optimize for ad hoc workloads' at the instance level can help reduce this

// CACHESTORE_OBJCP  Object Plans      
// These are compiled plans for stored procedures, functions and triggers



// Find single-use, ad-hoc and prepared queries that are bloating the plan cache  (Query 45) (Ad hoc Queries)-->
    <Query id="45" name="Ad hoc Queries" description="Find single-use, ad-hoc and prepared queries that are bloating the plan cache" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server" longTextColumns="QueryText"><![CDATA[
SELECT TOP(50) [text] AS [QueryText], cp.cacheobjtype, cp.objtype, cp.size_in_bytes/1024 AS [Plan Size in KB]
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) 
WHERE cp.cacheobjtype = N'Compiled Plan' 
AND cp.objtype IN (N'Adhoc', N'Prepared') 
AND cp.usecounts = 1
ORDER BY cp.size_in_bytes DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// MEMORYCLERK_SQLBUFFERPOOL was new for SQL Server 2012. It should be your highest consumer of memory

// CACHESTORE_SQLCP  SQL Plans         
// These are cached SQL statements or batches that aren't in stored procedures, functions and triggers
// Watch out for high values for CACHESTORE_SQLCP
// Enabling 'optimize for ad hoc workloads' at the instance level can help reduce this

// CACHESTORE_OBJCP  Object Plans      
// These are compiled plans for stored procedures, functions and triggers



// Find single-use, ad-hoc and prepared queries that are bloating the plan cache  (Query 45) (Ad hoc Queries)-->
    <Query id="45" name="Ad hoc Queries" description="Find single-use, ad-hoc and prepared queries that are bloating the plan cache" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server" longTextColumns="QueryText"><![CDATA[
SELECT TOP(50) [text] AS [QueryText], cp.cacheobjtype, cp.objtype, cp.size_in_bytes/1024 AS [Plan Size in KB]
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) 
WHERE cp.cacheobjtype = N'Compiled Plan' 
AND cp.objtype IN (N'Adhoc', N'Prepared') 
AND cp.usecounts = 1
ORDER BY cp.size_in_bytes DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Knowing which node owns the cluster resources is critical
// Especially when you are installing Windows or SQL Server updates
// You will see no results if your instance is not clustered

// Recommended hotfixes and updates for Windows Server 2012 R2-based failover clusters
// http://support.microsoft.com/kb/2920151


// Get information about any AlwaysOn AG cluster this instance is a part of (Query 15) (AlwaysOn AG Cluster)-->
    <Query id="15" name="AlwaysOn AG Cluster" description="Get information about any AlwaysOn AG cluster this instance is a part of" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT cluster_name, quorum_type_desc, quorum_state_desc
FROM sys.dm_hadr_cluster WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Knowing which node owns the cluster resources is critical
// Especially when you are installing Windows or SQL Server updates
// You will see no results if your instance is not clustered

// Recommended hotfixes and updates for Windows Server 2012 R2-based failover clusters
// http://support.microsoft.com/kb/2920151


// Get information about any AlwaysOn AG cluster this instance is a part of (Query 16) (AlwaysOn AG Cluster)-->
    <Query id="16" name="AlwaysOn AG Cluster" description="Get information about any AlwaysOn AG cluster this instance is a part of" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT cluster_name, quorum_type_desc, quorum_state_desc
FROM sys.dm_hadr_cluster WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Knowing which node owns the cluster resources is critical
// Especially when you are installing Windows or SQL Server updates
// You will see no results if your instance is not clustered

// Recommended hotfixes and updates for Windows Server 2012 R2-based failover clusters
// http://support.microsoft.com/kb/2920151


// Get information about any AlwaysOn AG cluster this instance is a part of (Query 16) (AlwaysOn AG Cluster)-->
    <Query id="16" name="AlwaysOn AG Cluster" description="Get information about any AlwaysOn AG cluster this instance is a part of" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT cluster_name, quorum_type_desc, quorum_state_desc
FROM sys.dm_hadr_cluster WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Knowing which node owns the cluster resources is critical
// Especially when you are installing Windows or SQL Server updates
// You will see no results if your instance is not clustered

// Recommended hotfixes and updates for Windows Server 2012 R2-based failover clusters
// http://support.microsoft.com/kb/2920151


// Get information about any AlwaysOn AG cluster this instance is a part of (Query 16) (AlwaysOn AG Cluster)-->
    <Query id="16" name="AlwaysOn AG Cluster" description="Get information about any AlwaysOn AG cluster this instance is a part of" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT cluster_name, quorum_type_desc, quorum_state_desc
FROM sys.dm_hadr_cluster WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You will see no results if your instance is not using AlwaysOn AGs


// Good overview of AG health and status (Query 17) (AlwaysOn AG Status)-->
    <Query id="17" name="AlwaysOn AG Status" description="Good overview of AG health and status" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT ag.name AS [AG Name], ar.replica_server_name, ar.availability_mode_desc, adc.[database_name], 
       drs.is_local, drs.is_primary_replica, drs.synchronization_state_desc, drs.is_commit_participant, 
	   drs.synchronization_health_desc, drs.recovery_lsn, drs.truncation_lsn, drs.last_sent_lsn, 
	   drs.last_sent_time, drs.last_received_lsn, drs.last_received_time, drs.last_hardened_lsn, 
	   drs.last_hardened_time, drs.last_redone_lsn, drs.last_redone_time, drs.log_send_queue_size, 
	   drs.log_send_rate, drs.redo_queue_size, drs.redo_rate, drs.filestream_send_rate, 
	   drs.end_of_log_lsn, drs.last_commit_lsn, drs.last_commit_time, drs.database_state_desc 
FROM sys.dm_hadr_database_replica_states AS drs WITH (NOLOCK)
INNER JOIN sys.availability_databases_cluster AS adc WITH (NOLOCK)
ON drs.group_id = adc.group_id 
AND drs.group_database_id = adc.group_database_id
INNER JOIN sys.availability_groups AS ag WITH (NOLOCK)
ON ag.group_id = drs.group_id
INNER JOIN sys.availability_replicas AS ar WITH (NOLOCK)
ON drs.group_id = ar.group_id 
AND drs.replica_id = ar.replica_id
ORDER BY ag.name, ar.replica_server_name, adc.[database_name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You will see no results if your instance is not using AlwaysOn AGs


// Good overview of AG health and status (Query 17) (AlwaysOn AG Status)-->
    <Query id="17" name="AlwaysOn AG Status" description="Good overview of AG health and status" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT ag.name AS [AG Name], ar.replica_server_name, ar.availability_mode_desc, adc.[database_name], 
       drs.is_local, drs.is_primary_replica, drs.synchronization_state_desc, drs.is_commit_participant, 
	   drs.synchronization_health_desc, drs.recovery_lsn, drs.truncation_lsn, drs.last_sent_lsn, 
	   drs.last_sent_time, drs.last_received_lsn, drs.last_received_time, drs.last_hardened_lsn, 
	   drs.last_hardened_time, drs.last_redone_lsn, drs.last_redone_time, drs.log_send_queue_size, 
	   drs.log_send_rate, drs.redo_queue_size, drs.redo_rate, drs.filestream_send_rate, 
	   drs.end_of_log_lsn, drs.last_commit_lsn, drs.last_commit_time, drs.database_state_desc 
FROM sys.dm_hadr_database_replica_states AS drs WITH (NOLOCK)
INNER JOIN sys.availability_databases_cluster AS adc WITH (NOLOCK)
ON drs.group_id = adc.group_id 
AND drs.group_database_id = adc.group_database_id
INNER JOIN sys.availability_groups AS ag WITH (NOLOCK)
ON ag.group_id = drs.group_id
INNER JOIN sys.availability_replicas AS ar WITH (NOLOCK)
ON drs.group_id = ar.group_id 
AND drs.replica_id = ar.replica_id
ORDER BY ag.name, ar.replica_server_name, adc.[database_name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You will see no results if your instance is not using AlwaysOn AGs


// Good overview of AG health and status (Query 17) (AlwaysOn AG Status)-->
    <Query id="17" name="AlwaysOn AG Status" description="Good overview of AG health and status" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT ag.name AS [AG Name], ar.replica_server_name, ar.availability_mode_desc, adc.[database_name], 
       drs.is_local, drs.is_primary_replica, drs.synchronization_state_desc, drs.is_commit_participant, 
	   drs.synchronization_health_desc, drs.recovery_lsn, drs.truncation_lsn, drs.last_sent_lsn, 
	   drs.last_sent_time, drs.last_received_lsn, drs.last_received_time, drs.last_hardened_lsn, 
	   drs.last_hardened_time, drs.last_redone_lsn, drs.last_redone_time, drs.log_send_queue_size, 
	   drs.log_send_rate, drs.redo_queue_size, drs.redo_rate, drs.filestream_send_rate, 
	   drs.end_of_log_lsn, drs.last_commit_lsn, drs.last_commit_time, drs.database_state_desc 
FROM sys.dm_hadr_database_replica_states AS drs WITH (NOLOCK)
INNER JOIN sys.availability_databases_cluster AS adc WITH (NOLOCK)
ON drs.group_id = adc.group_id 
AND drs.group_database_id = adc.group_database_id
INNER JOIN sys.availability_groups AS ag WITH (NOLOCK)
ON ag.group_id = drs.group_id
INNER JOIN sys.availability_replicas AS ar WITH (NOLOCK)
ON drs.group_id = ar.group_id 
AND drs.replica_id = ar.replica_id
ORDER BY ag.name, ar.replica_server_name, adc.[database_name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you figure where your database load is coming from
// and verifies connectivity from other machines


// Get Average Task Counts (run multiple times) (Query 25) (Avg Task Counts)-->
    <Query id="25" name="Avg Task Counts" description="Get Average Task Counts (run multiple times)" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT AVG(current_tasks_count) AS [Avg Task Count], 
AVG(runnable_tasks_count) AS [Avg Runnable Task Count],
AVG(pending_disk_io_count) AS [Avg Pending DiskIO Count]
FROM sys.dm_os_schedulers WITH (NOLOCK)
WHERE scheduler_id < 255 OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you figure where your database load is coming from
// and verifies connectivity from other machines


// Get Average Task Counts (run multiple times) (Query 31) (Avg Task Counts)-->
    <Query id="31" name="Avg Task Counts" description="Get Average Task Counts (run multiple times)" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT AVG(current_tasks_count) AS [Avg Task Count], 
AVG(runnable_tasks_count) AS [Avg Runnable Task Count],
AVG(pending_disk_io_count) AS [Avg Pending DiskIO Count]
FROM sys.dm_os_schedulers WITH (NOLOCK)
WHERE scheduler_id < 255 OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you figure where your database load is coming from
// and verifies connectivity from other machines


// Get Average Task Counts (run multiple times) (Query 27) (Avg Task Counts)-->
    <Query id="27" name="Avg Task Counts" description="Get Average Task Counts (run multiple times)" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT AVG(current_tasks_count) AS [Avg Task Count], 
AVG(runnable_tasks_count) AS [Avg Runnable Task Count],
AVG(pending_disk_io_count) AS [Avg Pending DiskIO Count]
FROM sys.dm_os_schedulers WITH (NOLOCK)
WHERE scheduler_id < 255 OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you figure where your database load is coming from
// and verifies connectivity from other machines


// Get Average Task Counts (run multiple times)  (Query 33) (Avg Task Counts)-->
    <Query id="33" name="Avg Task Counts" description="Get Average Task Counts (run multiple times)" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT AVG(current_tasks_count) AS [Avg Task Count], 
AVG(work_queue_count) AS [Avg Work Queue Count],
AVG(runnable_tasks_count) AS [Avg Runnable Task Count],
AVG(pending_disk_io_count) AS [Avg Pending DiskIO Count]
FROM sys.dm_os_schedulers WITH (NOLOCK)
WHERE scheduler_id < 255 OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you figure where your database load is coming from
// and verifies connectivity from other machines


// Get Average Task Counts (run multiple times)  (Query 38) (Avg Task Counts)-->
    <Query id="38" name="Avg Task Counts" description="Get Average Task Counts (run multiple times)" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT AVG(current_tasks_count) AS [Avg Task Count], 
AVG(work_queue_count) AS [Avg Work Queue Count],
AVG(runnable_tasks_count) AS [Avg Runnable Task Count],
AVG(pending_disk_io_count) AS [Avg Pending DiskIO Count]
FROM sys.dm_os_schedulers WITH (NOLOCK)
WHERE scheduler_id < 255 OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you figure where your database load is coming from
// and verifies connectivity from other machines


// Get Average Task Counts (run multiple times)  (Query 38) (Avg Task Counts)-->
    <Query id="38" name="Avg Task Counts" description="Get Average Task Counts (run multiple times)" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT AVG(current_tasks_count) AS [Avg Task Count], 
AVG(work_queue_count) AS [Avg Work Queue Count],
AVG(runnable_tasks_count) AS [Avg Runnable Task Count],
AVG(pending_disk_io_count) AS [Avg Pending DiskIO Count]
FROM sys.dm_os_schedulers WITH (NOLOCK)
WHERE scheduler_id < 255 OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you figure where your database load is coming from
// and verifies connectivity from other machines


// Get Average Task Counts (run multiple times)  (Query 38) (Avg Task Counts)-->
    <Query id="38" name="Avg Task Counts" description="Get Average Task Counts (run multiple times)" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT AVG(current_tasks_count) AS [Avg Task Count], 
AVG(work_queue_count) AS [Avg Work Queue Count],
AVG(runnable_tasks_count) AS [Avg Runnable Task Count],
AVG(pending_disk_io_count) AS [Avg Pending DiskIO Count]
FROM sys.dm_os_schedulers WITH (NOLOCK)
WHERE scheduler_id < 255 OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you find the most expensive statements for I/O by SP



// Possible Bad NC Indexes (writes > reads)  (Query 40) (Bad NC Indexes)-->
    <Query id="40" name="Bad NC Indexes" description="Possible Bad NC Indexes (writes &gt; reads)" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(s.[object_id]) AS [Table Name], i.name AS [Index Name], 
o.[type_desc], o.create_date, i.index_id, i.is_disabled,
user_updates AS [Total Writes], user_seeks + user_scans + user_lookups AS [Total Reads],
user_updates - (user_seeks + user_scans + user_lookups) AS [Difference]
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON s.[object_id] = i.[object_id]
AND i.index_id = s.index_id
INNER JOIN sys.objects AS o WITH (NOLOCK) 
ON i.[object_id] = o.[object_id]
WHERE OBJECTPROPERTY(s.[object_id],'IsUserTable') = 1
AND s.database_id = DB_ID()
AND user_updates > (user_seeks + user_scans + user_lookups)
AND i.index_id > 1
ORDER BY [Difference] DESC, [Total Writes] DESC, [Total Reads] ASC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you find the most expensive statements for I/O by SP



// Possible Bad NC Indexes (writes > reads)  (Query 51) (Bad NC Indexes)-->
    <Query id="51" name="Bad NC Indexes" description="Possible Bad NC Indexes (writes &gt; reads)" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT OBJECT_NAME(s.[object_id]) AS [Table Name], i.name AS [Index Name], i.index_id, 
i.is_disabled, i.is_hypothetical, i.has_filter, i.fill_factor,
user_updates AS [Total Writes], user_seeks + user_scans + user_lookups AS [Total Reads],
user_updates - (user_seeks + user_scans + user_lookups) AS [Difference]
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON s.[object_id] = i.[object_id]
AND i.index_id = s.index_id
WHERE OBJECTPROPERTY(s.[object_id],'IsUserTable') = 1
AND s.database_id = DB_ID()
AND user_updates > (user_seeks + user_scans + user_lookups)
AND i.index_id > 1
ORDER BY [Difference] DESC, [Total Writes] DESC, [Total Reads] ASC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you find the most expensive statements for I/O by SP



// Possible Bad NC Indexes (writes > reads)  (Query 47) (Bad NC Indexes)-->
    <Query id="47" name="Bad NC Indexes" description="Possible Bad NC Indexes (writes &gt; reads)" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(s.[object_id]) AS [Table Name], i.name AS [Index Name], i.index_id, 
i.is_disabled, i.is_hypothetical, i.has_filter, i.fill_factor,
user_updates AS [Total Writes], user_seeks + user_scans + user_lookups AS [Total Reads],
user_updates - (user_seeks + user_scans + user_lookups) AS [Difference]
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON s.[object_id] = i.[object_id]
AND i.index_id = s.index_id
WHERE OBJECTPROPERTY(s.[object_id],'IsUserTable') = 1
AND s.database_id = DB_ID()
AND user_updates > (user_seeks + user_scans + user_lookups)
AND i.index_id > 1
ORDER BY [Difference] DESC, [Total Writes] DESC, [Total Reads] ASC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you find the most expensive statements for I/O by SP



// Possible Bad NC Indexes (writes > reads)  (Query 53) (Bad NC Indexes)-->
    <Query id="53" name="Bad NC Indexes" description="Possible Bad NC Indexes (writes &gt; reads)" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(s.[object_id]) AS [Table Name], i.name AS [Index Name], i.index_id, 
i.is_disabled, i.is_hypothetical, i.has_filter, i.fill_factor,
user_updates AS [Total Writes], user_seeks + user_scans + user_lookups AS [Total Reads],
user_updates - (user_seeks + user_scans + user_lookups) AS [Difference]
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON s.[object_id] = i.[object_id]
AND i.index_id = s.index_id
WHERE OBJECTPROPERTY(s.[object_id],'IsUserTable') = 1
AND s.database_id = DB_ID()
AND user_updates > (user_seeks + user_scans + user_lookups)
AND i.index_id > 1
ORDER BY [Difference] DESC, [Total Writes] DESC, [Total Reads] ASC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you find the most expensive statements for I/O by SP



// Possible Bad NC Indexes (writes > reads)  (Query 59) (Bad NC Indexes)-->
    <Query id="59" name="Bad NC Indexes" description="Possible Bad NC Indexes (writes &gt; reads)" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(s.[object_id]) AS [Table Name], i.name AS [Index Name], i.index_id, 
i.is_disabled, i.is_hypothetical, i.has_filter, i.fill_factor,
user_updates AS [Total Writes], user_seeks + user_scans + user_lookups AS [Total Reads],
user_updates - (user_seeks + user_scans + user_lookups) AS [Difference]
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON s.[object_id] = i.[object_id]
AND i.index_id = s.index_id
WHERE OBJECTPROPERTY(s.[object_id],'IsUserTable') = 1
AND s.database_id = DB_ID()
AND user_updates > (user_seeks + user_scans + user_lookups)
AND i.index_id > 1
ORDER BY [Difference] DESC, [Total Writes] DESC, [Total Reads] ASC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you find the most expensive statements for I/O by SP



// Possible Bad NC Indexes (writes > reads)  (Query 61) (Bad NC Indexes)-->
    <Query id="61" name="Bad NC Indexes" description="Possible Bad NC Indexes (writes &gt; reads)" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(s.[object_id]) AS [Table Name], i.name AS [Index Name], i.index_id, 
i.is_disabled, i.is_hypothetical, i.has_filter, i.fill_factor,
user_updates AS [Total Writes], user_seeks + user_scans + user_lookups AS [Total Reads],
user_updates - (user_seeks + user_scans + user_lookups) AS [Difference]
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON s.[object_id] = i.[object_id]
AND i.index_id = s.index_id
WHERE OBJECTPROPERTY(s.[object_id],'IsUserTable') = 1
AND s.database_id = DB_ID()
AND user_updates > (user_seeks + user_scans + user_lookups)
AND i.index_id > 1
ORDER BY [Difference] DESC, [Total Writes] DESC, [Total Reads] ASC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you find the most expensive statements for I/O by SP



// Possible Bad NC Indexes (writes > reads)  (Query 61) (Bad NC Indexes)-->
    <Query id="61" name="Bad NC Indexes" description="Possible Bad NC Indexes (writes &gt; reads)" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(s.[object_id]) AS [Table Name], i.name AS [Index Name], i.index_id, 
i.is_disabled, i.is_hypothetical, i.has_filter, i.fill_factor,
user_updates AS [Total Writes], user_seeks + user_scans + user_lookups AS [Total Reads],
user_updates - (user_seeks + user_scans + user_lookups) AS [Difference]
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON s.[object_id] = i.[object_id]
AND i.index_id = s.index_id
WHERE OBJECTPROPERTY(s.[object_id],'IsUserTable') = 1
AND s.database_id = DB_ID()
AND user_updates > (user_seeks + user_scans + user_lookups)
AND i.index_id > 1
ORDER BY [Difference] DESC, [Total Writes] DESC, [Total Reads] ASC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you the model number and rated clock speed of your processor(s)
// Your processors may be running at less than the rated clock speed due
// to the Windows Power Plan or hardware power management

// You can use CPU-Z to get your actual CPU core speed and a lot of other useful information
// http://www.cpuid.com/softwares/cpu-z.html

// You can learn more about processor selection for SQL Server by following this link
// http://www.sqlskills.com/blogs/glenn/processor-selection-for-sql-server/



// See if buffer pool extensions (BPE) is enabled (Query 21) (BPE Configuration)-->
    <Query id="21" name="BPE Configuration" description="See if buffer pool extensions (BPE) is enabled" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT [path], state_description, current_size_in_kb, 
CAST(current_size_in_kb/1048576.0 AS DECIMAL(10,2)) AS [Size (GB)]
FROM sys.dm_os_buffer_pool_extension_configuration WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you the model number and rated clock speed of your processor(s)
// Your processors may be running at less than the rated clock speed due
// to the Windows Power Plan or hardware power management

// You can use CPU-Z to get your actual CPU core speed and a lot of other useful information
// http://www.cpuid.com/softwares/cpu-z.html

// You can learn more about processor selection for SQL Server by following this link
// http://www.sqlskills.com/blogs/glenn/processor-selection-for-sql-server/



// See if buffer pool extensions (BPE) is enabled (Query 21) (BPE Configuration)-->
    <Query id="21" name="BPE Configuration" description="See if buffer pool extensions (BPE) is enabled" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT [path], state_description, current_size_in_kb, 
CAST(current_size_in_kb/1048576.0 AS DECIMAL(10,2)) AS [Size (GB)]
FROM sys.dm_os_buffer_pool_extension_configuration WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you the model number and rated clock speed of your processor(s)
// Your processors may be running at less than the rated clock speed due
// to the Windows Power Plan or hardware power management

// You can use CPU-Z to get your actual CPU core speed and a lot of other useful information
// http://www.cpuid.com/softwares/cpu-z.html

// You can learn more about processor selection for SQL Server by following this link
// http://www.sqlskills.com/blogs/glenn/processor-selection-for-sql-server/



// See if buffer pool extensions (BPE) is enabled (Query 21) (BPE Configuration)-->
    <Query id="21" name="BPE Configuration" description="See if buffer pool extensions (BPE) is enabled" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT [path], state_description, current_size_in_kb, 
CAST(current_size_in_kb/1048576.0 AS DECIMAL(10,2)) AS [Size (GB)]
FROM sys.dm_os_buffer_pool_extension_configuration WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// BPE is available in both Standard Edition and Enterprise Edition
// It is a more interesting feature for Standard Edition

// Buffer Pool Extension to SSDs in SQL Server 2014
// http://blogs.technet.com/b/dataplatforminsider/archive/2013/07/25/buffer-pool-extension-to-ssds-in-sql-server-2014.aspx



// Look at buffer descriptors to see BPE usage by database (Query 22) (BPE Usage) -->
    <Query id="22" name="BPE Usage" description="Look at buffer descriptors to see BPE usage by database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT DB_NAME(database_id) AS [Database Name], COUNT(page_id) AS [Page Count],
CAST(COUNT(*)/128.0 AS DECIMAL(10, 2)) AS [Buffer size(MB)], 
AVG(read_microsec) AS [Avg Read Time (microseconds)]
FROM sys.dm_os_buffer_descriptors WITH (NOLOCK)
WHERE database_id <> 32767
AND is_in_bpool_extension = 1
GROUP BY DB_NAME(database_id) 
ORDER BY [Buffer size(MB)] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// BPE is available in both Standard Edition and Enterprise Edition
// It is a more interesting feature for Standard Edition

// Buffer Pool Extension to SSDs in SQL Server 2014
// http://blogs.technet.com/b/dataplatforminsider/archive/2013/07/25/buffer-pool-extension-to-ssds-in-sql-server-2014.aspx



// Look at buffer descriptors to see BPE usage by database (Query 22) (BPE Usage) -->
    <Query id="22" name="BPE Usage" description="Look at buffer descriptors to see BPE usage by database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT DB_NAME(database_id) AS [Database Name], COUNT(page_id) AS [Page Count],
CAST(COUNT(*)/128.0 AS DECIMAL(10, 2)) AS [Buffer size(MB)], 
AVG(read_microsec) AS [Avg Read Time (microseconds)]
FROM sys.dm_os_buffer_descriptors WITH (NOLOCK)
WHERE database_id <> 32767
AND is_in_bpool_extension = 1
GROUP BY DB_NAME(database_id) 
ORDER BY [Buffer size(MB)] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// BPE is available in both Standard Edition and Enterprise Edition
// It is a more interesting feature for Standard Edition

// Buffer Pool Extension to SSDs in SQL Server 2014
// http://blogs.technet.com/b/dataplatforminsider/archive/2013/07/25/buffer-pool-extension-to-ssds-in-sql-server-2014.aspx



// Look at buffer descriptors to see BPE usage by database (Query 22) (BPE Usage) -->
    <Query id="22" name="BPE Usage" description="Look at buffer descriptors to see BPE usage by database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT DB_NAME(database_id) AS [Database Name], COUNT(page_id) AS [Page Count],
CAST(COUNT(*)/128.0 AS DECIMAL(10, 2)) AS [Buffer size(MB)], 
AVG(read_microsec) AS [Avg Read Time (microseconds)]
FROM sys.dm_os_buffer_descriptors WITH (NOLOCK)
WHERE database_id <> 32767
AND is_in_bpool_extension = 1
GROUP BY DB_NAME(database_id) 
ORDER BY [Buffer size(MB)] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you connect missing indexes to specific stored procedures
// This can help you decide whether to add them or not


// Breaks down buffers used by current database by object (table, index) in the buffer cache  (Query 43) (Buffer Usage)
// Note: This query could take some time on a busy instance-->
    <Query id="43" name="Buffer Usage" description="Breaks down buffers used by current database by object (table, index) in the buffer cache" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(p.[object_id]) AS [ObjectName], 
p.index_id, COUNT(*)/128 AS [buffer size(MB)],  COUNT(*) AS [buffer_count] 
FROM sys.allocation_units AS a
INNER JOIN sys.dm_os_buffer_descriptors AS b WITH (NOLOCK)
ON a.allocation_unit_id = b.allocation_unit_id
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON a.container_id = p.hobt_id
WHERE b.database_id = DB_ID()
AND p.[object_id] > 100
GROUP BY p.[object_id], p.index_id
ORDER BY buffer_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you connect missing indexes to specific stored procedures
// This can help you decide whether to add them or not


// Breaks down buffers used by current database by object (table, index) in the buffer cache  (Query 54) (Buffer Usage)
// Note: This query could take some time on a busy instance-->
    <Query id="54" name="Buffer Usage" description="Breaks down buffers used by current database by object (table, index) in the buffer cache" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT OBJECT_NAME(p.[object_id]) AS [Object Name], p.index_id, 
CAST(COUNT(*)/128.0 AS DECIMAL(10, 2)) AS [Buffer size(MB)],  
COUNT(*) AS [BufferCount], p.Rows AS [Row Count],
p.data_compression_desc AS [Compression Type]
FROM sys.allocation_units AS a WITH (NOLOCK)
INNER JOIN sys.dm_os_buffer_descriptors AS b WITH (NOLOCK)
ON a.allocation_unit_id = b.allocation_unit_id
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON a.container_id = p.hobt_id
WHERE b.database_id = CONVERT(int,DB_ID())
AND p.[object_id] > 100
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'plan_%'
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'sys%'
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'xml_index_nodes%'
GROUP BY p.[object_id], p.index_id, p.data_compression_desc, p.[Rows]
ORDER BY [BufferCount] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you connect missing indexes to specific stored procedures
// This can help you decide whether to add them or not


// Breaks down buffers used by current database by object (table, index) in the buffer cache  (Query 50) (Buffer Usage)
// Note: This query could take some time on a busy instance-->
    <Query id="50" name="Buffer Usage" description="Breaks down buffers used by current database by object (table, index) in the buffer cache" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(p.[object_id]) AS [Object Name], p.index_id, 
CAST(COUNT(*)/128.0 AS DECIMAL(10, 2)) AS [Buffer size(MB)],  
COUNT(*) AS [BufferCount], p.Rows AS [Row Count],
p.data_compression_desc AS [Compression Type]
FROM sys.allocation_units AS a WITH (NOLOCK)
INNER JOIN sys.dm_os_buffer_descriptors AS b WITH (NOLOCK)
ON a.allocation_unit_id = b.allocation_unit_id
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON a.container_id = p.hobt_id
WHERE b.database_id = CONVERT(int,DB_ID())
AND p.[object_id] > 100
GROUP BY p.[object_id], p.index_id, p.data_compression_desc, p.[Rows]
ORDER BY [BufferCount] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you connect missing indexes to specific stored procedures or queries
// This can help you decide whether to add them or not


// Breaks down buffers used by current database by object (table, index) in the buffer cache  (Query 56) (Buffer Usage)
// Note: This query could take some time on a busy instance-->
    <Query id="56" name="Buffer Usage" description="Breaks down buffers used by current database by object (table, index) in the buffer cache" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(p.[object_id]) AS [Object Name], p.index_id, 
CAST(COUNT(*)/128.0 AS DECIMAL(10, 2)) AS [Buffer size(MB)],  
COUNT(*) AS [BufferCount], p.[Rows] AS [Row Count],
p.data_compression_desc AS [Compression Type]
FROM sys.allocation_units AS a WITH (NOLOCK)
INNER JOIN sys.dm_os_buffer_descriptors AS b WITH (NOLOCK)
ON a.allocation_unit_id = b.allocation_unit_id
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON a.container_id = p.hobt_id
WHERE b.database_id = CONVERT(int, DB_ID())
AND p.[object_id] > 100
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'plan_%'
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'sys%'
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'xml_index_nodes%'
GROUP BY p.[object_id], p.index_id, p.data_compression_desc, p.[Rows]
ORDER BY [BufferCount] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you connect missing indexes to specific stored procedures or queries
// This can help you decide whether to add them or not


// Breaks down buffers used by current database by object (table, index) in the buffer cache  (Query 62) (Buffer Usage)
// Note: This query could take some time on a busy instance-->
    <Query id="62" name="Buffer Usage" description="Breaks down buffers used by current database by object (table, index) in the buffer cache" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(p.[object_id]) AS [Object Name], p.index_id, 
CAST(COUNT(*)/128.0 AS DECIMAL(10, 2)) AS [Buffer size(MB)],  
COUNT(*) AS [BufferCount], p.[Rows] AS [Row Count],
p.data_compression_desc AS [Compression Type]
FROM sys.allocation_units AS a WITH (NOLOCK)
INNER JOIN sys.dm_os_buffer_descriptors AS b WITH (NOLOCK)
ON a.allocation_unit_id = b.allocation_unit_id
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON a.container_id = p.hobt_id
WHERE b.database_id = CONVERT(int, DB_ID())
AND p.[object_id] > 100
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'plan_%'
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'sys%'
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'xml_index_nodes%'
GROUP BY p.[object_id], p.index_id, p.data_compression_desc, p.[Rows]
ORDER BY [BufferCount] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you connect missing indexes to specific stored procedures or queries
// This can help you decide whether to add them or not


// Breaks down buffers used by current database by object (table, index) in the buffer cache  (Query 64) (Buffer Usage)
// Note: This query could take some time on a busy instance-->
    <Query id="64" name="Buffer Usage" description="Breaks down buffers used by current database by object (table, index) in the buffer cache" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(p.[object_id]) AS [Object Name], p.index_id, 
CAST(COUNT(*)/128.0 AS DECIMAL(10, 2)) AS [Buffer size(MB)],  
COUNT(*) AS [BufferCount], p.[Rows] AS [Row Count],
p.data_compression_desc AS [Compression Type]
FROM sys.allocation_units AS a WITH (NOLOCK)
INNER JOIN sys.dm_os_buffer_descriptors AS b WITH (NOLOCK)
ON a.allocation_unit_id = b.allocation_unit_id
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON a.container_id = p.hobt_id
WHERE b.database_id = CONVERT(int, DB_ID())
AND p.[object_id] > 100
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'plan_%'
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'sys%'
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'xml_index_nodes%'
GROUP BY p.[object_id], p.index_id, p.data_compression_desc, p.[Rows]
ORDER BY [BufferCount] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you connect missing indexes to specific stored procedures or queries
// This can help you decide whether to add them or not


// Breaks down buffers used by current database by object (table, index) in the buffer cache  (Query 64) (Buffer Usage)
// Note: This query could take some time on a busy instance-->
    <Query id="64" name="Buffer Usage" description="Breaks down buffers used by current database by object (table, index) in the buffer cache" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(p.[object_id]) AS [Object Name], p.index_id, 
CAST(COUNT(*)/128.0 AS DECIMAL(10, 2)) AS [Buffer size(MB)],  
COUNT(*) AS [BufferCount], p.[Rows] AS [Row Count],
p.data_compression_desc AS [Compression Type]
FROM sys.allocation_units AS a WITH (NOLOCK)
INNER JOIN sys.dm_os_buffer_descriptors AS b WITH (NOLOCK)
ON a.allocation_unit_id = b.allocation_unit_id
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON a.container_id = p.hobt_id
WHERE b.database_id = CONVERT(int, DB_ID())
AND p.[object_id] > 100
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'plan_%'
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'sys%'
AND OBJECT_NAME(p.[object_id]) NOT LIKE N'xml_index_nodes%'
GROUP BY p.[object_id], p.index_id, p.data_compression_desc, p.[Rows]
ORDER BY [BufferCount] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you the model number and rated clock speed of your processor(s)
// Your processors may be running at less than the rated clock speed due
// to the Windows Power Plan or hardware power management

// You can use CPU-Z to get your actual CPU core speed and a lot of other useful information
// http://www.cpuid.com/softwares/cpu-z.html

// You can learn more about processor selection for SQL Server by following this link
// http://www.sqlskills.com/blogs/glenn/processor-selection-for-sql-server/



// Get the current node name from your cluster nodes  (Query 13) (Cluster Node Properties)
// (if your database server is in a failover cluster)-->
    <Query id="13" name="Cluster Node Properties" description="Get the current node name from your cluster nodes" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT NodeName
FROM sys.dm_os_cluster_nodes WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you the model number and rated clock speed of your processor(s)
// Your processors may be running at less that the rated clock speed due
// to the Windows Power Plan or hardware power management

// You can use CPU-Z to get your actual CPU core speed and a lot of other useful information
// http://www.cpuid.com/softwares/cpu-z.html

// You can learn more about processor selection for SQL Server by following this link
// http://www.sqlskills.com/blogs/glenn/processor-selection-for-sql-server/



// Get the current node name from your cluster nodes  (Query 11) (Cluster Node Properties)
// (if your database server is in a failover cluster)-->
    <Query id="11" name="Cluster Node Properties" description="Get the current node name from your cluster nodes" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT NodeName
FROM sys.dm_os_cluster_nodes WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you the count of your SQL Server Error Logs, and shows you how large each one is


// You can skip the next two queries if you know you don't have a clustered instance


// Get information about your cluster nodes and their status  (Query 14) (Cluster Node Properties)
// (if your database server is in a failover cluster)-->
    <Query id="14" name="Cluster Node Properties" description="Get information about your cluster nodes and their status" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT NodeName, status_description, is_current_owner
FROM sys.dm_os_cluster_nodes WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you the count of your SQL Server Error Logs, and shows you how large each one is


// You can skip the next two queries if you know you don't have a clustered instance


// Get information about your cluster nodes and their status  (Query 15) (Cluster Node Properties)
// (if your database server is in a failover cluster)-->
    <Query id="15" name="Cluster Node Properties" description="Get information about your cluster nodes and their status" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT NodeName, status_description, is_current_owner
FROM sys.dm_os_cluster_nodes WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you the count of your SQL Server Error Logs, and shows you how large each one is


// You can skip the next two queries if you know you don't have a clustered instance


// Get information about your cluster nodes and their status  (Query 15) (Cluster Node Properties)
// (if your database server is in a failover cluster)-->
    <Query id="15" name="Cluster Node Properties" description="Get information about your cluster nodes and their status" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT NodeName, status_description, is_current_owner
FROM sys.dm_os_cluster_nodes WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you the count of your SQL Server Error Logs, and shows you how large each one is


// You can skip the next two queries if you know you don't have a clustered instance


// Get information about your cluster nodes and their status  (Query 15) (Cluster Node Properties)
// (if your database server is in a failover cluster)-->
    <Query id="15" name="Cluster Node Properties" description="Get information about your cluster nodes and their status" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT NodeName, status_description, is_current_owner
FROM sys.dm_os_cluster_nodes WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you some index usage statistics for in-memory OLTP
// Returns no data if you are not using in-memory OLTP

// Guidelines for Using Indexes on Memory-Optimized Tables
// https://msdn.microsoft.com/en-us/library/dn133166.aspx


// Look at Columnstore index physical statistics (Query 73) (Columnstore Index Physical Stat)-->
    <Query id="73" name="Columnstore Index Physical Stat" description="Look at Columnstore index physical statistics" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(ps.object_id) AS [TableName],  
	i.[name] AS [IndexName], ps.index_id, ps.partition_number,
	ps.delta_store_hobt_id, ps.state_desc, ps.total_rows, ps.size_in_bytes,
	ps.trim_reason_desc, ps.generation, ps.transition_to_compressed_state_desc,
	ps.has_vertipaq_optimization, ps.deleted_rows,
	100 * (ISNULL(ps.deleted_rows, 0))/ps.total_rows AS [Fragmentation]
FROM sys.dm_db_column_store_row_group_physical_stats AS ps WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ps.object_id = i.object_id 
AND ps.index_id = i.index_id
ORDER BY ps.object_id, ps.partition_number, ps.row_group_id OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you some index usage statistics for in-memory OLTP
// Returns no data if you are not using in-memory OLTP

// Guidelines for Using Indexes on Memory-Optimized Tables
// https://msdn.microsoft.com/en-us/library/dn133166.aspx


// Look at Columnstore index physical statistics (Query 73) (Columnstore Index Physical Stat)-->
    <Query id="73" name="Columnstore Index Physical Stat" description="Look at Columnstore index physical statistics" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(ps.object_id) AS [TableName],  
	i.[name] AS [IndexName], ps.index_id, ps.partition_number,
	ps.delta_store_hobt_id, ps.state_desc, ps.total_rows, ps.size_in_bytes,
	ps.trim_reason_desc, ps.generation, ps.transition_to_compressed_state_desc,
	ps.has_vertipaq_optimization, ps.deleted_rows,
	100 * (ISNULL(ps.deleted_rows, 0))/ps.total_rows AS [Fragmentation]
FROM sys.dm_db_column_store_row_group_physical_stats AS ps WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ps.object_id = i.object_id 
AND ps.index_id = i.index_id
ORDER BY ps.object_id, ps.partition_number, ps.row_group_id OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you the model number and rated clock speed of your processor(s)
// Your processors may be running at less that the rated clock speed due
// to the Windows Power Plan or hardware power management

// You can use CPU-Z to get your actual CPU core speed and a lot of other useful information
// http://www.cpuid.com/softwares/cpu-z.html

// You can learn more about processor selection for SQL Server by following this link
// http://www.sqlskills.com/blogs/glenn/processor-selection-for-sql-server/



// Get configuration values for instance  (Query 10) (Configuration Values)-->
    <Query id="10" name="Configuration Values" description="Get configuration values for instance" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT name, value, value_in_use, minimum, maximum, [description], is_dynamic, is_advanced
FROM sys.configurations WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Knowing which node owns the cluster resources is critical
// Especially when you are installing Windows or SQL Server updates
// You will see no results if your instance is not clustered


// Get configuration values for instance  (Query 14) (Configuration Values)-->
    <Query id="14" name="Configuration Values" description="Get configuration values for instance" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT name, value, value_in_use, minimum, maximum, [description], is_dynamic, is_advanced
FROM sys.configurations WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Knowing which node owns the cluster resources is critical
// Especially when you are installing Windows or SQL Server updates
// You will see no results if your instance is not clustered


// Get configuration values for instance  (Query 12) (Configuration Values)-->
    <Query id="12" name="Configuration Values" description="Get configuration values for instance" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT name, value, value_in_use, minimum, maximum, [description], is_dynamic, is_advanced
FROM sys.configurations WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you a lot of useful information about your instance of SQL Server,
// such as the ProcessID for SQL Server and your collation
// Note: Some columns will be NULL on older SQL Server builds

// SERVERPROPERTY (Transact-SQL)
// http://bit.ly/2eeaXeI


// Get instance-level configuration values for instance  (Query 4) (Configuration Values)-->
    <Query id="4" name="Configuration Values" description="Get instance-level configuration values for instance" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT name, value, value_in_use, minimum, maximum, [description], is_dynamic, is_advanced
FROM sys.configurations WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you a lot of useful information about your instance of SQL Server,
// such as the ProcessID for SQL Server and your collation
// Note: Some columns will be NULL on older SQL Server builds

// SERVERPROPERTY (Transact-SQL)
// http://bit.ly/2eeaXeI


// Get instance-level configuration values for instance  (Query 4) (Configuration Values)-->
    <Query id="4" name="Configuration Values" description="Get instance-level configuration values for instance" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT name, value, value_in_use, minimum, maximum, [description], is_dynamic, is_advanced
FROM sys.configurations WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you a lot of useful information about your instance of SQL Server,
// such as the ProcessID for SQL Server and your collation
// Note: Some columns will be NULL on older SQL Server builds

// SERVERPROPERTY (Transact-SQL)
// http://bit.ly/2eeaXeI



// Get instance-level configuration values for instance  (Query 4) (Configuration Values)-->
    <Query id="4" name="Configuration Values" description="Get instance-level configuration values for instance" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT name, value, value_in_use, minimum, maximum, [description], is_dynamic, is_advanced
FROM sys.configurations WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you a lot of useful information about your instance of SQL Server,
// such as the ProcessID for SQL Server and your collation
// Note: Some columns will be NULL on older SQL Server builds

// SERVERPROPERTY (Transact-SQL)
// http://bit.ly/2eeaXeI



// Get instance-level configuration values for instance  (Query 4) (Configuration Values)-->
    <Query id="4" name="Configuration Values" description="Get instance-level configuration values for instance" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT name, value, value_in_use, minimum, maximum, [description], is_dynamic, is_advanced
FROM sys.configurations WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Signal Waits above 10-15% is usually a confirming sign of CPU pressure
// Cumulative wait stats are not as useful on an idle instance that is not under load or performance pressure
// Resource waits are non-CPU related waits


//  Get logins that are connected and how many sessions they have (Query 23) (Connection Counts)-->
    <Query id="23" name="Connection Counts" description="Get logins that are connected and how many sessions they have" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT login_name, [program_name], COUNT(session_id) AS [session_count] 
FROM sys.dm_exec_sessions WITH (NOLOCK)
GROUP BY login_name, [program_name]
ORDER BY COUNT(session_id) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Signal Waits above 10-15% is usually a confirming sign of CPU pressure
// Cumulative wait stats are not as useful on an idle instance that is not under load or performance pressure
// Resource waits are non-CPU related waits


//  Get logins that are connected and how many sessions they have (Query 29) (Connection Counts)-->
    <Query id="29" name="Connection Counts" description="Get logins that are connected and how many sessions they have" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT login_name, [program_name], COUNT(session_id) AS [session_count] 
FROM sys.dm_exec_sessions WITH (NOLOCK)
GROUP BY login_name, [program_name]
ORDER BY COUNT(session_id) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Signal Waits above 10-15% is usually a confirming sign of CPU pressure
// Cumulative wait stats are not as useful on an idle instance that is not under load or performance pressure
// Resource waits are non-CPU related waits


//  Get logins that are connected and how many sessions they have (Query 25) (Connection Counts)-->
    <Query id="25" name="Connection Counts" description="Get logins that are connected and how many sessions they have" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT login_name, [program_name], COUNT(session_id) AS [session_count] 
FROM sys.dm_exec_sessions WITH (NOLOCK)
GROUP BY login_name, [program_name]
ORDER BY COUNT(session_id) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This can help characterize your workload and
// determine whether you are seeing a normal level of activity


// Get a count of SQL connections by IP address (Query 24) (Connection Counts by IP Address)-->
    <Query id="24" name="Connection Counts by IP Address" description="Get a count of SQL connections by IP address" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT ec.client_net_address, es.[program_name], es.[host_name], es.login_name, 
COUNT(ec.session_id) AS [connection count] 
FROM sys.dm_exec_sessions AS es WITH (NOLOCK) 
INNER JOIN sys.dm_exec_connections AS ec WITH (NOLOCK) 
ON es.session_id = ec.session_id 
GROUP BY ec.client_net_address, es.[program_name], es.[host_name], es.login_name  
ORDER BY ec.client_net_address, es.[program_name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This can help characterize your workload and
// determine whether you are seeing a normal level of activity


// Get a count of SQL connections by IP address (Query 30) (Connection Counts by IP Address)-->
    <Query id="30" name="Connection Counts by IP Address" description="Get a count of SQL connections by IP address" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT ec.client_net_address, es.[program_name], es.[host_name], es.login_name, 
COUNT(ec.session_id) AS [connection count] 
FROM sys.dm_exec_sessions AS es WITH (NOLOCK) 
INNER JOIN sys.dm_exec_connections AS ec WITH (NOLOCK) 
ON es.session_id = ec.session_id 
GROUP BY ec.client_net_address, es.[program_name], es.[host_name], es.login_name  
ORDER BY ec.client_net_address, es.[program_name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This can help characterize your workload and
// determine whether you are seeing a normal level of activity


// Get a count of SQL connections by IP address (Query 26) (Connection Counts by IP Address)-->
    <Query id="26" name="Connection Counts by IP Address" description="Get a count of SQL connections by IP address" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT ec.client_net_address, es.[program_name], es.[host_name], es.login_name, 
COUNT(ec.session_id) AS [connection count] 
FROM sys.dm_exec_sessions AS es WITH (NOLOCK) 
INNER JOIN sys.dm_exec_connections AS ec WITH (NOLOCK) 
ON es.session_id = ec.session_id 
GROUP BY ec.client_net_address, es.[program_name], es.[host_name], es.login_name  
ORDER BY ec.client_net_address, es.[program_name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Cumulative wait stats are not as useful on an idle instance that is not under load or performance pressure

// SQL Server Wait Types Library (Paul Randal)
// https://www.sqlskills.com/help/waits/

// The SQL Server Wait Type Repository
// http://blogs.msdn.com/b/psssql/archive/2009/11/03/the-sql-server-wait-type-repository.aspx

// Wait statistics, or please tell me where it hurts
// http://www.sqlskills.com/blogs/paul/wait-statistics-or-please-tell-me-where-it-hurts/

// SQL Server 2005 Performance Tuning using the Waits and Queues
// http://technet.microsoft.com/en-us/library/cc966413.aspx

// sys.dm_os_wait_stats (Transact-SQL)
// http://msdn.microsoft.com/en-us/library/ms179984(v=sql.120).aspx



// Get a count of SQL connections by IP address (Query 32) (Connection Counts by IP Address)-->
    <Query id="32" name="Connection Counts by IP Address" description="Get a count of SQL connections by IP address" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT ec.client_net_address, es.[program_name], es.[host_name], es.login_name, 
COUNT(ec.session_id) AS [connection count] 
FROM sys.dm_exec_sessions AS es WITH (NOLOCK) 
INNER JOIN sys.dm_exec_connections AS ec WITH (NOLOCK) 
ON es.session_id = ec.session_id 
GROUP BY ec.client_net_address, es.[program_name], es.[host_name], es.login_name  
ORDER BY ec.client_net_address, es.[program_name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Cumulative wait stats are not as useful on an idle instance that is not under load or performance pressure

// SQL Server Wait Types Library (Paul Randal)
// https://www.sqlskills.com/help/waits/

// The SQL Server Wait Type Repository
// http://blogs.msdn.com/b/psssql/archive/2009/11/03/the-sql-server-wait-type-repository.aspx

// Wait statistics, or please tell me where it hurts
// http://www.sqlskills.com/blogs/paul/wait-statistics-or-please-tell-me-where-it-hurts/

// SQL Server 2005 Performance Tuning using the Waits and Queues
// http://technet.microsoft.com/en-us/library/cc966413.aspx

// sys.dm_os_wait_stats (Transact-SQL)
// http://msdn.microsoft.com/en-us/library/ms179984(v=sql.120).aspx



// Get a count of SQL connections by IP address (Query 37) (Connection Counts by IP Address)-->
    <Query id="37" name="Connection Counts by IP Address" description="Get a count of SQL connections by IP address" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT ec.client_net_address, es.[program_name], es.[host_name], es.login_name, 
COUNT(ec.session_id) AS [connection count] 
FROM sys.dm_exec_sessions AS es WITH (NOLOCK) 
INNER JOIN sys.dm_exec_connections AS ec WITH (NOLOCK) 
ON es.session_id = ec.session_id 
GROUP BY ec.client_net_address, es.[program_name], es.[host_name], es.login_name  
ORDER BY ec.client_net_address, es.[program_name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Cumulative wait stats are not as useful on an idle instance that is not under load or performance pressure

// SQL Server Wait Types Library (Paul Randal)
// https://www.sqlskills.com/help/waits/

// The SQL Server Wait Type Repository
// http://blogs.msdn.com/b/psssql/archive/2009/11/03/the-sql-server-wait-type-repository.aspx

// Wait statistics, or please tell me where it hurts
// http://www.sqlskills.com/blogs/paul/wait-statistics-or-please-tell-me-where-it-hurts/

// SQL Server 2005 Performance Tuning using the Waits and Queues
// http://technet.microsoft.com/en-us/library/cc966413.aspx

// sys.dm_os_wait_stats (Transact-SQL)
// http://msdn.microsoft.com/en-us/library/ms179984(v=sql.120).aspx



// Get a count of SQL connections by IP address (Query 37) (Connection Counts by IP Address)-->
    <Query id="37" name="Connection Counts by IP Address" description="Get a count of SQL connections by IP address" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT ec.client_net_address, es.[program_name], es.[host_name], es.login_name, 
COUNT(ec.session_id) AS [connection count] 
FROM sys.dm_exec_sessions AS es WITH (NOLOCK) 
INNER JOIN sys.dm_exec_connections AS ec WITH (NOLOCK) 
ON es.session_id = ec.session_id 
GROUP BY ec.client_net_address, es.[program_name], es.[host_name], es.login_name  
ORDER BY ec.client_net_address, es.[program_name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Cumulative wait stats are not as useful on an idle instance that is not under load or performance pressure

// SQL Server Wait Types Library (Paul Randal)
// https://www.sqlskills.com/help/waits/

// The SQL Server Wait Type Repository
// http://blogs.msdn.com/b/psssql/archive/2009/11/03/the-sql-server-wait-type-repository.aspx

// Wait statistics, or please tell me where it hurts
// http://www.sqlskills.com/blogs/paul/wait-statistics-or-please-tell-me-where-it-hurts/

// SQL Server 2005 Performance Tuning using the Waits and Queues
// http://technet.microsoft.com/en-us/library/cc966413.aspx

// sys.dm_os_wait_stats (Transact-SQL)
// http://msdn.microsoft.com/en-us/library/ms179984(v=sql.120).aspx



// Get a count of SQL connections by IP address (Query 37) (Connection Counts by IP Address)-->
    <Query id="37" name="Connection Counts by IP Address" description="Get a count of SQL connections by IP address" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT ec.client_net_address, es.[program_name], es.[host_name], es.login_name, 
COUNT(ec.session_id) AS [connection count] 
FROM sys.dm_exec_sessions AS es WITH (NOLOCK) 
INNER JOIN sys.dm_exec_connections AS ec WITH (NOLOCK) 
ON es.session_id = ec.session_id 
GROUP BY ec.client_net_address, es.[program_name], es.[host_name], es.login_name  
ORDER BY ec.client_net_address, es.[program_name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// SQL Server 2012 RTM Branch Builds						SQL Server 2012 SP1 Branch Builds					SQL Server 2012 SP2 Branch Builds						SQL Server 2012 SP3 Branch Builds
// Build			Description			Release Date		Build			Description		Release Date		Build			Description		    Release Date        Build			Description		    Release Date
// 11.0.2100		RTM					  3/6/2012  
// 11.0.2316		RTM CU1				 4/12/2012
// 11.0.2325        RTM CU2				 6/18/2012 //>		11.0.3000		SP1 RTM			11/7/2012
// 11.0.2332		RTM CU3				 8/31/2012
// 11.0.2376	    RTM CU3 + QFE	     10/9/2012
// 11.0.2383	    RTM CU4			    10/15/2012 //>		11.0.3321		SP1 CU1			11/20/2012
// 11.0.2395		RTM CU5				12/17/2012 //>      11.0.3339		SP1 CU2			1/21/2013
// 11.0.2401        RTM CU6              2/18/2013 //>      11.0.3349       SP1 CU3			3/18/2013
// 11.0.2405        RTM CU7              4/15/2013 //>      11.0 3368       SP1 CU4         5/30/2013
// 11.0.2410        RTM CU8              6/17/2013 //>      11.0.3373       SP1 CU5         7/15/2013
// 11.0.2419        RTM CU9              8/20/2013 //>      11.0.3381		SP1 CU6			9/16/2013
// 11.0.2420        RTM CU10            10/21/2013 //>		11.0.3393       SP1 CU7         11/18/2013
// 11.0.2424        RTM CU11            12/16/2003 //>      11.0.3401       SP1 CU8         1/20/2014
//                                                          11.0.3412       SP1 CU9         3/17/2014 //>		11.0.5058		SP2 RTM			    6/10/2014
//                                                          11.0.3431       SP1 CU10        5/19/2014
//                                                          11.0.3449       SP1 CU11        7/21/2014 //>		11.0.5532		SP2 CU1			    7/23/2014
//                                                          11.0.3470       SP1 CU12        9/15/2014 //>       11.0.5548       SP2 CU2             9/15/2014
//                                                          11.0.3482		SP1 CU13        11/17/2014//>       11.0.5556		SP2 CU3            11/17/2014
//                                                          11.0.3486       SP1 CU14        1/19/2015 //>       11.0.5569       SP2 CU4             1/19/2015
//                                                                                                              11.0.5571       SP2 CU4 + COD HF     2/4/2015  
//                                                          11.0.3487		SP1 CU15		3/16/2015 //>       11.0.5582       SP2 CU5             3/16/2015
//															11.0.3492       SP1 CU16        5/18/2015 //>       11.0.5592		SP2 CU6				5/18/2015
//                                                                                                              11.0.5623       SP2 CU7				7/20/2015
//                                                                                                              11.0.5634		SP2 CU8				9/21/2015
//																												11.0.5641		SP2 CU9			   11/16/2015   ////>  11.0.6290		SP3 RTM			11/22/2015
//																												11.0.5644		SP2 CU10			1/18/2016   ////>  11.0.6518		SP3 CU1			 1/18/2016
//																												11.0.5646		SP2 CU11			3/21/2016	////>  11.0.6523		SP3 CU2			 3/21/2016
//																												11.0.5649		SP2 CU12			5/16/2016	////>  11.0.6537		SP3 CU3			 5/16/2016
//																												11.0.5655		SP2 CU13			7/18/2016	////>  11.0.6540		SP3 CU4			 7/18/2016	
//																												11.0.5657		SP2 CU14		    9/19/2016   ////>  11.0.6544		SP3 CU5			 9/20/2016
//																												11.0.5676		SP2 CU15 			11/16/2016  ////>  11.0.6567		SP3 CU6 		11/16/2016                                                             				
//																												
// Announcing updates to the SQL Server Incremental Servicing Model (ISM)
// https://blogs.msdn.microsoft.com/sqlreleaseservices/announcing-updates-to-the-sql-server-incremental-servicing-model-ism/

// How to determine the version, edition and update level of SQL Server and its components 
// https://support.microsoft.com/en-us/kb/321185

// SQL Server 2012 SP3 build versions
// https://support.microsoft.com/en-us/kb/3133750 

// SQL Server 2012 SP2 build versions 
// http://support.microsoft.com/kb/2983249

// The SQL Server 2012 builds that were released after SQL Server 2012 Service Pack 1 was released
// http://support.microsoft.com/kb/2772858

// The SQL Server 2012 builds that were released after SQL Server 2012 was released
// http://support.microsoft.com/kb/2692828


// Recommended updates and configuration options for SQL Server 2012 and SQL Server 2014 used with high-performance workloads
// http://support.microsoft.com/kb/2964518/EN-US

// Performance and Stability Related Fixes in Post-SQL Server 2012 SP3 Builds
// http://www.sqlskills.com/blogs/glenn/performance-and-stability-related-fixes-in-post-sql-server-2012-sp3-builds/

// Performance and Stability Related Fixes in Post-SQL Server 2012 SP2 Builds
// http://www.sqlskills.com/blogs/glenn/performance-and-stability-related-fixes-in-post-sql-server-2012-sp2-builds/

// Performance and Stability Related Fixes in Post-SQL Server 2012 SP1 Builds
// http://www.sqlskills.com/blogs/glenn/performance-and-stability-related-fixes-in-post-sql-server-2012-sp1-builds-2/

// Performance Related Fixes in Post-SQL Server 2012 RTM Builds
// http://www.sqlskills.com/blogs/glenn/performance-related-fixes-in-post-sql-server-2012-rtm-builds/




// Get socket, physical core and logical core count from the SQL Server Error log. (Query 2) (Core Counts)
// This query might take a few seconds if you have not recycled your error log recently-->
    <Query id="2" name="Core Counts" description="Get socket, physical core and logical core count from the SQL Server Error log." file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
EXEC sys.xp_readerrorlog 0, 1, N'detected', N'socket';
]]></Query>
    <!--//////
   
// SQL Server 2014 RTM Branch Builds						SQL Server 2014 SP1 Branch Builds						SQL Server 2014 SP2 Branch Builds					
// Build			Description			Release Date		Build			Description		Release Date			Build			Description		Release Date		
// 11.0.9120        CTP1				6/2/2013
// 12.0.1524		CTP2				10/15/2013
// 12.0.2000        RTM					4/1/2014
// 12.0.2342        CU1                 4/21/2014
// 12.0.2370        CU2                 6/27/2014
// 12.0.2402		CU3					8/18/2014
// 12.0.2430        CU4					10/21/2014
// 12.0.2456		CU5					12/17/2014	////>	12.0.4100		SP1 RTM			5/4/2015
// 12.0.2474		CU5 + COD HF		2/3/2015   
// 12.0.2480		CU6					2/16/2015
// 12.0.2495        CU7                 4/20/2015
// 12.0.2546		CU8					6/19/2015			12.0.4416		SP1 CU1			6/19/2015
// 12.0.2553		CU9					8/17/2015			12.0.4422		SP1 CU2			8/17/2015
// 12.0.2556		CU10				10/19/2015          12.0.4427		SP1 CU3			10/19/2015
// 12.0.2560		CU11				12/21/2015			12.0.4436		SP1 CU4			12/21/2015
// 12.0.2564		CU12				2/22/2016			12.0.4439		SP1 CU5			2/22/2016
// 12.0.2568		CU13				4/18/2016			12.0.4449		SP1 CU6			4/18/2016 (Deprecated)
//															12.0.4457		SP1 CU6 		5/30/2016 (Re-release)
// 12.0.2569		CU14				6/20/2016			12.0.4459		SP1 CU7			6/20/2016 //////////->	12.0.5000		SP2 RTM			7/11/2016
//															12.0.4468		SP1 CU8			8/15/2016				12.0.5511		SP2 CU1			8/25/2016
//                                                          12.0.4474		SP1 CU9		    10/17/2016				12.0.5522		SP2 CU2			10/17/2016
//															12.0.4487		SP1 CU9 + HF	11/8/2016				12.0.5532		SP2 CU2 + HF    11/8/2016  https://technet.microsoft.com/library/security/MS16-136
//                                                          12.0.4491       SP1 CU10		12/28/2016				12.0.5537		SP2 CU3			12/28/2016


// Announcing updates to the SQL Server Incremental Servicing Model (ISM)
// https://blogs.msdn.microsoft.com/sqlreleaseservices/announcing-updates-to-the-sql-server-incremental-servicing-model-ism/

// How to determine the version, edition and update level of SQL Server and its components 
// https://support.microsoft.com/en-us/kb/321185

// SQL Server 2014 build versions
// http://support.microsoft.com/kb/2936603

// Recommended updates and configuration options for SQL Server 2012 and SQL Server 2014 used with high-performance workloads
// http://support.microsoft.com/kb/2964518/EN-US

// Performance and Stability Related Fixes in Post-SQL Server 2014 RTM Builds
// http://www.sqlskills.com/blogs/glenn/performance-and-stability-related-fixes-in-post-sql-server-2014-rtm-builds/

// Performance and Stability Related Fixes in Post-SQL Server 2014 SP1 Builds
// http://www.sqlskills.com/blogs/glenn/performance-and-stability-related-fixes-in-post-sql-server-2014-sp1-builds/

// Announcing updates to the SQL Server Incremental Servicing Model (ISM)
// https://blogs.msdn.microsoft.com/sqlreleaseservices/announcing-updates-to-the-sql-server-incremental-servicing-model-ism/


// Get socket, physical core and logical core count from the SQL Server Error log. (Query 2) (Core Counts)
// This query might take a few seconds if you have not recycled your error log recently-->
    <Query id="2" name="Core Counts" description="Get socket, physical core and logical core count from the SQL Server Error log." file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
EXEC sys.xp_readerrorlog 0, 1, N'detected', N'socket';
]]></Query>
    <!--//////
   
// High VLF counts can affect write performance 
// and they can make full database restores and crash recovery take much longer
// Try to keep your VLF counts under 200 in most cases



// Get CPU utilization by database (Query 18) (CPU Usage by Database)-->
    <Query id="18" name="CPU Usage by Database" description="Get CPU utilization by database" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
WITH DB_CPU_Stats
AS
(SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]
 FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
 CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID] 
              FROM sys.dm_exec_plan_attributes(qs.plan_handle)
              WHERE attribute = N'dbid') AS pa
 GROUP BY DatabaseID)
SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],
       [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)], 
       CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent]
FROM DB_CPU_Stats
WHERE DatabaseID <> 32767 -- ResourceDB
ORDER BY [CPU Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// High VLF counts can affect write performance 
// and they can make full database restores and crash recovery take much longer
// Try to keep your VLF counts under 200 in most cases (depending on log file size)



// Get CPU utilization by database (Query 24) (CPU Usage by Database)-->
    <Query id="24" name="CPU Usage by Database" description="Get CPU utilization by database" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
WITH DB_CPU_Stats
AS
(SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]
 FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
 CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID] 
              FROM sys.dm_exec_plan_attributes(qs.plan_handle)
              WHERE attribute = N'dbid') AS pa
 GROUP BY DatabaseID)
SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],
       [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)], 
       CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent]
FROM DB_CPU_Stats
WHERE DatabaseID <> 32767 -- ResourceDB
ORDER BY [CPU Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// High VLF counts can affect write performance 
// and they can make full database restores and crash recovery take much longer
// Try to keep your VLF counts under 200 in most cases



// Get CPU utilization by database (Query 20) (CPU Usage by Database)-->
    <Query id="20" name="CPU Usage by Database" description="Get CPU utilization by database" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
WITH DB_CPU_Stats
AS
(SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]
 FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
 CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID] 
              FROM sys.dm_exec_plan_attributes(qs.plan_handle)
              WHERE attribute = N'dbid') AS pa
 GROUP BY DatabaseID)
SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],
       [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)], 
       CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent]
FROM DB_CPU_Stats
WHERE DatabaseID <> 32767 -- ResourceDB
ORDER BY [CPU Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// High VLF counts can affect write performance to the log file 
// and they can make full database restores and crash recovery take much longer
// Try to keep your VLF counts under 200 in most cases (depending on log file size)



// Get CPU utilization by database (Query 28) (CPU Usage by Database)-->
    <Query id="28" name="CPU Usage by Database" description="Get CPU utilization by database" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
WITH DB_CPU_Stats
AS
(SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]
 FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
 CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID] 
              FROM sys.dm_exec_plan_attributes(qs.plan_handle)
              WHERE attribute = N'dbid') AS pa
 GROUP BY DatabaseID)
SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],
       [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)], 
       CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent]
FROM DB_CPU_Stats
WHERE DatabaseID <> 32767 -- ResourceDB
ORDER BY [CPU Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// High VLF counts can affect write performance to the log file 
// and they can make full database restores and crash recovery take much longer
// Try to keep your VLF counts under 200 in most cases (depending on log file size)

// Important change to VLF creation algorithm in SQL Server 2014
// http://www.sqlskills.com/blogs/paul/important-change-vlf-creation-algorithm-sql-server-2014/



// Get CPU utilization by database (Query 33) (CPU Usage by Database)-->
    <Query id="33" name="CPU Usage by Database" description="Get CPU utilization by database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
WITH DB_CPU_Stats
AS
(SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]
 FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
 CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID] 
              FROM sys.dm_exec_plan_attributes(qs.plan_handle)
              WHERE attribute = N'dbid') AS pa
 GROUP BY DatabaseID)
SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],
       [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)], 
       CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent]
FROM DB_CPU_Stats
WHERE DatabaseID <> 32767 -- ResourceDB
ORDER BY [CPU Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// High VLF counts can affect write performance to the log file
// and they can make full database restores and crash recovery take much longer
// Try to keep your VLF counts under 200 in most cases (depending on log file size)

// Important change to VLF creation algorithm in SQL Server 2014
// http://www.sqlskills.com/blogs/paul/important-change-vlf-creation-algorithm-sql-server-2014/



// Get CPU utilization by database (Query 33) (CPU Usage by Database)-->
    <Query id="33" name="CPU Usage by Database" description="Get CPU utilization by database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
WITH DB_CPU_Stats
AS
(SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]
 FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
 CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID] 
              FROM sys.dm_exec_plan_attributes(qs.plan_handle)
              WHERE attribute = N'dbid') AS pa
 GROUP BY DatabaseID)
SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],
       [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)], 
       CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent]
FROM DB_CPU_Stats
WHERE DatabaseID <> 32767 -- ResourceDB
ORDER BY [CPU Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// High VLF counts can affect write performance to the log file
// and they can make full database restores and crash recovery take much longer
// Try to keep your VLF counts under 200 in most cases (depending on log file size)

// Important change to VLF creation algorithm in SQL Server 2014
// http://www.sqlskills.com/blogs/paul/important-change-vlf-creation-algorithm-sql-server-2014/



// Get CPU utilization by database (Query 33) (CPU Usage by Database)-->
    <Query id="33" name="CPU Usage by Database" description="Get CPU utilization by database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
WITH DB_CPU_Stats
AS
(SELECT pa.DatabaseID, DB_Name(pa.DatabaseID) AS [Database Name], SUM(qs.total_worker_time/1000) AS [CPU_Time_Ms]
 FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
 CROSS APPLY (SELECT CONVERT(int, value) AS [DatabaseID] 
              FROM sys.dm_exec_plan_attributes(qs.plan_handle)
              WHERE attribute = N'dbid') AS pa
 GROUP BY DatabaseID)
SELECT ROW_NUMBER() OVER(ORDER BY [CPU_Time_Ms] DESC) AS [CPU Rank],
       [Database Name], [CPU_Time_Ms] AS [CPU Time (ms)], 
       CAST([CPU_Time_Ms] * 1.0 / SUM([CPU_Time_Ms]) OVER() * 100.0 AS DECIMAL(5, 2)) AS [CPU Percent]
FROM DB_CPU_Stats
WHERE DatabaseID <> 32767 -- ResourceDB
ORDER BY [CPU Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Sustained values above 10 suggest further investigation in that area
// High Avg Task Counts are often caused by blocking/deadlocking or other resource contention

// Sustained values above 1 suggest further investigation in that area
// High Avg Runnable Task Counts are a good sign of CPU pressure
// High Avg Pending DiskIO Counts are a sign of disk pressure

// How to Do Some Very Basic SQL Server Monitoring
// http://www.sqlskills.com/blogs/glenn/how-to-do-some-very-basic-sql-server-monitoring/



// Get CPU Utilization History for last 256 minutes (in one minute intervals) (Query 26) (CPU Utilization History)
// This version works with SQL Server 2005-->
    <Query id="26" name="CPU Utilization History" description="Get CPU Utilization History for last 256 minutes (in one minute intervals)" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
DECLARE @ts_now bigint; 
SET @ts_now = (SELECT cpu_ticks / CONVERT(float, cpu_ticks_in_ms) FROM sys.dm_os_sys_info WITH (NOLOCK)); 

SELECT TOP(256) SQLProcessUtilization AS [SQL Server Process CPU Utilization], 
               SystemIdle AS [System Idle Process], 
               100 - SystemIdle - SQLProcessUtilization AS [Other Process CPU Utilization], 
               DATEADD(ms, -1 * (@ts_now - [timestamp]), GETDATE()) AS [Event Time] 
FROM ( 
	  SELECT record.value('(./Record/@id)[1]', 'int') AS record_id, 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') 
			AS [SystemIdle], 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 
			'int') 
			AS [SQLProcessUtilization], [timestamp] 
	  FROM ( 
			SELECT [timestamp], CONVERT(xml, record) AS [record] 
			FROM sys.dm_os_ring_buffers WITH (NOLOCK)
			WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR' 
			AND record LIKE '%<SystemHealth>%') AS x 
	  ) AS y 
ORDER BY record_id DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Sustained values above 10 suggest further investigation in that area
// High Avg Task Counts are often caused by blocking/deadlocking or other resource contention

// Sustained values above 1 suggest further investigation in that area
// High Avg Runnable Task Counts are a good sign of CPU pressure
// High Avg Pending DiskIO Counts are a sign of disk pressure

// How to Do Some Very Basic SQL Server Monitoring
// http://www.sqlskills.com/blogs/glenn/how-to-do-some-very-basic-sql-server-monitoring/



// Get CPU Utilization History for last 256 minutes (in one minute intervals)  (Query 32) (CPU Utilization History)
// This version works with SQL Server 2008 R2-->
    <Query id="32" name="CPU Utilization History" description="Get CPU Utilization History for last 256 minutes (in one minute intervals)" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
DECLARE @ts_now bigint = (SELECT cpu_ticks/(cpu_ticks/ms_ticks) FROM sys.dm_os_sys_info WITH (NOLOCK)); 

SELECT TOP(256) SQLProcessUtilization AS [SQL Server Process CPU Utilization], 
               SystemIdle AS [System Idle Process], 
               100 - SystemIdle - SQLProcessUtilization AS [Other Process CPU Utilization], 
               DATEADD(ms, -1 * (@ts_now - [timestamp]), GETDATE()) AS [Event Time] 
FROM ( 
	  SELECT record.value('(./Record/@id)[1]', 'int') AS record_id, 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') 
			AS [SystemIdle], 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 
			'int') 
			AS [SQLProcessUtilization], [timestamp] 
	  FROM ( 
			SELECT [timestamp], CONVERT(xml, record) AS [record] 
			FROM sys.dm_os_ring_buffers WITH (NOLOCK)
			WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR' 
			AND record LIKE N'%<SystemHealth>%') AS x 
	  ) AS y 
ORDER BY record_id DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Sustained values above 10 suggest further investigation in that area
// High Avg Task Counts are often caused by blocking/deadlocking or other resource contention

// Sustained values above 1 suggest further investigation in that area
// High Avg Runnable Task Counts are a good sign of CPU pressure
// High Avg Pending DiskIO Counts are a sign of disk pressure

// How to Do Some Very Basic SQL Server Monitoring
// http://www.sqlskills.com/blogs/glenn/how-to-do-some-very-basic-sql-server-monitoring/



// Get CPU Utilization History for last 256 minutes (in one minute intervals)  (Query 28) (CPU Utilization History)
// This version works with SQL Server 2008-->
    <Query id="28" name="CPU Utilization History" description="Get CPU Utilization History for last 256 minutes (in one minute intervals)" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
DECLARE @ts_now bigint = (SELECT cpu_ticks/(cpu_ticks/ms_ticks) FROM sys.dm_os_sys_info WITH (NOLOCK)); 

SELECT TOP(256) SQLProcessUtilization AS [SQL Server Process CPU Utilization], 
               SystemIdle AS [System Idle Process], 
               100 - SystemIdle - SQLProcessUtilization AS [Other Process CPU Utilization], 
               DATEADD(ms, -1 * (@ts_now - [timestamp]), GETDATE()) AS [Event Time] 
FROM ( 
	  SELECT record.value('(./Record/@id)[1]', 'int') AS record_id, 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') 
			AS [SystemIdle], 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 
			'int') 
			AS [SQLProcessUtilization], [timestamp] 
	  FROM ( 
			SELECT [timestamp], CONVERT(xml, record) AS [record] 
			FROM sys.dm_os_ring_buffers WITH (NOLOCK)
			WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR' 
			AND record LIKE N'%<SystemHealth>%') AS x 
	  ) AS y 
ORDER BY record_id DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps troubleshoot blocking and deadlocking issues
// The results will change from second to second on a busy system
// You should run this query multiple times when you see signs of blocking



// Get CPU Utilization History for last 256 minutes (in one minute intervals)  (Query 35) (CPU Utilization History)
// This version works with SQL Server 2012-->
    <Query id="35" name="CPU Utilization History" description="Get CPU Utilization History for last 256 minutes (in one minute intervals)" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
DECLARE @ts_now bigint = (SELECT cpu_ticks/(cpu_ticks/ms_ticks) FROM sys.dm_os_sys_info WITH (NOLOCK)); 

SELECT TOP(256) SQLProcessUtilization AS [SQL Server Process CPU Utilization], 
               SystemIdle AS [System Idle Process], 
               100 - SystemIdle - SQLProcessUtilization AS [Other Process CPU Utilization], 
               DATEADD(ms, -1 * (@ts_now - [timestamp]), GETDATE()) AS [Event Time] 
FROM (SELECT record.value('(./Record/@id)[1]', 'int') AS record_id, 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') 
			AS [SystemIdle], 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int') 
			AS [SQLProcessUtilization], [timestamp] 
	  FROM (SELECT [timestamp], CONVERT(xml, record) AS [record] 
			FROM sys.dm_os_ring_buffers WITH (NOLOCK)
			WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR' 
			AND record LIKE N'%<SystemHealth>%') AS x) AS y 
ORDER BY record_id DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps troubleshoot blocking and deadlocking issues
// The results will change from second to second on a busy system
// You should run this query multiple times when you see signs of blocking



// Get CPU Utilization History for last 256 minutes (in one minute intervals)  (Query 40) (CPU Utilization History)
// This version works with SQL Server 2014-->
    <Query id="40" name="CPU Utilization History" description="Get CPU Utilization History for last 256 minutes (in one minute intervals)" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
DECLARE @ts_now bigint = (SELECT cpu_ticks/(cpu_ticks/ms_ticks) FROM sys.dm_os_sys_info WITH (NOLOCK)); 

SELECT TOP(256) SQLProcessUtilization AS [SQL Server Process CPU Utilization], 
               SystemIdle AS [System Idle Process], 
               100 - SystemIdle - SQLProcessUtilization AS [Other Process CPU Utilization], 
               DATEADD(ms, -1 * (@ts_now - [timestamp]), GETDATE()) AS [Event Time] 
FROM (SELECT record.value('(./Record/@id)[1]', 'int') AS record_id, 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') 
			AS [SystemIdle], 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int') 
			AS [SQLProcessUtilization], [timestamp] 
	  FROM (SELECT [timestamp], CONVERT(xml, record) AS [record] 
			FROM sys.dm_os_ring_buffers WITH (NOLOCK)
			WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR' 
			AND record LIKE N'%<SystemHealth>%') AS x) AS y 
ORDER BY record_id DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps troubleshoot blocking and deadlocking issues
// The results will change from second to second on a busy system
// You should run this query multiple times when you see signs of blocking



// Get CPU Utilization History for last 256 minutes (in one minute intervals)  (Query 40) (CPU Utilization History)
// This version works with SQL Server 2016-->
    <Query id="40" name="CPU Utilization History" description="Get CPU Utilization History for last 256 minutes (in one minute intervals)" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
DECLARE @ts_now bigint = (SELECT cpu_ticks/(cpu_ticks/ms_ticks) FROM sys.dm_os_sys_info WITH (NOLOCK)); 

SELECT TOP(256) SQLProcessUtilization AS [SQL Server Process CPU Utilization], 
               SystemIdle AS [System Idle Process], 
               100 - SystemIdle - SQLProcessUtilization AS [Other Process CPU Utilization], 
               DATEADD(ms, -1 * (@ts_now - [timestamp]), GETDATE()) AS [Event Time] 
FROM (SELECT record.value('(./Record/@id)[1]', 'int') AS record_id, 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') 
			AS [SystemIdle], 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int') 
			AS [SQLProcessUtilization], [timestamp] 
	  FROM (SELECT [timestamp], CONVERT(xml, record) AS [record] 
			FROM sys.dm_os_ring_buffers WITH (NOLOCK)
			WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR' 
			AND record LIKE N'%<SystemHealth>%') AS x) AS y 
ORDER BY record_id DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps troubleshoot blocking and deadlocking issues
// The results will change from second to second on a busy system
// You should run this query multiple times when you see signs of blocking



// Get CPU Utilization History for last 256 minutes (in one minute intervals)  (Query 40) (CPU Utilization History)
// This version works with SQL Server 2016-->
    <Query id="40" name="CPU Utilization History" description="Get CPU Utilization History for last 256 minutes (in one minute intervals)" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
DECLARE @ts_now bigint = (SELECT cpu_ticks/(cpu_ticks/ms_ticks) FROM sys.dm_os_sys_info WITH (NOLOCK)); 

SELECT TOP(256) SQLProcessUtilization AS [SQL Server Process CPU Utilization], 
               SystemIdle AS [System Idle Process], 
               100 - SystemIdle - SQLProcessUtilization AS [Other Process CPU Utilization], 
               DATEADD(ms, -1 * (@ts_now - [timestamp]), GETDATE()) AS [Event Time] 
FROM (SELECT record.value('(./Record/@id)[1]', 'int') AS record_id, 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', 'int') 
			AS [SystemIdle], 
			record.value('(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', 'int') 
			AS [SQLProcessUtilization], [timestamp] 
	  FROM (SELECT [timestamp], CONVERT(xml, record) AS [record] 
			FROM sys.dm_os_ring_buffers WITH (NOLOCK)
			WHERE ring_buffer_type = N'RING_BUFFER_SCHEDULER_MONITOR' 
			AND record LIKE N'%<SystemHealth>%') AS x) AS y 
ORDER BY record_id DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Focus on these settings:)
// backup compression default (should be 1 in most cases)
// clr enabled (only enable if it is needed)
// cost threshold for parallelism (depends on your workload)
// lightweight pooling (should be zero)
// max degree of parallelism (depends on your workload)
// max server memory (MB) (set to an appropriate value, not the default)
// priority boost (should be zero)
// remote admin connections (should be 1)


// File Names and Paths for TempDB and all user databases in instance (Query 11) (Database Filenames and Paths)-->
    <Query id="11" name="Database Filenames and Paths" description="File Names and Paths for TempDB and all user databases in instance" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT DB_NAME([database_id]) AS [Database Name], 
       [file_id], name, physical_name, type_desc, state_desc,
	   is_percent_growth, growth,
	   CONVERT(bigint, growth/128.0) AS [Growth in MB], 
       CONVERT(bigint, size/128.0) AS [Total Size in MB]
FROM sys.master_files WITH (NOLOCK)
WHERE [database_id] > 4 
AND [database_id] <> 32767
OR [database_id] = 2
ORDER BY DB_NAME([database_id]) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This will not return any rows if you have 
// not had any memory dumps (which is a good thing)


// File Names and Paths for TempDB and all user databases in instance  (Query 16) (Database Filenames and Paths)-->
    <Query id="16" name="Database Filenames and Paths" description="File Names and Paths for TempDB and all user databases in instance" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT DB_NAME([database_id]) AS [Database Name], 
       [file_id], name, physical_name, type_desc, state_desc,
	   is_percent_growth, growth,
	   CONVERT(bigint, growth/128.0) AS [Growth in MB], 
       CONVERT(bigint, size/128.0) AS [Total Size in MB]
FROM sys.master_files WITH (NOLOCK)
WHERE [database_id] > 4 
AND [database_id] <> 32767
OR [database_id] = 2
ORDER BY DB_NAME([database_id]) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Focus on these settings:
// backup compression default (should be 1 in most cases)
// clr enabled (only enable if it is needed)
// cost threshold for parallelism (depends on your workload)
// lightweight pooling (should be zero)
// max degree of parallelism (depends on your workload)
// max server memory (MB) (set to an appropriate value, not the default)
// optimize for ad hoc workloads (should be 1)
// priority boost (should be zero)
// remote admin connections (should be 1)





// File Names and Paths for TempDB and all user databases in instance  (Query 13) (Database Filenames and Paths)-->
    <Query id="13" name="Database Filenames and Paths" description="File Names and Paths for TempDB and all user databases in instance" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT DB_NAME([database_id]) AS [Database Name], 
       [file_id], name, physical_name, type_desc, state_desc,
	   is_percent_growth, growth,
	   CONVERT(bigint, growth/128.0) AS [Growth in MB], 
       CONVERT(bigint, size/128.0) AS [Total Size in MB]
FROM sys.master_files WITH (NOLOCK)
WHERE [database_id] > 4 
AND [database_id] <> 32767
OR [database_id] = 2
ORDER BY DB_NAME([database_id]) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This will not return any rows if you have 
// not had any memory dumps (which is a good thing)

// sys.dm_server_memory_dumps (Transact-SQL)
// http://bit.ly/2elwWll


// File names and paths for all user and system databases on instance  (Query 20) (Database Filenames and Paths)-->
    <Query id="20" name="Database Filenames and Paths" description="File names and paths for all user and system databases on instance" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT DB_NAME([database_id]) AS [Database Name], 
       [file_id], [name], physical_name, [type_desc], state_desc,
	   is_percent_growth, growth,
	   CONVERT(bigint, growth/128.0) AS [Growth in MB], 
       CONVERT(bigint, size/128.0) AS [Total Size in MB]
FROM sys.master_files WITH (NOLOCK)
ORDER BY DB_NAME([database_id]), [file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Get the number of data files in the tempdb database
// 4-8 data files that are all the same size is a good starting point
// This will be blank unless you have Service Pack 2 or later


// File names and paths for all user and system databases on instance  (Query 25) (Database Filenames and Paths)-->
    <Query id="25" name="Database Filenames and Paths" description="File names and paths for all user and system databases on instance" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT DB_NAME([database_id]) AS [Database Name], 
       [file_id], [name], physical_name, [type_desc], state_desc,
	   is_percent_growth, growth,
	   CONVERT(bigint, growth/128.0) AS [Growth in MB], 
       CONVERT(bigint, size/128.0) AS [Total Size in MB]
FROM sys.master_files WITH (NOLOCK)
ORDER BY DB_NAME([database_id]), [file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Get the number of data files in the tempdb database
// 4-8 data files that are all the same size is a good starting point


// File names and paths for all user and system databases on instance  (Query 25) (Database Filenames and Paths)-->
    <Query id="25" name="Database Filenames and Paths" description="File names and paths for all user and system databases on instance" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT DB_NAME([database_id]) AS [Database Name], 
       [file_id], [name], physical_name, [type_desc], state_desc,
	   is_percent_growth, growth,
	   CONVERT(bigint, growth/128.0) AS [Growth in MB], 
       CONVERT(bigint, size/128.0) AS [Total Size in MB]
FROM sys.master_files WITH (NOLOCK)
ORDER BY DB_NAME([database_id]), [file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Get the number of data files in the tempdb database
// 4-8 data files that are all the same size is a good starting point


// File names and paths for all user and system databases on instance  (Query 25) (Database Filenames and Paths)-->
    <Query id="25" name="Database Filenames and Paths" description="File names and paths for all user and system databases on instance" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT DB_NAME([database_id]) AS [Database Name], 
       [file_id], [name], physical_name, [type_desc], state_desc,
	   is_percent_growth, growth,
	   CONVERT(bigint, growth/128.0) AS [Growth in MB], 
       CONVERT(bigint, size/128.0) AS [Total Size in MB]
FROM sys.master_files WITH (NOLOCK)
ORDER BY DB_NAME([database_id]), [file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database files on the entire instance have the most I/O bottlenecks
// This can help you decide whether certain LUNs are overloaded and whether you might
// want to move some files to a different location or perhaps improve your I/O performance


// Recovery model, log reuse wait description, log file size, log usage size (Query 15) (Database Properties)
// and compatibility level for all databases on instance-->
    <Query id="15" name="Database Properties" description="Recovery model, log reuse wait description, log file size, log usage size" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT db.[name] AS [Database Name], db.recovery_model_desc AS [Recovery Model], 
db.log_reuse_wait_desc AS [Log Reuse Wait Description], 
ls.cntr_value AS [Log Size (KB)], lu.cntr_value AS [Log Used (KB)],
CAST(CAST(lu.cntr_value AS FLOAT) / CAST(ls.cntr_value AS FLOAT)AS DECIMAL(18,2)) * 100 AS [Log Used %], 
db.[compatibility_level] AS [DB Compatibility Level], 
db.page_verify_option_desc AS [Page Verify Option], db.is_auto_create_stats_on, db.is_auto_update_stats_on,
db.is_auto_update_stats_async_on, db.is_parameterization_forced, 
db.snapshot_isolation_state_desc, db.is_read_committed_snapshot_on,
db.is_auto_close_on, db.is_auto_shrink_on
FROM sys.databases AS db WITH (NOLOCK)
INNER JOIN sys.dm_os_performance_counters AS lu WITH (NOLOCK)
ON db.name = lu.instance_name
INNER JOIN sys.dm_os_performance_counters AS ls WITH (NOLOCK)
ON db.name = ls.instance_name
WHERE lu.counter_name LIKE N'Log File(s) Used Size (KB)%' 
AND ls.counter_name LIKE N'Log File(s) Size (KB)%'
AND ls.cntr_value > 0 OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database files on the entire instance have the most I/O bottlenecks
// This can help you decide whether certain LUNs are overloaded and whether you might
// want to move some files to a different location or perhaps improve your I/O performance


// Recovery model, log reuse wait description, log file size, log usage size  (Query 21) (Database Properties)
// and compatibility level for all databases on instance-->
    <Query id="21" name="Database Properties" description="Recovery model, log reuse wait description, log file size, log usage size" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT db.[name] AS [Database Name], db.recovery_model_desc AS [Recovery Model], 
db.log_reuse_wait_desc AS [Log Reuse Wait Description], 
ls.cntr_value AS [Log Size (KB)], lu.cntr_value AS [Log Used (KB)],
CAST(CAST(lu.cntr_value AS FLOAT) / CAST(ls.cntr_value AS FLOAT)AS DECIMAL(18,2)) * 100 AS [Log Used %], 
db.[compatibility_level] AS [DB Compatibility Level], 
db.page_verify_option_desc AS [Page Verify Option], db.is_auto_create_stats_on, db.is_auto_update_stats_on,
db.is_auto_update_stats_async_on, db.is_parameterization_forced, 
db.snapshot_isolation_state_desc, db.is_read_committed_snapshot_on,
db.is_auto_close_on, db.is_auto_shrink_on, db.is_cdc_enabled
FROM sys.databases AS db WITH (NOLOCK)
INNER JOIN sys.dm_os_performance_counters AS lu WITH (NOLOCK)
ON db.name = lu.instance_name
INNER JOIN sys.dm_os_performance_counters AS ls WITH (NOLOCK) 
ON db.name = ls.instance_name
WHERE lu.counter_name LIKE N'Log File(s) Used Size (KB)%' 
AND ls.counter_name LIKE N'Log File(s) Size (KB)%'
AND ls.cntr_value > 0
ORDER BY db.[name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database files on the entire instance have the most I/O bottlenecks
// This can help you decide whether certain LUNs are overloaded and whether you might
// want to move some files to a different location or perhaps improve your I/O performance


// Recovery model, log reuse wait description, log file size, log usage size  (Query 17) (Database Properties)
// and compatibility level for all databases on instance-->
    <Query id="17" name="Database Properties" description="Recovery model, log reuse wait description, log file size, log usage size" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT db.[name] AS [Database Name], db.recovery_model_desc AS [Recovery Model], 
db.log_reuse_wait_desc AS [Log Reuse Wait Description], 
ls.cntr_value AS [Log Size (KB)], lu.cntr_value AS [Log Used (KB)],
CAST(CAST(lu.cntr_value AS FLOAT) / CAST(ls.cntr_value AS FLOAT)AS DECIMAL(18,2)) * 100 AS [Log Used %], 
db.[compatibility_level] AS [DB Compatibility Level], 
db.page_verify_option_desc AS [Page Verify Option], db.is_auto_create_stats_on, db.is_auto_update_stats_on,
db.is_auto_update_stats_async_on, db.is_parameterization_forced, 
db.snapshot_isolation_state_desc, db.is_read_committed_snapshot_on,
db.is_auto_close_on, db.is_auto_shrink_on, db.is_cdc_enabled
FROM sys.databases AS db WITH (NOLOCK)
INNER JOIN sys.dm_os_performance_counters AS lu WITH (NOLOCK)
ON db.name = lu.instance_name
INNER JOIN sys.dm_os_performance_counters AS ls WITH (NOLOCK) 
ON db.name = ls.instance_name
WHERE lu.counter_name LIKE N'Log File(s) Used Size (KB)%' 
AND ls.counter_name LIKE N'Log File(s) Size (KB)%'
AND ls.cntr_value > 0 OPTION (RECOMPILE);
]]></Query>
    <!--//////  
   
// Finding 15 second I/O warnings in the SQL Server Error Log is useful evidence of
// poor I/O performance (which might have many different causes)
// Look to see if you see any patterns in the results (same files, same drives, same time of day, etc.)

// Diagnostics in SQL Server help detect stalled and stuck I/O operations
// https://support.microsoft.com/en-us/kb/897284



// Recovery model, log reuse wait description, log file size, log usage size  (Query 25) (Database Properties)
// and compatibility level for all databases on instance-->
    <Query id="25" name="Database Properties" description="Recovery model, log reuse wait description, log file size, log usage size" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT db.[name] AS [Database Name], db.recovery_model_desc AS [Recovery Model], db.state_desc, db.containment_desc,
db.log_reuse_wait_desc AS [Log Reuse Wait Description], 
CONVERT(DECIMAL(18,2), ls.cntr_value/1024.0) AS [Log Size (MB)], CONVERT(DECIMAL(18,2), lu.cntr_value/1024.0) AS [Log Used (MB)],
CAST(CAST(lu.cntr_value AS FLOAT) / CAST(ls.cntr_value AS FLOAT)AS DECIMAL(18,2)) * 100 AS [Log Used %], 
db.[compatibility_level] AS [DB Compatibility Level], 
db.page_verify_option_desc AS [Page Verify Option], db.is_auto_create_stats_on, db.is_auto_update_stats_on,
db.is_auto_update_stats_async_on, db.is_parameterization_forced, 
db.snapshot_isolation_state_desc, db.is_read_committed_snapshot_on,
db.is_auto_close_on, db.is_auto_shrink_on, db.target_recovery_time_in_seconds, db.is_cdc_enabled,
db.is_published, db.group_database_id, db.replica_id,
db.is_encrypted, de.encryption_state, de.percent_complete, de.key_algorithm, de.key_length
FROM sys.databases AS db WITH (NOLOCK)
INNER JOIN sys.dm_os_performance_counters AS lu WITH (NOLOCK)
ON db.name = lu.instance_name
INNER JOIN sys.dm_os_performance_counters AS ls WITH (NOLOCK)
ON db.name = ls.instance_name
LEFT OUTER JOIN sys.dm_database_encryption_keys AS de WITH (NOLOCK)
ON db.database_id = de.database_id
WHERE lu.counter_name LIKE N'Log File(s) Used Size (KB)%' 
AND ls.counter_name LIKE N'Log File(s) Size (KB)%'
AND ls.cntr_value > 0 
ORDER BY db.[name] OPTION (RECOMPILE);
]]></Query>
    <!--//////  
   
// Finding 15 second I/O warnings in the SQL Server Error Log is useful evidence of
// poor I/O performance (which might have many different causes)
// Look to see if you see any patterns in the results (same files, same drives, same time of day, etc.)

// Diagnostics in SQL Server help detect stalled and stuck I/O operations
// https://support.microsoft.com/en-us/kb/897284



// Recovery model, log reuse wait description, log file size, log usage size  (Query 30) (Database Properties)
// and compatibility level for all databases on instance-->
    <Query id="30" name="Database Properties" description="Recovery model, log reuse wait description, log file size, log usage size" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT db.[name] AS [Database Name], db.recovery_model_desc AS [Recovery Model], db.state_desc, db.containment_desc,
db.log_reuse_wait_desc AS [Log Reuse Wait Description], 
CONVERT(DECIMAL(18,2), ls.cntr_value/1024.0) AS [Log Size (MB)], CONVERT(DECIMAL(18,2), lu.cntr_value/1024.0) AS [Log Used (MB)],
CAST(CAST(lu.cntr_value AS FLOAT) / CAST(ls.cntr_value AS FLOAT)AS DECIMAL(18,2)) * 100 AS [Log Used %], 
db.[compatibility_level] AS [DB Compatibility Level], db.page_verify_option_desc AS [Page Verify Option], 
db.is_auto_create_stats_on, db.is_auto_update_stats_on, db.is_auto_update_stats_async_on, db.is_parameterization_forced, 
db.snapshot_isolation_state_desc, db.is_read_committed_snapshot_on, db.is_auto_close_on, db.is_auto_shrink_on, 
db.target_recovery_time_in_seconds, db.is_cdc_enabled, db.is_published, db.is_distributor, /* db.is_encrypted, */
db.group_database_id, db.replica_id,db.is_memory_optimized_elevate_to_snapshot_on, 
db.delayed_durability_desc, db.is_auto_create_stats_incremental_on,
db.is_encrypted, de.encryption_state, de.percent_complete, de.key_algorithm, de.key_length      
FROM sys.databases AS db WITH (NOLOCK)
INNER JOIN sys.dm_os_performance_counters AS lu WITH (NOLOCK)
ON db.name = lu.instance_name
INNER JOIN sys.dm_os_performance_counters AS ls WITH (NOLOCK)
ON db.name = ls.instance_name
LEFT OUTER JOIN sys.dm_database_encryption_keys AS de WITH (NOLOCK)
ON db.database_id = de.database_id
WHERE lu.counter_name LIKE N'Log File(s) Used Size (KB)%' 
AND ls.counter_name LIKE N'Log File(s) Size (KB)%'
AND ls.cntr_value > 0 
ORDER BY db.[name] OPTION (RECOMPILE);
]]></Query>
    <!--//////  
   
// Finding 15 second I/O warnings in the SQL Server Error Log is useful evidence of
// poor I/O performance (which might have many different causes)
// Look to see if you see any patterns in the results (same files, same drives, same time of day, etc.)

// Diagnostics in SQL Server help detect stalled and stuck I/O operations
// https://support.microsoft.com/en-us/kb/897284



// Recovery model, log reuse wait description, log file size, log usage size  (Query 30) (Database Properties)
// and compatibility level for all databases on instance-->
    <Query id="30" name="Database Properties" description="Recovery model, log reuse wait description, log file size, log usage size" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT db.[name] AS [Database Name], db.recovery_model_desc AS [Recovery Model], db.state_desc, db.containment_desc,
db.log_reuse_wait_desc AS [Log Reuse Wait Description], 
CONVERT(DECIMAL(18,2), ls.cntr_value/1024.0) AS [Log Size (MB)], CONVERT(DECIMAL(18,2), lu.cntr_value/1024.0) AS [Log Used (MB)],
CAST(CAST(lu.cntr_value AS FLOAT) / CAST(ls.cntr_value AS FLOAT)AS DECIMAL(18,2)) * 100 AS [Log Used %], 
db.[compatibility_level] AS [DB Compatibility Level], 
db.is_mixed_page_allocation_on, db.page_verify_option_desc AS [Page Verify Option], 
db.is_auto_create_stats_on, db.is_auto_update_stats_on, db.is_auto_update_stats_async_on, db.is_parameterization_forced, 
db.snapshot_isolation_state_desc, db.is_read_committed_snapshot_on, db.is_auto_close_on, db.is_auto_shrink_on, 
db.target_recovery_time_in_seconds, db.is_cdc_enabled, db.is_published, db.is_distributor, db.is_encrypted,
db.group_database_id, db.replica_id,db.is_memory_optimized_elevate_to_snapshot_on, 
db.delayed_durability_desc, db.is_auto_create_stats_incremental_on,
db.is_query_store_on, db.is_sync_with_backup, 
db.is_supplemental_logging_enabled, db.is_remote_data_archive_enabled,
db.is_encrypted, de.encryption_state, de.percent_complete, de.key_algorithm, de.key_length      
FROM sys.databases AS db WITH (NOLOCK)
INNER JOIN sys.dm_os_performance_counters AS lu WITH (NOLOCK)
ON db.name = lu.instance_name
INNER JOIN sys.dm_os_performance_counters AS ls WITH (NOLOCK)
ON db.name = ls.instance_name
LEFT OUTER JOIN sys.dm_database_encryption_keys AS de WITH (NOLOCK)
ON db.database_id = de.database_id
WHERE lu.counter_name LIKE N'Log File(s) Used Size (KB)%' 
AND ls.counter_name LIKE N'Log File(s) Size (KB)%'
AND ls.cntr_value > 0 
ORDER BY db.[name] OPTION (RECOMPILE);
]]></Query>
    <!--//////  
   
// Finding 15 second I/O warnings in the SQL Server Error Log is useful evidence of
// poor I/O performance (which might have many different causes)
// Look to see if you see any patterns in the results (same files, same drives, same time of day, etc.)

// Diagnostics in SQL Server help detect stalled and stuck I/O operations
// https://support.microsoft.com/en-us/kb/897284



// Recovery model, log reuse wait description, log file size, log usage size  (Query 30) (Database Properties)
// and compatibility level for all databases on instance-->
    <Query id="30" name="Database Properties" description="Recovery model, log reuse wait description, log file size, log usage size" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT db.[name] AS [Database Name], db.recovery_model_desc AS [Recovery Model], db.state_desc, db.containment_desc,
db.log_reuse_wait_desc AS [Log Reuse Wait Description], 
CONVERT(DECIMAL(18,2), ls.cntr_value/1024.0) AS [Log Size (MB)], CONVERT(DECIMAL(18,2), lu.cntr_value/1024.0) AS [Log Used (MB)],
CAST(CAST(lu.cntr_value AS FLOAT) / CAST(ls.cntr_value AS FLOAT)AS DECIMAL(18,2)) * 100 AS [Log Used %], 
db.[compatibility_level] AS [DB Compatibility Level], 
db.is_mixed_page_allocation_on, db.page_verify_option_desc AS [Page Verify Option], 
db.is_auto_create_stats_on, db.is_auto_update_stats_on, db.is_auto_update_stats_async_on, db.is_parameterization_forced, 
db.snapshot_isolation_state_desc, db.is_read_committed_snapshot_on, db.is_auto_close_on, db.is_auto_shrink_on, 
db.target_recovery_time_in_seconds, db.is_cdc_enabled, db.is_published, db.is_distributor, db.is_encrypted,
db.group_database_id, db.replica_id,db.is_memory_optimized_elevate_to_snapshot_on, 
db.delayed_durability_desc, db.is_auto_create_stats_incremental_on,
db.is_query_store_on, db.is_sync_with_backup, 
db.is_supplemental_logging_enabled, db.is_remote_data_archive_enabled,
db.is_encrypted, de.encryption_state, de.percent_complete, de.key_algorithm, de.key_length      
FROM sys.databases AS db WITH (NOLOCK)
INNER JOIN sys.dm_os_performance_counters AS lu WITH (NOLOCK)
ON db.name = lu.instance_name
INNER JOIN sys.dm_os_performance_counters AS ls WITH (NOLOCK)
ON db.name = ls.instance_name
LEFT OUTER JOIN sys.dm_database_encryption_keys AS de WITH (NOLOCK)
ON db.database_id = de.database_id
WHERE lu.counter_name LIKE N'Log File(s) Used Size (KB)%' 
AND ls.counter_name LIKE N'Log File(s) Size (KB)%'
AND ls.cntr_value > 0 
ORDER BY db.[name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at log file size and usage, along with the log reuse wait description for the current database



// Get database scoped configuration values for current database (Query 51) (Database-scoped Configurations)-->
    <Query id="51" name="Database-scoped Configurations" description="Get database scoped configuration values for current database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT configuration_id, name, [value] AS [value_for_primary], value_for_secondary
FROM sys.database_scoped_configurations WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at log file size and usage, along with the log reuse wait description for the current database



// Get database scoped configuration values for current database (Query 51) (Database-scoped Configurations)-->
    <Query id="51" name="Database-scoped Configurations" description="Get database scoped configuration values for current database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT configuration_id, name, [value] AS [value_for_primary], value_for_secondary
FROM sys.database_scoped_configurations WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you an idea of table sizes


// Detect blocking (run multiple times)  (Query 45) (Detect Blocking)-->
    <Query id="45" name="Detect Blocking" description="Detect blocking (run multiple times)" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT t1.resource_type AS [lock type], DB_NAME(resource_database_id) AS [database],
t1.resource_associated_entity_id AS [blk object],t1.request_mode AS [lock req],  --- lock requested
t1.request_session_id AS [waiter sid], t2.wait_duration_ms AS [wait time],       -- spid of waiter  
(SELECT [text] FROM sys.dm_exec_requests AS r WITH (NOLOCK)                      -- get sql for waiter
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) 
WHERE r.session_id = t1.request_session_id) AS [waiter_batch],
(SELECT SUBSTRING(qt.[text],r.statement_start_offset/2, 
    (CASE WHEN r.statement_end_offset = -1 
    THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
    ELSE r.statement_end_offset END - r.statement_start_offset)/2) 
FROM sys.dm_exec_requests AS r WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) AS qt
WHERE r.session_id = t1.request_session_id) AS [waiter_stmt],					-- statement blocked
t2.blocking_session_id AS [blocker sid],										-- spid of blocker
(SELECT [text] FROM sys.sysprocesses AS p										-- get sql for blocker
CROSS APPLY sys.dm_exec_sql_text(p.[sql_handle]) 
WHERE p.spid = t2.blocking_session_id) AS [blocker_stmt]
FROM sys.dm_tran_locks AS t1 WITH (NOLOCK)
INNER JOIN sys.dm_os_waiting_tasks AS t2 WITH (NOLOCK)
ON t1.lock_owner_address = t2.resource_address OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some good information about your tables


// Detect blocking (run multiple times)  (Query 57) (Detect Blocking)-->
    <Query id="57" name="Detect Blocking" description="Detect blocking (run multiple times)" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT t1.resource_type AS [lock type], DB_NAME(resource_database_id) AS [database],
t1.resource_associated_entity_id AS [blk object],t1.request_mode AS [lock req],  --- lock requested
t1.request_session_id AS [waiter sid], t2.wait_duration_ms AS [wait time],       -- spid of waiter  
(SELECT [text] FROM sys.dm_exec_requests AS r WITH (NOLOCK)                      -- get sql for waiter
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) 
WHERE r.session_id = t1.request_session_id) AS [waiter_batch],
(SELECT SUBSTRING(qt.[text],r.statement_start_offset/2, 
    (CASE WHEN r.statement_end_offset = -1 
    THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
    ELSE r.statement_end_offset END - r.statement_start_offset)/2) 
FROM sys.dm_exec_requests AS r WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) AS qt
WHERE r.session_id = t1.request_session_id) AS [waiter_stmt],					-- statement blocked
t2.blocking_session_id AS [blocker sid],										-- spid of blocker
(SELECT [text] FROM sys.sysprocesses AS p										-- get sql for blocker
CROSS APPLY sys.dm_exec_sql_text(p.[sql_handle]) 
WHERE p.spid = t2.blocking_session_id) AS [blocker_stmt]
FROM sys.dm_tran_locks AS t1 WITH (NOLOCK)
INNER JOIN sys.dm_os_waiting_tasks AS t2 WITH (NOLOCK)
ON t1.lock_owner_address = t2.resource_address OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some good information about your tables


// Detect blocking (run multiple times)  (Query 53) (Detect Blocking)-->
    <Query id="53" name="Detect Blocking" description="Detect blocking (run multiple times)" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT t1.resource_type AS [lock type], DB_NAME(resource_database_id) AS [database],
t1.resource_associated_entity_id AS [blk object],t1.request_mode AS [lock req],  --- lock requested
t1.request_session_id AS [waiter sid], t2.wait_duration_ms AS [wait time],       -- spid of waiter  
(SELECT [text] FROM sys.dm_exec_requests AS r WITH (NOLOCK)                      -- get sql for waiter
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) 
WHERE r.session_id = t1.request_session_id) AS [waiter_batch],
(SELECT SUBSTRING(qt.[text],r.statement_start_offset/2, 
    (CASE WHEN r.statement_end_offset = -1 
    THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
    ELSE r.statement_end_offset END - r.statement_start_offset)/2) 
FROM sys.dm_exec_requests AS r WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) AS qt
WHERE r.session_id = t1.request_session_id) AS [waiter_stmt],					-- statement blocked
t2.blocking_session_id AS [blocker sid],										-- spid of blocker
(SELECT [text] FROM sys.sysprocesses AS p										-- get sql for blocker
CROSS APPLY sys.dm_exec_sql_text(p.[sql_handle]) 
WHERE p.spid = t2.blocking_session_id) AS [blocker_stmt]
FROM sys.dm_tran_locks AS t1 WITH (NOLOCK)
INNER JOIN sys.dm_os_waiting_tasks AS t2 WITH (NOLOCK)
ON t1.lock_owner_address = t2.resource_address OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Sustained values above 10 suggest further investigation in that area
// High Avg Task Counts are often caused by blocking/deadlocking or other resource contention

// Sustained values above 1 suggest further investigation in that area
// High Avg Runnable Task Counts are a good sign of CPU pressure
// High Avg Pending DiskIO Counts are a sign of disk pressure

// How to Do Some Very Basic SQL Server Monitoring
// http://www.sqlskills.com/blogs/glenn/how-to-do-some-very-basic-sql-server-monitoring/



// Detect blocking (run multiple times)  (Query 34) (Detect Blocking)-->
    <Query id="34" name="Detect Blocking" description="Detect blocking (run multiple times)" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT t1.resource_type AS [lock type], DB_NAME(resource_database_id) AS [database],
t1.resource_associated_entity_id AS [blk object],t1.request_mode AS [lock req],  -- lock requested
t1.request_session_id AS [waiter sid], t2.wait_duration_ms AS [wait time],       -- spid of waiter  
(SELECT [text] FROM sys.dm_exec_requests AS r WITH (NOLOCK)                      -- get sql for waiter
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) 
WHERE r.session_id = t1.request_session_id) AS [waiter_batch],
(SELECT SUBSTRING(qt.[text],r.statement_start_offset/2, 
    (CASE WHEN r.statement_end_offset = -1 
    THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
    ELSE r.statement_end_offset END - r.statement_start_offset)/2) 
FROM sys.dm_exec_requests AS r WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) AS qt
WHERE r.session_id = t1.request_session_id) AS [waiter_stmt],					-- statement blocked
t2.blocking_session_id AS [blocker sid],										-- spid of blocker
(SELECT [text] FROM sys.sysprocesses AS p										-- get sql for blocker
CROSS APPLY sys.dm_exec_sql_text(p.[sql_handle]) 
WHERE p.spid = t2.blocking_session_id) AS [blocker_batch]
FROM sys.dm_tran_locks AS t1 WITH (NOLOCK)
INNER JOIN sys.dm_os_waiting_tasks AS t2 WITH (NOLOCK)
ON t1.lock_owner_address = t2.resource_address OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Sustained values above 10 suggest further investigation in that area
// High Avg Task Counts are often caused by blocking/deadlocking or other resource contention

// Sustained values above 1 suggest further investigation in that area
// High Avg Runnable Task Counts are a good sign of CPU pressure
// High Avg Pending DiskIO Counts are a sign of disk pressure

// How to Do Some Very Basic SQL Server Monitoring
// http://www.sqlskills.com/blogs/glenn/how-to-do-some-very-basic-sql-server-monitoring/



// Detect blocking (run multiple times)  (Query 39) (Detect Blocking)-->
    <Query id="39" name="Detect Blocking" description="Detect blocking (run multiple times)" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT t1.resource_type AS [lock type], DB_NAME(resource_database_id) AS [database],
t1.resource_associated_entity_id AS [blk object],t1.request_mode AS [lock req],  -- lock requested
t1.request_session_id AS [waiter sid], t2.wait_duration_ms AS [wait time],       -- spid of waiter  
(SELECT [text] FROM sys.dm_exec_requests AS r WITH (NOLOCK)                      -- get sql for waiter
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) 
WHERE r.session_id = t1.request_session_id) AS [waiter_batch],
(SELECT SUBSTRING(qt.[text],r.statement_start_offset/2, 
    (CASE WHEN r.statement_end_offset = -1 
    THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
    ELSE r.statement_end_offset END - r.statement_start_offset)/2) 
FROM sys.dm_exec_requests AS r WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) AS qt
WHERE r.session_id = t1.request_session_id) AS [waiter_stmt],					-- statement blocked
t2.blocking_session_id AS [blocker sid],										-- spid of blocker
(SELECT [text] FROM sys.sysprocesses AS p										-- get sql for blocker
CROSS APPLY sys.dm_exec_sql_text(p.[sql_handle]) 
WHERE p.spid = t2.blocking_session_id) AS [blocker_batch]
FROM sys.dm_tran_locks AS t1 WITH (NOLOCK)
INNER JOIN sys.dm_os_waiting_tasks AS t2 WITH (NOLOCK)
ON t1.lock_owner_address = t2.resource_address OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Sustained values above 10 suggest further investigation in that area
// High Avg Task Counts are often caused by blocking/deadlocking or other resource contention

// Sustained values above 1 suggest further investigation in that area
// High Avg Runnable Task Counts are a good sign of CPU pressure
// High Avg Pending DiskIO Counts are a sign of disk pressure

// How to Do Some Very Basic SQL Server Monitoring
// http://www.sqlskills.com/blogs/glenn/how-to-do-some-very-basic-sql-server-monitoring/



// Detect blocking (run multiple times)  (Query 39) (Detect Blocking)-->
    <Query id="39" name="Detect Blocking" description="Detect blocking (run multiple times)" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT t1.resource_type AS [lock type], DB_NAME(resource_database_id) AS [database],
t1.resource_associated_entity_id AS [blk object],t1.request_mode AS [lock req],  -- lock requested
t1.request_session_id AS [waiter sid], t2.wait_duration_ms AS [wait time],       -- spid of waiter  
(SELECT [text] FROM sys.dm_exec_requests AS r WITH (NOLOCK)                      -- get sql for waiter
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) 
WHERE r.session_id = t1.request_session_id) AS [waiter_batch],
(SELECT SUBSTRING(qt.[text],r.statement_start_offset/2, 
    (CASE WHEN r.statement_end_offset = -1 
    THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
    ELSE r.statement_end_offset END - r.statement_start_offset)/2) 
FROM sys.dm_exec_requests AS r WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) AS qt
WHERE r.session_id = t1.request_session_id) AS [waiter_stmt],					-- statement blocked
t2.blocking_session_id AS [blocker sid],										-- spid of blocker
(SELECT [text] FROM sys.sysprocesses AS p										-- get sql for blocker
CROSS APPLY sys.dm_exec_sql_text(p.[sql_handle]) 
WHERE p.spid = t2.blocking_session_id) AS [blocker_batch]
FROM sys.dm_tran_locks AS t1 WITH (NOLOCK)
INNER JOIN sys.dm_os_waiting_tasks AS t2 WITH (NOLOCK)
ON t1.lock_owner_address = t2.resource_address OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Sustained values above 10 suggest further investigation in that area
// High Avg Task Counts are often caused by blocking/deadlocking or other resource contention

// Sustained values above 1 suggest further investigation in that area
// High Avg Runnable Task Counts are a good sign of CPU pressure
// High Avg Pending DiskIO Counts are a sign of disk pressure

// How to Do Some Very Basic SQL Server Monitoring
// http://www.sqlskills.com/blogs/glenn/how-to-do-some-very-basic-sql-server-monitoring/



// Detect blocking (run multiple times)  (Query 39) (Detect Blocking)-->
    <Query id="39" name="Detect Blocking" description="Detect blocking (run multiple times)" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT t1.resource_type AS [lock type], DB_NAME(resource_database_id) AS [database],
t1.resource_associated_entity_id AS [blk object],t1.request_mode AS [lock req],  -- lock requested
t1.request_session_id AS [waiter sid], t2.wait_duration_ms AS [wait time],       -- spid of waiter  
(SELECT [text] FROM sys.dm_exec_requests AS r WITH (NOLOCK)                      -- get sql for waiter
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) 
WHERE r.session_id = t1.request_session_id) AS [waiter_batch],
(SELECT SUBSTRING(qt.[text],r.statement_start_offset/2, 
    (CASE WHEN r.statement_end_offset = -1 
    THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
    ELSE r.statement_end_offset END - r.statement_start_offset)/2) 
FROM sys.dm_exec_requests AS r WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(r.[sql_handle]) AS qt
WHERE r.session_id = t1.request_session_id) AS [waiter_stmt],					-- statement blocked
t2.blocking_session_id AS [blocker sid],										-- spid of blocker
(SELECT [text] FROM sys.sysprocesses AS p										-- get sql for blocker
CROSS APPLY sys.dm_exec_sql_text(p.[sql_handle]) 
WHERE p.spid = t2.blocking_session_id) AS [blocker_batch]
FROM sys.dm_tran_locks AS t1 WITH (NOLOCK)
INNER JOIN sys.dm_os_waiting_tasks AS t2 WITH (NOLOCK)
ON t1.lock_owner_address = t2.resource_address OPTION (RECOMPILE);
]]></Query>
    <!--////// 
   
// Finding 15 second I/O warnings in the SQL Server Error Log is useful evidence of
// poor I/O performance (which might have many different causes)
// Look to see if you see any patterns in the results (same files, same drives, same time of day, etc.)

// Diagnostics in SQL Server help detect stalled and stuck I/O operations
// https://support.microsoft.com/en-us/kb/897284


// Drive level latency information (Query 13) (Drive Level Latency)
// Based on code from Jimmy May-->
    <Query id="13" name="Drive Level Latency" description="Drive level latency information" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT tab.[Drive], tab.volume_mount_point AS [Volume Mount Point], 
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (io_stall_read_ms/num_of_reads) 
	END AS [Read Latency],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (io_stall_write_ms/num_of_writes) 
	END AS [Write Latency],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE (io_stall/(num_of_reads + num_of_writes)) 
	END AS [Overall Latency],
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (num_of_bytes_read/num_of_reads) 
	END AS [Avg Bytes/Read],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (num_of_bytes_written/num_of_writes) 
	END AS [Avg Bytes/Write],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE ((num_of_bytes_read + num_of_bytes_written)/(num_of_reads + num_of_writes)) 
	END AS [Avg Bytes/Transfer]
FROM (SELECT LEFT(UPPER(mf.physical_name), 2) AS Drive, SUM(num_of_reads) AS num_of_reads,
	         SUM(io_stall_read_ms) AS io_stall_read_ms, SUM(num_of_writes) AS num_of_writes,
	         SUM(io_stall_write_ms) AS io_stall_write_ms, SUM(num_of_bytes_read) AS num_of_bytes_read,
	         SUM(num_of_bytes_written) AS num_of_bytes_written, SUM(io_stall) AS io_stall, vs.volume_mount_point 
      FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS vfs
      INNER JOIN sys.master_files AS mf WITH (NOLOCK)
      ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id
	  CROSS APPLY sys.dm_os_volume_stats(mf.database_id, mf.[file_id]) AS vs 
      GROUP BY LEFT(UPPER(mf.physical_name), 2), vs.volume_mount_point) AS tab
ORDER BY [Overall Latency] OPTION (RECOMPILE);
]]></Query>
    <!--//////  
   
// Finding 15 second I/O warnings in the SQL Server Error Log is useful evidence of
// poor I/O performance (which might have many different causes)
// Look to see if you see any patterns in the results (same files, same drives, same time of day, etc.)

// Diagnostics in SQL Server help detect stalled and stuck I/O operations
// https://support.microsoft.com/en-us/kb/897284



// Drive level latency information (Query 19) (Drive Level Latency)
// Based on code from Jimmy May-->
    <Query id="19" name="Drive Level Latency" description="Drive level latency information" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT tab.[Drive], tab.volume_mount_point AS [Volume Mount Point], 
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (io_stall_read_ms/num_of_reads) 
	END AS [Read Latency],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (io_stall_write_ms/num_of_writes) 
	END AS [Write Latency],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE (io_stall/(num_of_reads + num_of_writes)) 
	END AS [Overall Latency],
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (num_of_bytes_read/num_of_reads) 
	END AS [Avg Bytes/Read],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (num_of_bytes_written/num_of_writes) 
	END AS [Avg Bytes/Write],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE ((num_of_bytes_read + num_of_bytes_written)/(num_of_reads + num_of_writes)) 
	END AS [Avg Bytes/Transfer]
FROM (SELECT LEFT(UPPER(mf.physical_name), 2) AS Drive, SUM(num_of_reads) AS num_of_reads,
	         SUM(io_stall_read_ms) AS io_stall_read_ms, SUM(num_of_writes) AS num_of_writes,
	         SUM(io_stall_write_ms) AS io_stall_write_ms, SUM(num_of_bytes_read) AS num_of_bytes_read,
	         SUM(num_of_bytes_written) AS num_of_bytes_written, SUM(io_stall) AS io_stall, vs.volume_mount_point 
      FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS vfs
      INNER JOIN sys.master_files AS mf WITH (NOLOCK)
      ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id
	  CROSS APPLY sys.dm_os_volume_stats(mf.database_id, mf.[file_id]) AS vs 
      GROUP BY LEFT(UPPER(mf.physical_name), 2), vs.volume_mount_point) AS tab
ORDER BY [Overall Latency] OPTION (RECOMPILE);
]]></Query>
    <!--//////  
   
// Finding 15 second I/O warnings in the SQL Server Error Log is useful evidence of
// poor I/O performance (which might have many different causes)
// Look to see if you see any patterns in the results (same files, same drives, same time of day, etc.)

// Diagnostics in SQL Server help detect stalled and stuck I/O operations
// https://support.microsoft.com/en-us/kb/897284


// Drive level latency information (Query 15) (Drive Level Latency)
// Based on code from Jimmy May-->
    <Query id="15" name="Drive Level Latency" description="Drive level latency information" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT tab.[Drive],
	/* , tab.volume_mount_point AS [Volume Mount Point] */ 
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (io_stall_read_ms/num_of_reads) 
	END AS [Read Latency],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (io_stall_write_ms/num_of_writes) 
	END AS [Write Latency],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE (io_stall/(num_of_reads + num_of_writes)) 
	END AS [Overall Latency],
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (num_of_bytes_read/num_of_reads) 
	END AS [Avg Bytes/Read],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (num_of_bytes_written/num_of_writes) 
	END AS [Avg Bytes/Write],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE ((num_of_bytes_read + num_of_bytes_written)/(num_of_reads + num_of_writes)) 
	END AS [Avg Bytes/Transfer]
FROM (SELECT LEFT(UPPER(mf.physical_name), 2) AS Drive, SUM(num_of_reads) AS num_of_reads,
	         SUM(io_stall_read_ms) AS io_stall_read_ms, SUM(num_of_writes) AS num_of_writes,
	         SUM(io_stall_write_ms) AS io_stall_write_ms, SUM(num_of_bytes_read) AS num_of_bytes_read,
	         SUM(num_of_bytes_written) AS num_of_bytes_written, SUM(io_stall) AS io_stall /*, vs.volume_mount_point*/
      FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS vfs
      INNER JOIN sys.master_files AS mf WITH (NOLOCK)
      ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id
	  /* CROSS APPLY sys.dm_os_volume_stats(mf.database_id, mf.[file_id]) AS vs */
      GROUP BY LEFT(UPPER(mf.physical_name), 2) /*, vs.volume_mount_point */) AS tab
ORDER BY [Overall Latency] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Shows you the total and free space on the LUNs where you have database files
// Being low on free space can negatively affect performance



// Drive level latency information (Query 22) (Drive Level Latency)
// Based on code from Jimmy May-->
    <Query id="22" name="Drive Level Latency" description="Drive level latency information" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT tab.[Drive], tab.volume_mount_point AS [Volume Mount Point], 
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (io_stall_read_ms/num_of_reads) 
	END AS [Read Latency],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (io_stall_write_ms/num_of_writes) 
	END AS [Write Latency],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE (io_stall/(num_of_reads + num_of_writes)) 
	END AS [Overall Latency],
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (num_of_bytes_read/num_of_reads) 
	END AS [Avg Bytes/Read],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (num_of_bytes_written/num_of_writes) 
	END AS [Avg Bytes/Write],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE ((num_of_bytes_read + num_of_bytes_written)/(num_of_reads + num_of_writes)) 
	END AS [Avg Bytes/Transfer]
FROM (SELECT LEFT(UPPER(mf.physical_name), 2) AS Drive, SUM(num_of_reads) AS num_of_reads,
	         SUM(io_stall_read_ms) AS io_stall_read_ms, SUM(num_of_writes) AS num_of_writes,
	         SUM(io_stall_write_ms) AS io_stall_write_ms, SUM(num_of_bytes_read) AS num_of_bytes_read,
	         SUM(num_of_bytes_written) AS num_of_bytes_written, SUM(io_stall) AS io_stall, vs.volume_mount_point 
      FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS vfs
      INNER JOIN sys.master_files AS mf WITH (NOLOCK)
      ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id
	  CROSS APPLY sys.dm_os_volume_stats(mf.database_id, mf.[file_id]) AS vs 
      GROUP BY LEFT(UPPER(mf.physical_name), 2), vs.volume_mount_point) AS tab
ORDER BY [Overall Latency] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Shows you the total and free space on the LUNs where you have database files
// Being low on free space can negatively affect performance



// Drive level latency information (Query 27) (Drive Level Latency)
// Based on code from Jimmy May-->
    <Query id="27" name="Drive Level Latency" description="Drive level latency information" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT tab.[Drive], tab.volume_mount_point AS [Volume Mount Point], 
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (io_stall_read_ms/num_of_reads) 
	END AS [Read Latency],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (io_stall_write_ms/num_of_writes) 
	END AS [Write Latency],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE (io_stall/(num_of_reads + num_of_writes)) 
	END AS [Overall Latency],
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (num_of_bytes_read/num_of_reads) 
	END AS [Avg Bytes/Read],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (num_of_bytes_written/num_of_writes) 
	END AS [Avg Bytes/Write],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE ((num_of_bytes_read + num_of_bytes_written)/(num_of_reads + num_of_writes)) 
	END AS [Avg Bytes/Transfer]
FROM (SELECT LEFT(UPPER(mf.physical_name), 2) AS Drive, SUM(num_of_reads) AS num_of_reads,
	         SUM(io_stall_read_ms) AS io_stall_read_ms, SUM(num_of_writes) AS num_of_writes,
	         SUM(io_stall_write_ms) AS io_stall_write_ms, SUM(num_of_bytes_read) AS num_of_bytes_read,
	         SUM(num_of_bytes_written) AS num_of_bytes_written, SUM(io_stall) AS io_stall, vs.volume_mount_point 
      FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS vfs
      INNER JOIN sys.master_files AS mf WITH (NOLOCK)
      ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id
	  CROSS APPLY sys.dm_os_volume_stats(mf.database_id, mf.[file_id]) AS vs 
      GROUP BY LEFT(UPPER(mf.physical_name), 2), vs.volume_mount_point) AS tab
ORDER BY [Overall Latency] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Shows you the total and free space on the LUNs where you have database files
// Being low on free space can negatively affect performance



// Drive level latency information (Query 27) (Drive Level Latency)
// Based on code from Jimmy May-->
    <Query id="27" name="Drive Level Latency" description="Drive level latency information" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT tab.[Drive], tab.volume_mount_point AS [Volume Mount Point], 
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (io_stall_read_ms/num_of_reads) 
	END AS [Read Latency],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (io_stall_write_ms/num_of_writes) 
	END AS [Write Latency],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE (io_stall/(num_of_reads + num_of_writes)) 
	END AS [Overall Latency],
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (num_of_bytes_read/num_of_reads) 
	END AS [Avg Bytes/Read],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (num_of_bytes_written/num_of_writes) 
	END AS [Avg Bytes/Write],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE ((num_of_bytes_read + num_of_bytes_written)/(num_of_reads + num_of_writes)) 
	END AS [Avg Bytes/Transfer]
FROM (SELECT LEFT(UPPER(mf.physical_name), 2) AS Drive, SUM(num_of_reads) AS num_of_reads,
	         SUM(io_stall_read_ms) AS io_stall_read_ms, SUM(num_of_writes) AS num_of_writes,
	         SUM(io_stall_write_ms) AS io_stall_write_ms, SUM(num_of_bytes_read) AS num_of_bytes_read,
	         SUM(num_of_bytes_written) AS num_of_bytes_written, SUM(io_stall) AS io_stall, vs.volume_mount_point 
      FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS vfs
      INNER JOIN sys.master_files AS mf WITH (NOLOCK)
      ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id
	  CROSS APPLY sys.dm_os_volume_stats(mf.database_id, mf.[file_id]) AS vs 
      GROUP BY LEFT(UPPER(mf.physical_name), 2), vs.volume_mount_point) AS tab
ORDER BY [Overall Latency] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Shows you the total and free space on the LUNs where you have database files
// Being low on free space can negatively affect performance



// Drive level latency information (Query 27) (Drive Level Latency)
// Based on code from Jimmy May-->
    <Query id="27" name="Drive Level Latency" description="Drive level latency information" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT tab.[Drive], tab.volume_mount_point AS [Volume Mount Point], 
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (io_stall_read_ms/num_of_reads) 
	END AS [Read Latency],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (io_stall_write_ms/num_of_writes) 
	END AS [Write Latency],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE (io_stall/(num_of_reads + num_of_writes)) 
	END AS [Overall Latency],
	CASE 
		WHEN num_of_reads = 0 THEN 0 
		ELSE (num_of_bytes_read/num_of_reads) 
	END AS [Avg Bytes/Read],
	CASE 
		WHEN num_of_writes = 0 THEN 0 
		ELSE (num_of_bytes_written/num_of_writes) 
	END AS [Avg Bytes/Write],
	CASE 
		WHEN (num_of_reads = 0 AND num_of_writes = 0) THEN 0 
		ELSE ((num_of_bytes_read + num_of_bytes_written)/(num_of_reads + num_of_writes)) 
	END AS [Avg Bytes/Transfer]
FROM (SELECT LEFT(UPPER(mf.physical_name), 2) AS Drive, SUM(num_of_reads) AS num_of_reads,
	         SUM(io_stall_read_ms) AS io_stall_read_ms, SUM(num_of_writes) AS num_of_writes,
	         SUM(io_stall_write_ms) AS io_stall_write_ms, SUM(num_of_bytes_read) AS num_of_bytes_read,
	         SUM(num_of_bytes_written) AS num_of_bytes_written, SUM(io_stall) AS io_stall, vs.volume_mount_point 
      FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS vfs
      INNER JOIN sys.master_files AS mf WITH (NOLOCK)
      ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id
	  CROSS APPLY sys.dm_os_volume_stats(mf.database_id, mf.[file_id]) AS vs 
      GROUP BY LEFT(UPPER(mf.physical_name), 2), vs.volume_mount_point) AS tab
ORDER BY [Overall Latency] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You want to see "Available physical memory is high" for System Memory State
// This indicates that you are not under external memory pressure

// Possible System Memory State values:
// Available physical memory is high
// Physical memory usage is steady
// Available physical memory is low
// Physical memory state is transitioning


// Get SQL Server Error Log count and sizes (Query 13) (Error Log Count)-->
    <Query id="13" name="Error Log Count" description="Get SQL Server Error Log count and sizes" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
EXEC sp_enumerrorlogs;
]]></Query>
    <!--//////
   
// You want to see "Available physical memory is high" for System Memory State
// This indicates that you are not under external memory pressure

// Possible System Memory State values:
// Available physical memory is high
// Physical memory usage is steady
// Available physical memory is low
// Physical memory state is transitioning


// Get SQL Server Error Log count and sizes (Query 14) (Error Log Count)-->
    <Query id="14" name="Error Log Count" description="Get SQL Server Error Log count and sizes" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
EXEC sp_enumerrorlogs;
]]></Query>
    <!--//////
   
// You want to see "Available physical memory is high" for System Memory State
// This indicates that you are not under external memory pressure

// Possible System Memory State values:
// Available physical memory is high
// Physical memory usage is steady
// Available physical memory is low
// Physical memory state is transitioning


// Get SQL Server Error Log count and sizes (Query 14) (Error Log Count)-->
    <Query id="14" name="Error Log Count" description="Get SQL Server Error Log count and sizes" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
EXEC sp_enumerrorlogs;
]]></Query>
    <!--//////
   
// You want to see "Available physical memory is high" for System Memory State
// This indicates that you are not under external memory pressure

// Possible System Memory State values:
// Available physical memory is high
// Physical memory usage is steady
// Available physical memory is low
// Physical memory state is transitioning


// Get SQL Server Error Log count and sizes (Query 14) (Error Log Count)-->
    <Query id="14" name="Error Log Count" description="Get SQL Server Error Log count and sizes" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
EXEC sp_enumerrorlogs;
]]></Query>
    <!--//////
   
// Helps you find the highest average elapsed time queries across the entire instance
// Can also help track down parameter sniffing issues




// Database specific queries *****************************************************************

// **** Please switch to a user database that you are interested in! *****
//USE YourDatabaseName; // make sure to change to an actual database on your instance, not the master system database
//GO

// Individual File Sizes and space available for current database  (Query 43) (File Sizes and Space)-->
    <Query id="43" name="File Sizes and Space" description="Individual File Sizes and space available for current database" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT f.name AS [File Name] , f.physical_name AS [Physical Name], 
CAST((f.size/128.0) AS DECIMAL(15,2)) AS [Total Size in MB],
CAST(f.size/128.0 - CAST(FILEPROPERTY(f.name, 'SpaceUsed') AS int)/128.0 AS DECIMAL(15,2)) 
AS [Available Space In MB], f.[file_id], fg.name AS [Filegroup Name],
f.is_percent_growth, f.growth, 
fg.is_default, fg.is_read_only
FROM sys.database_files AS f WITH (NOLOCK) 
LEFT OUTER JOIN sys.filegroups AS fg WITH (NOLOCK)
ON f.data_space_id = fg.data_space_id
ORDER BY f.[file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you find the highest average elapsed time queries across the entire instance
// Can also help track down parameter sniffing issues




// Database specific queries *****************************************************************

// **** Please switch to a user database that you are interested in! *****
//USE YourDatabaseName; // make sure to change to an actual database on your instance, not the master system database
//GO

// Individual File Sizes and space available for current database  (Query 48) (File Sizes and Space)-->
    <Query id="48" name="File Sizes and Space" description="Individual File Sizes and space available for current database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT f.name AS [File Name] , f.physical_name AS [Physical Name], 
CAST((f.size/128.0) AS DECIMAL(15,2)) AS [Total Size in MB],
CAST(f.size/128.0 - CAST(FILEPROPERTY(f.name, 'SpaceUsed') AS int)/128.0 AS DECIMAL(15,2)) 
AS [Available Space In MB], f.[file_id], fg.name AS [Filegroup Name],
f.is_percent_growth, f.growth, 
fg.is_default, fg.is_read_only
FROM sys.database_files AS f WITH (NOLOCK) 
LEFT OUTER JOIN sys.filegroups AS fg WITH (NOLOCK)
ON f.data_space_id = fg.data_space_id
ORDER BY f.[file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// sys.dm_exec_function_stats (Transact-SQL)
// https://msdn.microsoft.com/en-US/library/mt429371.aspx



// Database specific queries *****************************************************************

// **** Please switch to a user database that you are interested in! *****
//USE YourDatabaseName; // make sure to change to an actual database on your instance, not the master system database
//GO

// Individual File Sizes and space available for current database  (Query 49) (File Sizes and Space)-->
    <Query id="49" name="File Sizes and Space" description="Individual File Sizes and space available for current database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT f.name AS [File Name] , f.physical_name AS [Physical Name], 
CAST((f.size/128.0) AS DECIMAL(15,2)) AS [Total Size in MB],
CAST(f.size/128.0 - CAST(FILEPROPERTY(f.name, 'SpaceUsed') AS int)/128.0 AS DECIMAL(15,2)) 
AS [Available Space In MB], f.[file_id], fg.name AS [Filegroup Name],
f.is_percent_growth, f.growth, 
fg.is_default, fg.is_read_only, fg.is_autogrow_all_files
FROM sys.database_files AS f WITH (NOLOCK) 
LEFT OUTER JOIN sys.filegroups AS fg WITH (NOLOCK)
ON f.data_space_id = fg.data_space_id
ORDER BY f.[file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// sys.dm_exec_function_stats (Transact-SQL)
// https://msdn.microsoft.com/en-US/library/mt429371.aspx



// Database specific queries *****************************************************************

// **** Please switch to a user database that you are interested in! *****
//USE YourDatabaseName; // make sure to change to an actual database on your instance, not the master system database
//GO

// Individual File Sizes and space available for current database  (Query 49) (File Sizes and Space)-->
    <Query id="49" name="File Sizes and Space" description="Individual File Sizes and space available for current database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT f.name AS [File Name] , f.physical_name AS [Physical Name], 
CAST((f.size/128.0) AS DECIMAL(15,2)) AS [Total Size in MB],
CAST(f.size/128.0 - CAST(FILEPROPERTY(f.name, 'SpaceUsed') AS int)/128.0 AS DECIMAL(15,2)) 
AS [Available Space In MB], f.[file_id], fg.name AS [Filegroup Name],
f.is_percent_growth, f.growth, 
fg.is_default, fg.is_read_only, fg.is_autogrow_all_files
FROM sys.database_files AS f WITH (NOLOCK) 
LEFT OUTER JOIN sys.filegroups AS fg WITH (NOLOCK)
ON f.data_space_id = fg.data_space_id
ORDER BY f.[file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent Alerts (which are different from SQL Server Agent jobs)
// Read more about Agent Alerts here: http://www.sqlskills.com/blogs/glenn/creating-sql-server-agent-alerts-for-critical-errors/


// Returns a list of all global trace flags that are enabled (Query 6) (Global Trace Flags)-->
    <Query id="6" name="Global Trace Flags" description="Returns a list of all global trace flags that are enabled" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
DBCC TRACESTATUS (-1);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent Alerts (which are different from SQL Server Agent jobs)
// Read more about Agent Alerts here: http://www.sqlskills.com/blogs/glenn/creating-sql-server-agent-alerts-for-critical-errors/


// Returns a list of all global trace flags that are enabled (Query 6) (Global Trace Flags)-->
    <Query id="6" name="Global Trace Flags" description="Returns a list of all global trace flags that are enabled" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
DBCC TRACESTATUS (-1);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent Alerts (which are different from SQL Server Agent jobs)
// Read more about Agent Alerts here: http://www.sqlskills.com/blogs/glenn/creating-sql-server-agent-alerts-for-critical-errors/


// Returns a list of all global trace flags that are enabled (Query 6) (Global Trace Flags)-->
    <Query id="6" name="Global Trace Flags" description="Returns a list of all global trace flags that are enabled" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
DBCC TRACESTATUS (-1);
]]></Query>
    <!--//////
   
// Focus on these settings:
// backup compression default (should be 1 in most cases)
// clr enabled (only enable if it is needed)
// cost threshold for parallelism (depends on your workload)
// lightweight pooling (should be zero)
// max degree of parallelism (depends on your workload and hardware)
// max server memory (MB) (set to an appropriate value, not the default)
// optimize for ad hoc workloads (should be 1)
// priority boost (should be zero)
// remote admin connections (should be 1)


// Returns a list of all global trace flags that are enabled (Query 5) (Global Trace Flags)-->
    <Query id="5" name="Global Trace Flags" description="Returns a list of all global trace flags that are enabled" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
DBCC TRACESTATUS (-1);
]]></Query>
    <!--//////
   
// Focus on these settings:
// backup checksum default (should be 1)
// backup compression default (should be 1 in most cases)
// clr enabled (only enable if it is needed)
// cost threshold for parallelism (depends on your workload)
// lightweight pooling (should be zero)
// max degree of parallelism (depends on your workload and hardware)
// max server memory (MB) (set to an appropriate value, not the default)
// optimize for ad hoc workloads (should be 1)
// priority boost (should be zero)
// remote admin connections (should be 1)


// Returns a list of all global trace flags that are enabled (Query 5) (Global Trace Flags)-->
    <Query id="5" name="Global Trace Flags" description="Returns a list of all global trace flags that are enabled" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
DBCC TRACESTATUS (-1);
]]></Query>
    <!--//////
   
// Focus on these settings:
// automatic soft-NUMA disabled (should be 0 in most cases)
// backup checksum default (should be 1)
// backup compression default (should be 1 in most cases)
// clr enabled (only enable if it is needed)
// cost threshold for parallelism (depends on your workload)
// lightweight pooling (should be zero)
// max degree of parallelism (depends on your workload and hardware)
// max server memory (MB) (set to an appropriate value, not the default)
// optimize for ad hoc workloads (should be 1)
// priority boost (should be zero)
// remote admin connections (should be 1)

// New configuration options for SQL Server 2016
// allow polybase export (Allow INSERT into a Hadoop external table)
// automatic soft-NUMA disabled (Automatic soft-NUMA is enabled by default)
// external scripts enabled (Allows execution of external scripts, for R Services)
// hadoop connectivity (Configure SQL Server to connect to external Hadoop or Microsoft Azure storage blob data sources through PolyBase)
// polybase network encryption (Configure SQL Server to encrypt control and data channels when using PolyBase)
// remote data archive (Allow the use of the REMOTE_DATA_ARCHIVE data access for Stretch databases)

// SQLSweet16!, Episode 1: Backup Compression for TDE-enabled Databases
// https://blogs.msdn.microsoft.com/sqlcat/2016/06/20/sqlsweet16-episode-1-backup-compression-for-tde-enabled-databases/



// Returns a list of all global trace flags that are enabled (Query 5) (Global Trace Flags)-->
    <Query id="5" name="Global Trace Flags" description="Returns a list of all global trace flags that are enabled" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
DBCC TRACESTATUS (-1);
]]></Query>
    <!--//////
   
// Focus on these settings:
// automatic soft-NUMA disabled (should be 0 in most cases)
// backup checksum default (should be 1)
// backup compression default (should be 1 in most cases)
// clr enabled (only enable if it is needed)
// cost threshold for parallelism (depends on your workload)
// lightweight pooling (should be zero)
// max degree of parallelism (depends on your workload and hardware)
// max server memory (MB) (set to an appropriate value, not the default)
// optimize for ad hoc workloads (should be 1)
// priority boost (should be zero)
// remote admin connections (should be 1)

// New configuration options for SQL Server 2016
// allow polybase export (Allow INSERT into a Hadoop external table)
// automatic soft-NUMA disabled (Automatic soft-NUMA is enabled by default)
// external scripts enabled (Allows execution of external scripts, for R Services)
// hadoop connectivity (Configure SQL Server to connect to external Hadoop or Microsoft Azure storage blob data sources through PolyBase)
// polybase network encryption (Configure SQL Server to encrypt control and data channels when using PolyBase)
// remote data archive (Allow the use of the REMOTE_DATA_ARCHIVE data access for Stretch databases)

// SQLSweet16!, Episode 1: Backup Compression for TDE-enabled Databases
// https://blogs.msdn.microsoft.com/sqlcat/2016/06/20/sqlsweet16-episode-1-backup-compression-for-tde-enabled-databases/



// Returns a list of all global trace flags that are enabled (Query 5) (Global Trace Flags)-->
    <Query id="5" name="Global Trace Flags" description="Returns a list of all global trace flags that are enabled" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
DBCC TRACESTATUS (-1);
]]></Query>
    <!--// If no global trace flags are enabled, no results will be returned.
   // It is very useful to know what global trace flags are currently enabled as part of the diagnostic process.

// Common trace flags that should be enabled in most cases
// TF 1117 - When growing a data file, grow all files at the same time so they remain the same size, reducing allocation contention points
//           http://support2.microsoft.com/kb/2154845
// 
// TF 1118 - Helps alleviate allocation contention in tempdb, SQL Server allocates full extents to each database object, 
//           thereby eliminating the contention on SGAM pages (more important with older versions of SQL Server)
//           Recommendations to reduce allocation contention in SQL Server tempdb database
//           http://support2.microsoft.com/kb/2154845

// TF 3226 - Supresses logging of successful database backup messages to the SQL Server Error Log
//           http://www.sqlskills.com/blogs/paul/fed-up-with-backup-success-messages-bloating-your-error-logs/


// Hardware Information from SQL Server 2005  (Query 7) (Hardware Info)
// (Cannot distinguish between HT and multi-core)-->
    <Query id="7" name="Hardware Info" description="Hardware Information from SQL Server 2005" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT cpu_count AS [Logical CPU Count], hyperthread_ratio AS [Hyperthread Ratio],
cpu_count/hyperthread_ratio AS [Physical CPU Count], 
physical_memory_in_bytes/1048576 AS [Physical Memory (MB)]
FROM sys.dm_os_sys_info WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some useful information about the composition 
// and relative load on your NUMA nodes


// Hardware information from SQL Server 2008 R2  (Query 10) (Hardware Info)
// (Cannot distinguish between HT and multi-core)-->
    <Query id="10" name="Hardware Info" description="Hardware information from SQL Server 2008 R2" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT cpu_count AS [Logical CPU Count], hyperthread_ratio AS [Hyperthread Ratio],
cpu_count/hyperthread_ratio AS [Physical CPU Count], 
physical_memory_in_bytes/1048576 AS [Physical Memory (MB)], 
sqlserver_start_time, affinity_type_desc 
FROM sys.dm_os_sys_info WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some useful information about the composition 
// and relative load on your NUMA nodes


// Hardware information from SQL Server 2008  (Query 8) (Hardware Info)
// (Cannot distinguish between HT and multi-core)-->
    <Query id="8" name="Hardware Info" description="Hardware information from SQL Server 2008" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT cpu_count AS [Logical CPU Count], hyperthread_ratio AS [Hyperthread Ratio],
cpu_count/hyperthread_ratio AS [Physical CPU Count], 
physical_memory_in_bytes/1048576 AS [Physical Memory (MB)], sqlserver_start_time 
FROM sys.dm_os_sys_info WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You will see no results if your instance is not using AlwaysOn AGs



// Hardware information from SQL Server 2012  (Query 16) (Hardware Info)-->
    <Query id="16" name="Hardware Info" description="Hardware information from SQL Server 2012" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT cpu_count AS [Logical CPU Count], scheduler_count, hyperthread_ratio AS [Hyperthread Ratio],
cpu_count/hyperthread_ratio AS [Physical CPU Count], 
physical_memory_kb/1024 AS [Physical Memory (MB)], committed_kb/1024 AS [Committed Memory (MB)],
committed_target_kb/1024 AS [Committed Target Memory (MB)],
max_workers_count AS [Max Workers Count], affinity_type_desc AS [Affinity Type], 
sqlserver_start_time AS [SQL Server Start Time], virtual_machine_type_desc AS [Virtual Machine Type]  
FROM sys.dm_os_sys_info WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You will see no results if your instance is not using AlwaysOn AGs


// Hardware information from SQL Server 2014  (Query 18) (Hardware Info)-->
    <Query id="18" name="Hardware Info" description="Hardware information from SQL Server 2014" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT cpu_count AS [Logical CPU Count], scheduler_count, hyperthread_ratio AS [Hyperthread Ratio],
cpu_count/hyperthread_ratio AS [Physical CPU Count], 
physical_memory_kb/1024 AS [Physical Memory (MB)], committed_kb/1024 AS [Committed Memory (MB)],
committed_target_kb/1024 AS [Committed Target Memory (MB)],
max_workers_count AS [Max Workers Count], affinity_type_desc AS [Affinity Type], 
sqlserver_start_time AS [SQL Server Start Time], virtual_machine_type_desc AS [Virtual Machine Type]
FROM sys.dm_os_sys_info WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You will see no results if your instance is not using AlwaysOn AGs

// SQL Server 2016  It Just Runs Faster: Always On Availability Groups Turbocharged
// https://blogs.msdn.microsoft.com/bobsql/2016/09/26/sql-server-2016-it-just-runs-faster-always-on-availability-groups-turbocharged/


// Hardware information from SQL Server 2016  (Query 18) (Hardware Info)-->
    <Query id="18" name="Hardware Info" description="Hardware information from SQL Server 2016" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT cpu_count AS [Logical CPU Count], scheduler_count, hyperthread_ratio AS [Hyperthread Ratio],
cpu_count/hyperthread_ratio AS [Physical CPU Count], 
physical_memory_kb/1024 AS [Physical Memory (MB)], committed_kb/1024 AS [Committed Memory (MB)],
committed_target_kb/1024 AS [Committed Target Memory (MB)],
max_workers_count AS [Max Workers Count], affinity_type_desc AS [Affinity Type], 
sqlserver_start_time AS [SQL Server Start Time], virtual_machine_type_desc AS [Virtual Machine Type], 
softnuma_configuration_desc AS [Soft NUMA Configuration],
sql_memory_model_desc -- New in SQL Server 2016 SP1
FROM sys.dm_os_sys_info WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You will see no results if your instance is not using AlwaysOn AGs

// SQL Server 2016  It Just Runs Faster: Always On Availability Groups Turbocharged
// https://blogs.msdn.microsoft.com/bobsql/2016/09/26/sql-server-2016-it-just-runs-faster-always-on-availability-groups-turbocharged/


// Hardware information from SQL Server 2016  (Query 18) (Hardware Info)-->
    <Query id="18" name="Hardware Info" description="Hardware information from SQL Server 2016" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT cpu_count AS [Logical CPU Count], scheduler_count, hyperthread_ratio AS [Hyperthread Ratio],
cpu_count/hyperthread_ratio AS [Physical CPU Count], 
physical_memory_kb/1024 AS [Physical Memory (MB)], committed_kb/1024 AS [Committed Memory (MB)],
committed_target_kb/1024 AS [Committed Target Memory (MB)],
max_workers_count AS [Max Workers Count], affinity_type_desc AS [Affinity Type], 
sqlserver_start_time AS [SQL Server Start Time], virtual_machine_type_desc AS [Virtual Machine Type], 
softnuma_configuration_desc AS [Soft NUMA Configuration], sql_memory_model_desc, 
process_physical_affinity -- New in SQL Server vNext CTP 1.0
FROM sys.dm_os_sys_info WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// New for SQL Server 2016
// Requires that QueryStore is enabled for this database

// Tuning Workload Performance with Query Store
// http://blogs.technet.com/b/dataplatforminsider/archive/2015/12/16/tuning-workload-performance-with-query-store.aspx


// Get highest aggregate duration queries over last hour (Query 77) (High Aggregate Duration Queries)-->
    <Query id="77" name="High Aggregate Duration Queries" description="Get highest aggregate duration queries over last hour" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
WITH AggregatedDurationLastHour
AS
(SELECT q.query_id, SUM(count_executions * avg_duration) AS total_duration,
   COUNT (distinct p.plan_id) AS number_of_plans
   FROM sys.query_store_query_text AS qt WITH (NOLOCK)
   INNER JOIN sys.query_store_query AS q WITH (NOLOCK)
   ON qt.query_text_id = q.query_text_id
   INNER JOIN sys.query_store_plan AS p WITH (NOLOCK)
   ON q.query_id = p.query_id
   INNER JOIN sys.query_store_runtime_stats AS rs WITH (NOLOCK)
   ON rs.plan_id = p.plan_id
   INNER JOIN sys.query_store_runtime_stats_interval AS rsi WITH (NOLOCK)
   ON rsi.runtime_stats_interval_id = rs.runtime_stats_interval_id
   WHERE rsi.start_time >= DATEADD(hour, -1, GETUTCDATE()) 
   AND rs.execution_type_desc = N'Regular'
   GROUP BY q.query_id),
OrderedDuration AS
(SELECT query_id, total_duration, number_of_plans, 
 ROW_NUMBER () OVER (ORDER BY total_duration DESC, query_id) AS RN
 FROM AggregatedDurationLastHour)
SELECT OBJECT_NAME(q.object_id) AS [Containing Object], qt.query_sql_text, 
od.total_duration AS [Total Duration (microsecs)], 
od.number_of_plans AS [Plan Count],
p.is_forced_plan, p.is_parallel_plan, p.is_trivial_plan,
q.query_parameterization_type_desc, p.[compatibility_level],
p.last_compile_start_time, q.last_execution_time,
CONVERT(xml, p.query_plan) AS query_plan_xml 
FROM OrderedDuration AS od 
INNER JOIN sys.query_store_query AS q WITH (NOLOCK)
ON q.query_id  = od.query_id
INNER JOIN sys.query_store_query_text AS qt WITH (NOLOCK)
ON q.query_text_id = qt.query_text_id
INNER JOIN sys.query_store_plan AS p WITH (NOLOCK)
ON q.query_id = p.query_id
WHERE od.RN <= 50 
ORDER BY total_duration DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// New for SQL Server 2016
// Requires that QueryStore is enabled for this database

// Tuning Workload Performance with Query Store
// http://blogs.technet.com/b/dataplatforminsider/archive/2015/12/16/tuning-workload-performance-with-query-store.aspx


// Get highest aggregate duration queries over last hour (Query 77) (High Aggregate Duration Queries)-->
    <Query id="77" name="High Aggregate Duration Queries" description="Get highest aggregate duration queries over last hour" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
WITH AggregatedDurationLastHour
AS
(SELECT q.query_id, SUM(count_executions * avg_duration) AS total_duration,
   COUNT (distinct p.plan_id) AS number_of_plans
   FROM sys.query_store_query_text AS qt WITH (NOLOCK)
   INNER JOIN sys.query_store_query AS q WITH (NOLOCK)
   ON qt.query_text_id = q.query_text_id
   INNER JOIN sys.query_store_plan AS p WITH (NOLOCK)
   ON q.query_id = p.query_id
   INNER JOIN sys.query_store_runtime_stats AS rs WITH (NOLOCK)
   ON rs.plan_id = p.plan_id
   INNER JOIN sys.query_store_runtime_stats_interval AS rsi WITH (NOLOCK)
   ON rsi.runtime_stats_interval_id = rs.runtime_stats_interval_id
   WHERE rsi.start_time >= DATEADD(hour, -1, GETUTCDATE()) 
   AND rs.execution_type_desc = N'Regular'
   GROUP BY q.query_id),
OrderedDuration AS
(SELECT query_id, total_duration, number_of_plans, 
 ROW_NUMBER () OVER (ORDER BY total_duration DESC, query_id) AS RN
 FROM AggregatedDurationLastHour)
SELECT OBJECT_NAME(q.object_id) AS [Containing Object], qt.query_sql_text, 
od.total_duration AS [Total Duration (microsecs)], 
od.number_of_plans AS [Plan Count],
p.is_forced_plan, p.is_parallel_plan, p.is_trivial_plan,
q.query_parameterization_type_desc, p.[compatibility_level],
p.last_compile_start_time, q.last_execution_time,
CONVERT(xml, p.query_plan) AS query_plan_xml 
FROM OrderedDuration AS od 
INNER JOIN sys.query_store_query AS q WITH (NOLOCK)
ON q.query_id  = od.query_id
INNER JOIN sys.query_store_query_text AS qt WITH (NOLOCK)
ON q.query_text_id = qt.query_text_id
INNER JOIN sys.query_store_plan AS p WITH (NOLOCK)
ON q.query_id = p.query_id
WHERE od.RN <= 50 
ORDER BY total_duration DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent Alerts (which are different from SQL Server Agent jobs)
// Read more about Agent Alerts here: http://www.sqlskills.com/blogs/glenn/creating-sql-server-agent-alerts-for-critical-errors/



// Host information (Query 11) (Host Info)-->
    <Query id="11" name="Host Info" description="Host information" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT host_platform, host_distribution, host_release, 
       host_service_pack_level, host_sku, os_language_version  
FROM sys.dm_os_host_info WITH (NOLOCK) OPTION (RECOMPILE); 
]]></Query>
    <!--//////
   
// If no global trace flags are enabled, no results will be returned.
// It is very useful to know what global trace flags are currently enabled as part of the diagnostic process.

// Common trace flags that should be enabled in most cases
// TF 1117 - When growing a data file, grow all files at the same time so they remain the same size, reducing allocation contention points
//           http://support2.microsoft.com/kb/2154845
// 
// TF 1118 - Helps alleviate allocation contention in tempdb, SQL Server allocates full extents to each database object, 
//           thereby eliminating the contention on SGAM pages (more important with older versions of SQL Server)
//           Recommendations to reduce allocation contention in SQL Server tempdb database
//           http://support2.microsoft.com/kb/2154845

// TF 2371 - Lowers auto update statistics threshold for large tables
//           http://blogs.msdn.com/b/saponsqlserver/archive/2011/09/07/changes-to-automatic-update-statistics-in-sql-server-traceflag-2371.aspx

// TF 3226 - Supresses logging of successful database backup messages to the SQL Server Error Log
//           http://www.sqlskills.com/blogs/paul/fed-up-with-backup-success-messages-bloating-your-error-logs/


// TF 6533 - Spatial performance improvements in SQL Server 2012 and 2014
//           https://support.microsoft.com/en-us/kb/3107399

// TF 6534 - Enables use of native code to improve performance with spatial data
//           https://blogs.msdn.microsoft.com/bobsql/2016/06/03/sql-2016-it-just-runs-faster-native-spatial-implementations/

// SQL Server query optimizer hotfix trace flag 4199 servicing model
// https://support.microsoft.com/en-us/kb/974006



// Returns status of instant file initialization (Query 6) (IFI Status)-->
    <Query id="6" name="IFI Status" description="Returns status of instant file initialization" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
EXEC sys.xp_readerrorlog 0, 1, N'Database Instant File Initialization';
]]></Query>
    <!--//////
   
// If no global trace flags are enabled, no results will be returned.
// It is very useful to know what global trace flags are currently enabled as part of the diagnostic process.

// Common trace flags that should be enabled in most cases
// TF 3226 - Supresses logging of successful database backup messages to the SQL Server Error Log
//           http://www.sqlskills.com/blogs/paul/fed-up-with-backup-success-messages-bloating-your-error-logs/

// TF 6534 - Enables use of native code to improve performance with spatial data
//           https://blogs.msdn.microsoft.com/bobsql/2016/06/03/sql-2016-it-just-runs-faster-native-spatial-implementations/

// The behavior of TF 1117, 1118 are enabled for tempdb in SQL Server 2016 by default
// SQL 2016  It Just Runs Faster: -T1117 and -T1118 changes for TEMPDB and user databases
//           https://blogs.msdn.microsoft.com/psssql/2016/03/15/sql-2016-it-just-runs-faster-t1117-and-t1118-changes-for-tempdb-and-user-databases/

// The behavior of TF 2371 is enabled by default in SQL Server 2016 (in compat level 130)


// SQL Server query optimizer hotfix trace flag 4199 servicing model
// https://support.microsoft.com/en-us/kb/974006



// Returns status of instant file initialization (Query 6) (IFI Status)-->
    <Query id="6" name="IFI Status" description="Returns status of instant file initialization" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
EXEC sys.xp_readerrorlog 0, 1, N'Database Instant File Initialization';
]]></Query>
    <!--//////
   
// If no global trace flags are enabled, no results will be returned.
// It is very useful to know what global trace flags are currently enabled as part of the diagnostic process.

// Common trace flags that should be enabled in most cases
// TF 3226 - Supresses logging of successful database backup messages to the SQL Server Error Log
//           http://www.sqlskills.com/blogs/paul/fed-up-with-backup-success-messages-bloating-your-error-logs/

// TF 6534 - Enables use of native code to improve performance with spatial data
//           https://blogs.msdn.microsoft.com/bobsql/2016/06/03/sql-2016-it-just-runs-faster-native-spatial-implementations/

// The behavior of TF 1117, 1118 are enabled for tempdb in SQL Server 2016 by default
// SQL 2016  It Just Runs Faster: -T1117 and -T1118 changes for TEMPDB and user databases
//           https://blogs.msdn.microsoft.com/psssql/2016/03/15/sql-2016-it-just-runs-faster-t1117-and-t1118-changes-for-tempdb-and-user-databases/

// The behavior of TF 2371 is enabled by default in SQL Server 2016 (in compat level 130)


// SQL Server query optimizer hotfix trace flag 4199 servicing model
// https://support.microsoft.com/en-us/kb/974006



// Returns status of instant file initialization (Query 6) (IFI Status)-->
    <Query id="6" name="IFI Status" description="Returns status of instant file initialization" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
EXEC sys.xp_readerrorlog 0, 1, N'Database Instant File Initialization';
]]></Query>
    <!--//////  
   
// Helps discover possible problems with out-of-date statistics
// Also gives you an idea which indexes are the most active



// Get fragmentation info for all indexes above a certain size in the current database  (Query 47) (Index Fragmentation)
// Note: This query could take some time on a very large database-->
    <Query id="47" name="Index Fragmentation" description="Get fragmentation info for all indexes above a certain size in the current database" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT DB_NAME(ps.database_id) AS [Database Name], OBJECT_NAME(ps.OBJECT_ID) AS [Object Name], 
i.name AS [Index Name], ps.index_id, ps.index_type_desc, ps.avg_fragmentation_in_percent, 
ps.fragment_count, ps.page_count, i.fill_factor
FROM sys.dm_db_index_physical_stats(DB_ID(),NULL, NULL, NULL , N'LIMITED') AS ps
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ps.[object_id] = i.[object_id] 
AND ps.index_id = i.index_id
WHERE ps.database_id = DB_ID()
AND ps.page_count > 2500
ORDER BY ps.avg_fragmentation_in_percent DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// Get fragmentation info for all indexes above a certain size in the current database  (Query 60) (Index Fragmentation)
// Note: This query could take some time on a very large database-->
    <Query id="60" name="Index Fragmentation" description="Get fragmentation info for all indexes above a certain size in the current database" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT DB_NAME(ps.database_id) AS [Database Name], SCHEMA_NAME(o.[schema_id]) AS [Schema Name],
OBJECT_NAME(ps.OBJECT_ID) AS [Object Name], 
i.name AS [Index Name], ps.index_id, ps.index_type_desc, ps.avg_fragmentation_in_percent, 
ps.fragment_count, ps.page_count, i.fill_factor, i.has_filter, i.filter_definition, i.allow_page_locks
FROM sys.dm_db_index_physical_stats(DB_ID(),NULL, NULL, NULL , N'LIMITED') AS ps
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ps.[object_id] = i.[object_id] 
AND ps.index_id = i.index_id
INNER JOIN sys.objects AS o WITH (NOLOCK)
ON i.[object_id] = o.[object_id]
WHERE ps.database_id = DB_ID()
AND ps.page_count > 2500
ORDER BY ps.avg_fragmentation_in_percent DESC OPTION (RECOMPILE);
]]></Query>
    <!--////// 
   
// Helps discover possible problems with out-of-date statistics
// Also gives you an idea which indexes are the most active


// Get fragmentation info for all indexes above a certain size in the current database  (Query 55) (Index Fragmentation)
// Note: This query could take some time on a very large database-->
    <Query id="55" name="Index Fragmentation" description="Get fragmentation info for all indexes above a certain size in the current database" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT DB_NAME(ps.database_id) AS [Database Name], OBJECT_NAME(ps.OBJECT_ID) AS [Object Name], 
i.name AS [Index Name], ps.index_id, ps.index_type_desc, ps.avg_fragmentation_in_percent, 
ps.fragment_count, ps.page_count, i.fill_factor, i.has_filter, i.filter_definition
FROM sys.dm_db_index_physical_stats(DB_ID(),NULL, NULL, NULL , N'LIMITED') AS ps
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ps.[object_id] = i.[object_id] 
AND ps.index_id = i.index_id
WHERE ps.database_id = DB_ID()
AND ps.page_count > 2500
ORDER BY ps.avg_fragmentation_in_percent DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you understand your workload and make better decisions about 
// things like data compression and adding new indexes to a table



// Get fragmentation info for all indexes above a certain size in the current database  (Query 61) (Index Fragmentation)
// Note: This query could take some time on a very large database-->
    <Query id="61" name="Index Fragmentation" description="Get fragmentation info for all indexes above a certain size in the current database" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT DB_NAME(ps.database_id) AS [Database Name], SCHEMA_NAME(o.[schema_id]) AS [Schema Name],
OBJECT_NAME(ps.OBJECT_ID) AS [Object Name], i.[name] AS [Index Name], ps.index_id, 
ps.index_type_desc, ps.avg_fragmentation_in_percent, 
ps.fragment_count, ps.page_count, i.fill_factor, i.has_filter, 
i.filter_definition, i.[allow_page_locks]
FROM sys.dm_db_index_physical_stats(DB_ID(),NULL, NULL, NULL , N'LIMITED') AS ps
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ps.[object_id] = i.[object_id] 
AND ps.index_id = i.index_id
INNER JOIN sys.objects AS o WITH (NOLOCK)
ON i.[object_id] = o.[object_id]
WHERE ps.database_id = DB_ID()
AND ps.page_count > 2500
ORDER BY ps.avg_fragmentation_in_percent DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you understand your workload and make better decisions about 
// things like data compression and adding new indexes to a table



// Get fragmentation info for all indexes above a certain size in the current database  (Query 67) (Index Fragmentation)
// Note: This query could take some time on a very large database-->
    <Query id="67" name="Index Fragmentation" description="Get fragmentation info for all indexes above a certain size in the current database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT DB_NAME(ps.database_id) AS [Database Name], SCHEMA_NAME(o.[schema_id]) AS [Schema Name],
OBJECT_NAME(ps.OBJECT_ID) AS [Object Name], i.[name] AS [Index Name], ps.index_id, 
ps.index_type_desc, ps.avg_fragmentation_in_percent, 
ps.fragment_count, ps.page_count, i.fill_factor, i.has_filter, 
i.filter_definition, i.[allow_page_locks]
FROM sys.dm_db_index_physical_stats(DB_ID(),NULL, NULL, NULL , N'LIMITED') AS ps
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ps.[object_id] = i.[object_id] 
AND ps.index_id = i.index_id
INNER JOIN sys.objects AS o WITH (NOLOCK)
ON i.[object_id] = o.[object_id]
WHERE ps.database_id = DB_ID()
AND ps.page_count > 2500
ORDER BY ps.avg_fragmentation_in_percent DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you understand your workload and make better decisions about 
// things like data compression and adding new indexes to a table



// Get fragmentation info for all indexes above a certain size in the current database  (Query 69) (Index Fragmentation)
// Note: This query could take some time on a very large database-->
    <Query id="69" name="Index Fragmentation" description="Get fragmentation info for all indexes above a certain size in the current database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT DB_NAME(ps.database_id) AS [Database Name], SCHEMA_NAME(o.[schema_id]) AS [Schema Name],
OBJECT_NAME(ps.OBJECT_ID) AS [Object Name], i.[name] AS [Index Name], ps.index_id, 
ps.index_type_desc, ps.avg_fragmentation_in_percent, 
ps.fragment_count, ps.page_count, i.fill_factor, i.has_filter, 
i.filter_definition, i.[allow_page_locks]
FROM sys.dm_db_index_physical_stats(DB_ID(),NULL, NULL, NULL , N'LIMITED') AS ps
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ps.[object_id] = i.[object_id] 
AND ps.index_id = i.index_id
INNER JOIN sys.objects AS o WITH (NOLOCK)
ON i.[object_id] = o.[object_id]
WHERE ps.database_id = DB_ID()
AND ps.page_count > 2500
ORDER BY ps.avg_fragmentation_in_percent DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you understand your workload and make better decisions about 
// things like data compression and adding new indexes to a table



// Get fragmentation info for all indexes above a certain size in the current database  (Query 69) (Index Fragmentation)
// Note: This query could take some time on a very large database-->
    <Query id="69" name="Index Fragmentation" description="Get fragmentation info for all indexes above a certain size in the current database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT DB_NAME(ps.database_id) AS [Database Name], SCHEMA_NAME(o.[schema_id]) AS [Schema Name],
OBJECT_NAME(ps.OBJECT_ID) AS [Object Name], i.[name] AS [Index Name], ps.index_id, 
ps.index_type_desc, ps.avg_fragmentation_in_percent, 
ps.fragment_count, ps.page_count, i.fill_factor, i.has_filter, 
i.filter_definition, i.[allow_page_locks]
FROM sys.dm_db_index_physical_stats(DB_ID(),NULL, NULL, NULL , N'LIMITED') AS ps
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ps.[object_id] = i.[object_id] 
AND ps.index_id = i.index_id
INNER JOIN sys.objects AS o WITH (NOLOCK)
ON i.[object_id] = o.[object_id]
WHERE ps.database_id = DB_ID()
AND ps.page_count > 2500
ORDER BY ps.avg_fragmentation_in_percent DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This query is helpful for troubleshooting blocking and deadlocking issues


// Get input buffer information for the current database (Query 72) (Input Buffer)-->
    <Query id="72" name="Input Buffer" description="Get input buffer information for the current database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT es.session_id, DB_NAME(es.database_id) AS [Database Name],
es.login_time, es.cpu_time, es.logical_reads,
es.[status], ib.event_info AS [Input Buffer]
FROM sys.dm_exec_sessions AS es WITH (NOLOCK)
CROSS APPLY sys.dm_exec_input_buffer(es.session_id, NULL) AS ib
WHERE es.database_id = DB_ID()
AND es.session_id > 50
AND es.session_id <> @@SPID OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// New for SQL Server 2016
// Requires that QueryStore is enabled for this database


// Get input buffer information for the current database (Query 78) (Input Buffer)-->
    <Query id="78" name="Input Buffer" description="Get input buffer information for the current database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT es.session_id, DB_NAME(es.database_id) AS [Database Name],
es.login_time, es.cpu_time, es.logical_reads,
es.[status], ib.event_info AS [Input Buffer]
FROM sys.dm_exec_sessions AS es WITH (NOLOCK)
CROSS APPLY sys.dm_exec_input_buffer(es.session_id, NULL) AS ib
WHERE es.database_id = DB_ID()
AND es.session_id > 50
AND es.session_id <> @@SPID OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// New for SQL Server 2016
// Requires that QueryStore is enabled for this database


// Get input buffer information for the current database (Query 78) (Input Buffer)-->
    <Query id="78" name="Input Buffer" description="Get input buffer information for the current database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT es.session_id, DB_NAME(es.database_id) AS [Database Name],
es.login_time, es.cpu_time, es.logical_reads,
es.[status], ib.event_info AS [Input Buffer]
FROM sys.dm_exec_sessions AS es WITH (NOLOCK)
CROSS APPLY sys.dm_exec_input_buffer(es.session_id, NULL) AS ib
WHERE es.database_id = DB_ID()
AND es.session_id > 50
AND es.session_id <> @@SPID OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Shows you the drive-level latency for reads and writes, in milliseconds
// Latency above 20-25ms is usually a problem


// Calculates average stalls per read, per write, and per total input/output for each database file  (Query 14) (IO Stalls by File)-->
    <Query id="14" name="IO Stalls by File" description="Calculates average stalls per read, per write, and per total input/output for each database file" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT DB_NAME(fs.database_id) AS [Database Name], CAST(fs.io_stall_read_ms/(1.0 + fs.num_of_reads) AS NUMERIC(10,1)) AS [avg_read_stall_ms],
CAST(fs.io_stall_write_ms/(1.0 + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_write_stall_ms],
CAST((fs.io_stall_read_ms + fs.io_stall_write_ms)/(1.0 + fs.num_of_reads + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_io_stall_ms],
CONVERT(DECIMAL(18,2), mf.size/128.0) AS [File Size (MB)], mf.physical_name, mf.type_desc, fs.io_stall_read_ms, fs.num_of_reads, 
fs.io_stall_write_ms, fs.num_of_writes, fs.io_stall_read_ms + fs.io_stall_write_ms AS [io_stalls], fs.num_of_reads + fs.num_of_writes AS [total_io]
FROM sys.dm_io_virtual_file_stats(null,null) AS fs
INNER JOIN sys.master_files AS mf WITH (NOLOCK)
ON fs.database_id = mf.database_id
AND fs.[file_id] = mf.[file_id]
ORDER BY avg_io_stall_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Shows you the drive-level latency for reads and writes, in milliseconds
// Latency above 20-25ms is usually a problem


// Calculates average stalls per read, per write, and per total input/output for each database file  (Query 20) (IO Stalls by File)-->
    <Query id="20" name="IO Stalls by File" description="Calculates average stalls per read, per write, and per total input/output for each database file" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT DB_NAME(fs.database_id) AS [Database Name], CAST(fs.io_stall_read_ms/(1.0 + fs.num_of_reads) AS NUMERIC(10,1)) AS [avg_read_stall_ms],
CAST(fs.io_stall_write_ms/(1.0 + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_write_stall_ms],
CAST((fs.io_stall_read_ms + fs.io_stall_write_ms)/(1.0 + fs.num_of_reads + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_io_stall_ms],
CONVERT(DECIMAL(18,2), mf.size/128.0) AS [File Size (MB)], mf.physical_name, mf.type_desc, fs.io_stall_read_ms, fs.num_of_reads, 
fs.io_stall_write_ms, fs.num_of_writes, fs.io_stall_read_ms + fs.io_stall_write_ms AS [io_stalls], fs.num_of_reads + fs.num_of_writes AS [total_io]
FROM sys.dm_io_virtual_file_stats(null,null) AS fs
INNER JOIN sys.master_files AS mf WITH (NOLOCK)
ON fs.database_id = mf.database_id
AND fs.[file_id] = mf.[file_id]
ORDER BY avg_io_stall_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Shows you the drive-level latency for reads and writes, in milliseconds
// Latency above 20-25ms is usually a problem


// Calculates average stalls per read, per write, and per total input/output for each database file  (Query 16) (IO Stalls by File)-->
    <Query id="16" name="IO Stalls by File" description="Calculates average stalls per read, per write, and per total input/output for each database file" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT DB_NAME(fs.database_id) AS [Database Name], CAST(fs.io_stall_read_ms/(1.0 + fs.num_of_reads) AS NUMERIC(10,1)) AS [avg_read_stall_ms],
CAST(fs.io_stall_write_ms/(1.0 + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_write_stall_ms],
CAST((fs.io_stall_read_ms + fs.io_stall_write_ms)/(1.0 + fs.num_of_reads + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_io_stall_ms],
CONVERT(DECIMAL(18,2), mf.size/128.0) AS [File Size (MB)], mf.physical_name, mf.type_desc, fs.io_stall_read_ms, fs.num_of_reads, 
fs.io_stall_write_ms, fs.num_of_writes, fs.io_stall_read_ms + fs.io_stall_write_ms AS [io_stalls], fs.num_of_reads + fs.num_of_writes AS [total_io]
FROM sys.dm_io_virtual_file_stats(null,null) AS fs
INNER JOIN sys.master_files AS mf WITH (NOLOCK)
ON fs.database_id = mf.database_id
AND fs.[file_id] = mf.[file_id]
ORDER BY avg_io_stall_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Shows you the drive-level latency for reads and writes, in milliseconds
// Latency above 20-25ms is usually a problem


// Calculates average stalls per read, per write, and per total input/output for each database file  (Query 23) (IO Stalls by File)-->
    <Query id="23" name="IO Stalls by File" description="Calculates average stalls per read, per write, and per total input/output for each database file" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT DB_NAME(fs.database_id) AS [Database Name], CAST(fs.io_stall_read_ms/(1.0 + fs.num_of_reads) AS NUMERIC(10,1)) AS [avg_read_stall_ms],
CAST(fs.io_stall_write_ms/(1.0 + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_write_stall_ms],
CAST((fs.io_stall_read_ms + fs.io_stall_write_ms)/(1.0 + fs.num_of_reads + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_io_stall_ms],
CONVERT(DECIMAL(18,2), mf.size/128.0) AS [File Size (MB)], mf.physical_name, mf.type_desc, fs.io_stall_read_ms, fs.num_of_reads, 
fs.io_stall_write_ms, fs.num_of_writes, fs.io_stall_read_ms + fs.io_stall_write_ms AS [io_stalls], fs.num_of_reads + fs.num_of_writes AS [total_io]
FROM sys.dm_io_virtual_file_stats(null,null) AS fs
INNER JOIN sys.master_files AS mf WITH (NOLOCK)
ON fs.database_id = mf.database_id
AND fs.[file_id] = mf.[file_id]
ORDER BY avg_io_stall_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Shows you the drive-level latency for reads and writes, in milliseconds
// Latency above 20-25ms is usually a problem


// Calculates average stalls per read, per write, and per total input/output for each database file  (Query 28) (IO Stalls by File)-->
    <Query id="28" name="IO Stalls by File" description="Calculates average stalls per read, per write, and per total input/output for each database file" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT DB_NAME(fs.database_id) AS [Database Name], CAST(fs.io_stall_read_ms/(1.0 + fs.num_of_reads) AS NUMERIC(10,1)) AS [avg_read_stall_ms],
CAST(fs.io_stall_write_ms/(1.0 + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_write_stall_ms],
CAST((fs.io_stall_read_ms + fs.io_stall_write_ms)/(1.0 + fs.num_of_reads + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_io_stall_ms],
CONVERT(DECIMAL(18,2), mf.size/128.0) AS [File Size (MB)], mf.physical_name, mf.type_desc, fs.io_stall_read_ms, fs.num_of_reads, 
fs.io_stall_write_ms, fs.num_of_writes, fs.io_stall_read_ms + fs.io_stall_write_ms AS [io_stalls], fs.num_of_reads + fs.num_of_writes AS [total_io],
io_stall_queued_read_ms AS [Resource Governor Total Read IO Latency (ms)], io_stall_queued_write_ms AS [Resource Governor Total Write IO Latency (ms)] 
FROM sys.dm_io_virtual_file_stats(null,null) AS fs
INNER JOIN sys.master_files AS mf WITH (NOLOCK)
ON fs.database_id = mf.database_id
AND fs.[file_id] = mf.[file_id]
ORDER BY avg_io_stall_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Shows you the drive-level latency for reads and writes, in milliseconds
// Latency above 30-40ms is usually a problem
// These latency numbers include all file activity against all SQL Server 
// database file on each drive since SQL Server was last started


// Calculates average stalls per read, per write, and per total input/output for each database file  (Query 28) (IO Stalls by File)-->
    <Query id="28" name="IO Stalls by File" description="Calculates average stalls per read, per write, and per total input/output for each database file" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT DB_NAME(fs.database_id) AS [Database Name], CAST(fs.io_stall_read_ms/(1.0 + fs.num_of_reads) AS NUMERIC(10,1)) AS [avg_read_stall_ms],
CAST(fs.io_stall_write_ms/(1.0 + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_write_stall_ms],
CAST((fs.io_stall_read_ms + fs.io_stall_write_ms)/(1.0 + fs.num_of_reads + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_io_stall_ms],
CONVERT(DECIMAL(18,2), mf.size/128.0) AS [File Size (MB)], mf.physical_name, mf.type_desc, fs.io_stall_read_ms, fs.num_of_reads, 
fs.io_stall_write_ms, fs.num_of_writes, fs.io_stall_read_ms + fs.io_stall_write_ms AS [io_stalls], fs.num_of_reads + fs.num_of_writes AS [total_io],
io_stall_queued_read_ms AS [Resource Governor Total Read IO Latency (ms)], io_stall_queued_write_ms AS [Resource Governor Total Write IO Latency (ms)] 
FROM sys.dm_io_virtual_file_stats(null,null) AS fs
INNER JOIN sys.master_files AS mf WITH (NOLOCK)
ON fs.database_id = mf.database_id
AND fs.[file_id] = mf.[file_id]
ORDER BY avg_io_stall_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Shows you the drive-level latency for reads and writes, in milliseconds
// Latency above 30-40ms is usually a problem
// These latency numbers include all file activity against all SQL Server 
// database file on each drive since SQL Server was last started


// Calculates average stalls per read, per write, and per total input/output for each database file  (Query 28) (IO Stalls by File)-->
    <Query id="28" name="IO Stalls by File" description="Calculates average stalls per read, per write, and per total input/output for each database file" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT DB_NAME(fs.database_id) AS [Database Name], CAST(fs.io_stall_read_ms/(1.0 + fs.num_of_reads) AS NUMERIC(10,1)) AS [avg_read_stall_ms],
CAST(fs.io_stall_write_ms/(1.0 + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_write_stall_ms],
CAST((fs.io_stall_read_ms + fs.io_stall_write_ms)/(1.0 + fs.num_of_reads + fs.num_of_writes) AS NUMERIC(10,1)) AS [avg_io_stall_ms],
CONVERT(DECIMAL(18,2), mf.size/128.0) AS [File Size (MB)], mf.physical_name, mf.type_desc, fs.io_stall_read_ms, fs.num_of_reads, 
fs.io_stall_write_ms, fs.num_of_writes, fs.io_stall_read_ms + fs.io_stall_write_ms AS [io_stalls], fs.num_of_reads + fs.num_of_writes AS [total_io],
io_stall_queued_read_ms AS [Resource Governor Total Read IO Latency (ms)], io_stall_queued_write_ms AS [Resource Governor Total Write IO Latency (ms)] 
FROM sys.dm_io_virtual_file_stats(null,null) AS fs
INNER JOIN sys.master_files AS mf WITH (NOLOCK)
ON fs.database_id = mf.database_id
AND fs.[file_id] = mf.[file_id]
ORDER BY avg_io_stall_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at how large and how full the files are and where they are located
// Make sure the transaction log is not full!!



// I/O Statistics by file for the current database  (Query 32) (IO Stats By File)-->
    <Query id="32" name="IO Stats By File" description="I/O Statistics by file for the current database" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT DB_NAME(DB_ID()) AS [Database Name], df.name AS [Logical Name], vfs.[file_id], 
df.physical_name AS [Physical Name], vfs.num_of_reads, vfs.num_of_writes, vfs.io_stall_read_ms, vfs.io_stall_write_ms,
CAST(100. * vfs.io_stall_read_ms/(vfs.io_stall_read_ms + vfs.io_stall_write_ms) AS DECIMAL(10,1)) AS [IO Stall Reads Pct],
CAST(100. * vfs.io_stall_write_ms/(vfs.io_stall_write_ms + vfs.io_stall_read_ms) AS DECIMAL(10,1)) AS [IO Stall Writes Pct],
(vfs.num_of_reads + vfs.num_of_writes) AS [Writes + Reads], 
CAST(vfs.num_of_bytes_read/1048576.0 AS DECIMAL(10, 2)) AS [MB Read], 
CAST(vfs.num_of_bytes_written/1048576.0 AS DECIMAL(10, 2)) AS [MB Written],
CAST(100. * vfs.num_of_reads/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Reads Pct],
CAST(100. * vfs.num_of_writes/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Write Pct],
CAST(100. * vfs.num_of_bytes_read/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Read Bytes Pct],
CAST(100. * vfs.num_of_bytes_written/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Written Bytes Pct]
FROM sys.dm_io_virtual_file_stats(DB_ID(), NULL) AS vfs
INNER JOIN sys.database_files AS df WITH (NOLOCK)
ON vfs.[file_id]= df.[file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at how large and how full the files are and where they are located
// Make sure the transaction log is not full!!



// I/O Statistics by file for the current database  (Query 41) (IO Stats By File)-->
    <Query id="41" name="IO Stats By File" description="I/O Statistics by file for the current database" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT DB_NAME(DB_ID()) AS [Database Name], df.name AS [Logical Name], vfs.[file_id], 
df.physical_name AS [Physical Name], vfs.num_of_reads, vfs.num_of_writes, vfs.io_stall_read_ms, vfs.io_stall_write_ms,
CAST(100. * vfs.io_stall_read_ms/(vfs.io_stall_read_ms + vfs.io_stall_write_ms) AS DECIMAL(10,1)) AS [IO Stall Reads Pct],
CAST(100. * vfs.io_stall_write_ms/(vfs.io_stall_write_ms + vfs.io_stall_read_ms) AS DECIMAL(10,1)) AS [IO Stall Writes Pct],
(vfs.num_of_reads + vfs.num_of_writes) AS [Writes + Reads], 
CAST(vfs.num_of_bytes_read/1048576.0 AS DECIMAL(10, 2)) AS [MB Read], 
CAST(vfs.num_of_bytes_written/1048576.0 AS DECIMAL(10, 2)) AS [MB Written],
CAST(100. * vfs.num_of_reads/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Reads Pct],
CAST(100. * vfs.num_of_writes/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Write Pct],
CAST(100. * vfs.num_of_bytes_read/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Read Bytes Pct],
CAST(100. * vfs.num_of_bytes_written/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Written Bytes Pct]
FROM sys.dm_io_virtual_file_stats(DB_ID(), NULL) AS vfs
INNER JOIN sys.database_files AS df WITH (NOLOCK)
ON vfs.[file_id]= df.[file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at how large and how full the files are and where they are located
// Make sure the transaction log is not full!!



// I/O Statistics by file for the current database  (Query 37) (IO Stats By File)-->
    <Query id="37" name="IO Stats By File" description="I/O Statistics by file for the current database" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT DB_NAME(DB_ID()) AS [Database Name], df.name AS [Logical Name], vfs.[file_id], 
df.physical_name AS [Physical Name], vfs.num_of_reads, vfs.num_of_writes, vfs.io_stall_read_ms, vfs.io_stall_write_ms,
CAST(100. * vfs.io_stall_read_ms/(vfs.io_stall_read_ms + vfs.io_stall_write_ms) AS DECIMAL(10,1)) AS [IO Stall Reads Pct],
CAST(100. * vfs.io_stall_write_ms/(vfs.io_stall_write_ms + vfs.io_stall_read_ms) AS DECIMAL(10,1)) AS [IO Stall Writes Pct],
(vfs.num_of_reads + vfs.num_of_writes) AS [Writes + Reads], 
CAST(vfs.num_of_bytes_read/1048576.0 AS DECIMAL(10, 2)) AS [MB Read], 
CAST(vfs.num_of_bytes_written/1048576.0 AS DECIMAL(10, 2)) AS [MB Written],
CAST(100. * vfs.num_of_reads/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Reads Pct],
CAST(100. * vfs.num_of_writes/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Write Pct],
CAST(100. * vfs.num_of_bytes_read/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Read Bytes Pct],
CAST(100. * vfs.num_of_bytes_written/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Written Bytes Pct]
FROM sys.dm_io_virtual_file_stats(DB_ID(), NULL) AS vfs
INNER JOIN sys.database_files AS df WITH (NOLOCK)
ON vfs.[file_id]= df.[file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at how large and how full the files are and where they are located
// Make sure the transaction log is not full!!


// I/O Statistics by file for the current database  (Query 44) (IO Stats By File)-->
    <Query id="44" name="IO Stats By File" description="I/O Statistics by file for the current database" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT DB_NAME(DB_ID()) AS [Database Name], df.name AS [Logical Name], vfs.[file_id], df.type_desc,
df.physical_name AS [Physical Name], CAST(vfs.size_on_disk_bytes/1048576.0 AS DECIMAL(10, 2)) AS [Size on Disk (MB)],
vfs.num_of_reads, vfs.num_of_writes, vfs.io_stall_read_ms, vfs.io_stall_write_ms,
CAST(100. * vfs.io_stall_read_ms/(vfs.io_stall_read_ms + vfs.io_stall_write_ms) AS DECIMAL(10,1)) AS [IO Stall Reads Pct],
CAST(100. * vfs.io_stall_write_ms/(vfs.io_stall_write_ms + vfs.io_stall_read_ms) AS DECIMAL(10,1)) AS [IO Stall Writes Pct],
(vfs.num_of_reads + vfs.num_of_writes) AS [Writes + Reads], 
CAST(vfs.num_of_bytes_read/1048576.0 AS DECIMAL(10, 2)) AS [MB Read], 
CAST(vfs.num_of_bytes_written/1048576.0 AS DECIMAL(10, 2)) AS [MB Written],
CAST(100. * vfs.num_of_reads/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Reads Pct],
CAST(100. * vfs.num_of_writes/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Write Pct],
CAST(100. * vfs.num_of_bytes_read/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Read Bytes Pct],
CAST(100. * vfs.num_of_bytes_written/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Written Bytes Pct]
FROM sys.dm_io_virtual_file_stats(DB_ID(), NULL) AS vfs
INNER JOIN sys.database_files AS df WITH (NOLOCK)
ON vfs.[file_id]= df.[file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at log file size and usage, along with the log reuse wait description for the current database


// I/O Statistics by file for the current database  (Query 50) (IO Stats By File)-->
    <Query id="50" name="IO Stats By File" description="I/O Statistics by file for the current database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT DB_NAME(DB_ID()) AS [Database Name], df.name AS [Logical Name], vfs.[file_id], df.type_desc,
df.physical_name AS [Physical Name], CAST(vfs.size_on_disk_bytes/1048576.0 AS DECIMAL(10, 2)) AS [Size on Disk (MB)],
vfs.num_of_reads, vfs.num_of_writes, vfs.io_stall_read_ms, vfs.io_stall_write_ms,
CAST(100. * vfs.io_stall_read_ms/(vfs.io_stall_read_ms + vfs.io_stall_write_ms) AS DECIMAL(10,1)) AS [IO Stall Reads Pct],
CAST(100. * vfs.io_stall_write_ms/(vfs.io_stall_write_ms + vfs.io_stall_read_ms) AS DECIMAL(10,1)) AS [IO Stall Writes Pct],
(vfs.num_of_reads + vfs.num_of_writes) AS [Writes + Reads], 
CAST(vfs.num_of_bytes_read/1048576.0 AS DECIMAL(10, 2)) AS [MB Read], 
CAST(vfs.num_of_bytes_written/1048576.0 AS DECIMAL(10, 2)) AS [MB Written],
CAST(100. * vfs.num_of_reads/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Reads Pct],
CAST(100. * vfs.num_of_writes/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Write Pct],
CAST(100. * vfs.num_of_bytes_read/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Read Bytes Pct],
CAST(100. * vfs.num_of_bytes_written/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Written Bytes Pct]
FROM sys.dm_io_virtual_file_stats(DB_ID(), NULL) AS vfs
INNER JOIN sys.database_files AS df WITH (NOLOCK)
ON vfs.[file_id]= df.[file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This lets you see the value of these new properties for the current database

// Clear plan cache for current database
// ALTER DATABASE SCOPED CONFIGURATION CLEAR PROCEDURE_CACHE;

// ALTER DATABASE SCOPED CONFIGURATION (Transact-SQL)
// https://msdn.microsoft.com/en-us/library/mt629158.aspx


// I/O Statistics by file for the current database  (Query 52) (IO Stats By File)-->
    <Query id="52" name="IO Stats By File" description="I/O Statistics by file for the current database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT DB_NAME(DB_ID()) AS [Database Name], df.name AS [Logical Name], vfs.[file_id], df.type_desc,
df.physical_name AS [Physical Name], CAST(vfs.size_on_disk_bytes/1048576.0 AS DECIMAL(10, 2)) AS [Size on Disk (MB)],
vfs.num_of_reads, vfs.num_of_writes, vfs.io_stall_read_ms, vfs.io_stall_write_ms,
CAST(100. * vfs.io_stall_read_ms/(vfs.io_stall_read_ms + vfs.io_stall_write_ms) AS DECIMAL(10,1)) AS [IO Stall Reads Pct],
CAST(100. * vfs.io_stall_write_ms/(vfs.io_stall_write_ms + vfs.io_stall_read_ms) AS DECIMAL(10,1)) AS [IO Stall Writes Pct],
(vfs.num_of_reads + vfs.num_of_writes) AS [Writes + Reads], 
CAST(vfs.num_of_bytes_read/1048576.0 AS DECIMAL(10, 2)) AS [MB Read], 
CAST(vfs.num_of_bytes_written/1048576.0 AS DECIMAL(10, 2)) AS [MB Written],
CAST(100. * vfs.num_of_reads/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Reads Pct],
CAST(100. * vfs.num_of_writes/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Write Pct],
CAST(100. * vfs.num_of_bytes_read/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Read Bytes Pct],
CAST(100. * vfs.num_of_bytes_written/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Written Bytes Pct]
FROM sys.dm_io_virtual_file_stats(DB_ID(), NULL) AS vfs
INNER JOIN sys.database_files AS df WITH (NOLOCK)
ON vfs.[file_id]= df.[file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This lets you see the value of these new properties for the current database

// Clear plan cache for current database
// ALTER DATABASE SCOPED CONFIGURATION CLEAR PROCEDURE_CACHE;

// ALTER DATABASE SCOPED CONFIGURATION (Transact-SQL)
// https://msdn.microsoft.com/en-us/library/mt629158.aspx


// I/O Statistics by file for the current database  (Query 52) (IO Stats By File)-->
    <Query id="52" name="IO Stats By File" description="I/O Statistics by file for the current database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT DB_NAME(DB_ID()) AS [Database Name], df.name AS [Logical Name], vfs.[file_id], df.type_desc,
df.physical_name AS [Physical Name], CAST(vfs.size_on_disk_bytes/1048576.0 AS DECIMAL(10, 2)) AS [Size on Disk (MB)],
vfs.num_of_reads, vfs.num_of_writes, vfs.io_stall_read_ms, vfs.io_stall_write_ms,
CAST(100. * vfs.io_stall_read_ms/(vfs.io_stall_read_ms + vfs.io_stall_write_ms) AS DECIMAL(10,1)) AS [IO Stall Reads Pct],
CAST(100. * vfs.io_stall_write_ms/(vfs.io_stall_write_ms + vfs.io_stall_read_ms) AS DECIMAL(10,1)) AS [IO Stall Writes Pct],
(vfs.num_of_reads + vfs.num_of_writes) AS [Writes + Reads], 
CAST(vfs.num_of_bytes_read/1048576.0 AS DECIMAL(10, 2)) AS [MB Read], 
CAST(vfs.num_of_bytes_written/1048576.0 AS DECIMAL(10, 2)) AS [MB Written],
CAST(100. * vfs.num_of_reads/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Reads Pct],
CAST(100. * vfs.num_of_writes/(vfs.num_of_reads + vfs.num_of_writes) AS DECIMAL(10,1)) AS [# Write Pct],
CAST(100. * vfs.num_of_bytes_read/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Read Bytes Pct],
CAST(100. * vfs.num_of_bytes_written/(vfs.num_of_bytes_read + vfs.num_of_bytes_written) AS DECIMAL(10,1)) AS [Written Bytes Pct]
FROM sys.dm_io_virtual_file_stats(DB_ID(), NULL) AS vfs
INNER JOIN sys.database_files AS df WITH (NOLOCK)
ON vfs.[file_id]= df.[file_id] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most CPU resources on the instance


// Get I/O utilization by database (Query 19) (IO Usage By Database)-->
    <Query id="19" name="IO Usage By Database" description="Get I/O utilization by database" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
WITH Aggregate_IO_Statistics
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(SUM(num_of_bytes_read + num_of_bytes_written)/1048576 AS DECIMAL(12, 2)) AS io_in_mb
FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS [DM_IO_STATS]
GROUP BY database_id)
SELECT ROW_NUMBER() OVER(ORDER BY io_in_mb DESC) AS [I/O Rank], [Database Name], io_in_mb AS [Total I/O (MB)],
       CAST(io_in_mb/ SUM(io_in_mb) OVER() * 100.0 AS DECIMAL(5,2)) AS [I/O Percent]
FROM Aggregate_IO_Statistics
ORDER BY [I/O Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most CPU resources on the instance


// Get I/O utilization by database (Query 25) (IO Usage By Database)-->
    <Query id="25" name="IO Usage By Database" description="Get I/O utilization by database" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
WITH Aggregate_IO_Statistics
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(SUM(num_of_bytes_read + num_of_bytes_written)/1048576 AS DECIMAL(12, 2)) AS io_in_mb
FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS [DM_IO_STATS]
GROUP BY database_id)
SELECT ROW_NUMBER() OVER(ORDER BY io_in_mb DESC) AS [I/O Rank], [Database Name], io_in_mb AS [Total I/O (MB)],
       CAST(io_in_mb/ SUM(io_in_mb) OVER() * 100.0 AS DECIMAL(5,2)) AS [I/O Percent]
FROM Aggregate_IO_Statistics
ORDER BY [I/O Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most CPU resources on the instance


// Get I/O utilization by database (Query 21) (IO Usage By Database)-->
    <Query id="21" name="IO Usage By Database" description="Get I/O utilization by database" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
WITH Aggregate_IO_Statistics
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(SUM(num_of_bytes_read + num_of_bytes_written)/1048576 AS DECIMAL(12, 2)) AS io_in_mb
FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS [DM_IO_STATS]
GROUP BY database_id)
SELECT ROW_NUMBER() OVER(ORDER BY io_in_mb DESC) AS [I/O Rank], [Database Name], io_in_mb AS [Total I/O (MB)],
       CAST(io_in_mb/ SUM(io_in_mb) OVER() * 100.0 AS DECIMAL(5,2)) AS [I/O Percent]
FROM Aggregate_IO_Statistics
ORDER BY [I/O Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most CPU resources on the instance


// Get I/O utilization by database (Query 29) (IO Usage By Database)-->
    <Query id="29" name="IO Usage By Database" description="Get I/O utilization by database" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
WITH Aggregate_IO_Statistics
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(SUM(num_of_bytes_read + num_of_bytes_written)/1048576 AS DECIMAL(12, 2)) AS io_in_mb
FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS [DM_IO_STATS]
GROUP BY database_id)
SELECT ROW_NUMBER() OVER(ORDER BY io_in_mb DESC) AS [I/O Rank], [Database Name], io_in_mb AS [Total I/O (MB)],
       CAST(io_in_mb/ SUM(io_in_mb) OVER() * 100.0 AS DECIMAL(5,2)) AS [I/O Percent]
FROM Aggregate_IO_Statistics
ORDER BY [I/O Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most CPU resources on the instance


// Get I/O utilization by database (Query 34) (IO Usage By Database)-->
    <Query id="34" name="IO Usage By Database" description="Get I/O utilization by database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
WITH Aggregate_IO_Statistics
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(SUM(num_of_bytes_read + num_of_bytes_written)/1048576 AS DECIMAL(12, 2)) AS io_in_mb
FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS [DM_IO_STATS]
GROUP BY database_id)
SELECT ROW_NUMBER() OVER(ORDER BY io_in_mb DESC) AS [I/O Rank], [Database Name], io_in_mb AS [Total I/O (MB)],
       CAST(io_in_mb/ SUM(io_in_mb) OVER() * 100.0 AS DECIMAL(5,2)) AS [I/O Percent]
FROM Aggregate_IO_Statistics
ORDER BY [I/O Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most CPU resources on the instance


// Get I/O utilization by database (Query 34) (IO Usage By Database)-->
    <Query id="34" name="IO Usage By Database" description="Get I/O utilization by database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
WITH Aggregate_IO_Statistics
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(SUM(num_of_bytes_read + num_of_bytes_written)/1048576 AS DECIMAL(12, 2)) AS io_in_mb
FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS [DM_IO_STATS]
GROUP BY database_id)
SELECT ROW_NUMBER() OVER(ORDER BY io_in_mb DESC) AS [I/O Rank], [Database Name], io_in_mb AS [Total I/O (MB)],
       CAST(io_in_mb/ SUM(io_in_mb) OVER() * 100.0 AS DECIMAL(5,2)) AS [I/O Percent]
FROM Aggregate_IO_Statistics
ORDER BY [I/O Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most CPU resources on the instance


// Get I/O utilization by database (Query 34) (IO Usage By Database)-->
    <Query id="34" name="IO Usage By Database" description="Get I/O utilization by database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
WITH Aggregate_IO_Statistics
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(SUM(num_of_bytes_read + num_of_bytes_written)/1048576 AS DECIMAL(12, 2)) AS io_in_mb
FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS [DM_IO_STATS]
GROUP BY database_id)
SELECT ROW_NUMBER() OVER(ORDER BY io_in_mb DESC) AS [I/O Rank], [Database Name], io_in_mb AS [Total I/O (MB)],
       CAST(io_in_mb/ SUM(io_in_mb) OVER() * 100.0 AS DECIMAL(5,2)) AS [I/O Percent]
FROM Aggregate_IO_Statistics
ORDER BY [I/O Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Things to look at:
// Are data files and log files on different drives?
// Is everything on the C: drive?
// Is TempDB on dedicated drives?
// Is there only one TempDB data file?
// Are all of the TempDB data files the same size?
// Are there multiple data files for user databases?
// Is percent growth enabled for any files (which is bad)?


// Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs (Query 12) (IO Warnings)-->
    <Query id="12" name="IO Warnings" description="Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
CREATE TABLE #IOWarningResults(LogDate datetime, ProcessInfo sysname, LogText nvarchar(1000));

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 0, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 1, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 2, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 3, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 4, 1, N'taking longer than 15 seconds';

SELECT LogDate, ProcessInfo, LogText
FROM #IOWarningResults
ORDER BY LogDate DESC;

DROP TABLE #IOWarningResults; 
]]></Query>
    <!--//////
   
//Shows you the total and free space on the LUNs where you have database files


// Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs (Query 18) (IO Warnings)-->
    <Query id="18" name="IO Warnings" description="Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
CREATE TABLE #IOWarningResults(LogDate datetime, ProcessInfo sysname, LogText nvarchar(1000));

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 0, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 1, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 2, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 3, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 4, 1, N'taking longer than 15 seconds';

SELECT LogDate, ProcessInfo, LogText
FROM #IOWarningResults
ORDER BY LogDate DESC;

DROP TABLE #IOWarningResults;
]]></Query>
    <!--//////
   
// Things to look at:
// Are data files and log files on different drives?
// Is everything on the C: drive?
// Is TempDB on dedicated drives?
// Is there only one TempDB data file?
// Are all of the TempDB data files the same size?
// Are there multiple data files for user databases?
// Is percent growth enabled for any files (which is bad)?


// Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs (Query 14) (IO Warnings)-->
    <Query id="14" name="IO Warnings" description="Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
CREATE TABLE #IOWarningResults(LogDate datetime, ProcessInfo sysname, LogText nvarchar(1000));

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 0, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 1, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 2, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 3, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 4, 1, N'taking longer than 15 seconds';

SELECT LogDate, ProcessInfo, LogText
FROM #IOWarningResults
ORDER BY LogDate DESC;

DROP TABLE #IOWarningResults;
]]></Query>
    <!--//////
   
// Helps determine which database files on the entire instance have the most I/O bottlenecks
// This can help you decide whether certain LUNs are overloaded and whether you might
// want to move some files to a different location or perhaps improve your I/O performance
// These latency numbers include all file activity against each SQL Server 
// database file since SQL Server was last started


// Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs (Query 24) (IO Warnings)-->
    <Query id="24" name="IO Warnings" description="Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
CREATE TABLE #IOWarningResults(LogDate datetime, ProcessInfo sysname, LogText nvarchar(1000));

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 0, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 1, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 2, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 3, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 4, 1, N'taking longer than 15 seconds';

SELECT LogDate, ProcessInfo, LogText
FROM #IOWarningResults
ORDER BY LogDate DESC;

DROP TABLE #IOWarningResults;
]]></Query>
    <!--//////
   
// Helps determine which database files on the entire instance have the most I/O bottlenecks
// This can help you decide whether certain LUNs are overloaded and whether you might
// want to move some files to a different location or perhaps improve your I/O performance
// These latency numbers include all file activity against each SQL Server 
// database file since SQL Server was last started


// Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs (Query 29) (IO Warnings)-->
    <Query id="29" name="IO Warnings" description="Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
CREATE TABLE #IOWarningResults(LogDate datetime, ProcessInfo sysname, LogText nvarchar(1000));

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 0, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 1, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 2, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 3, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 4, 1, N'taking longer than 15 seconds';

SELECT LogDate, ProcessInfo, LogText
FROM #IOWarningResults
ORDER BY LogDate DESC;

DROP TABLE #IOWarningResults;
]]></Query>
    <!--//////
   
// Helps determine which database files on the entire instance have the most I/O bottlenecks
// This can help you decide whether certain LUNs are overloaded and whether you might
// want to move some files to a different location or perhaps improve your I/O performance
// These latency numbers include all file activity against each SQL Server 
// database file since SQL Server was last started


// Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs (Query 29) (IO Warnings)-->
    <Query id="29" name="IO Warnings" description="Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
CREATE TABLE #IOWarningResults(LogDate datetime, ProcessInfo sysname, LogText nvarchar(1000));

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 0, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 1, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 2, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 3, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 4, 1, N'taking longer than 15 seconds';

SELECT LogDate, ProcessInfo, LogText
FROM #IOWarningResults
ORDER BY LogDate DESC;

DROP TABLE #IOWarningResults;
]]></Query>
    <!--//////
   
// Helps determine which database files on the entire instance have the most I/O bottlenecks
// This can help you decide whether certain LUNs are overloaded and whether you might
// want to move some files to a different location or perhaps improve your I/O performance
// These latency numbers include all file activity against each SQL Server 
// database file since SQL Server was last started


// Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs (Query 29) (IO Warnings)-->
    <Query id="29" name="IO Warnings" description="Look for I/O requests taking longer than 15 seconds in the five most recent SQL Server Error Logs" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
CREATE TABLE #IOWarningResults(LogDate datetime, ProcessInfo sysname, LogText nvarchar(1000));

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 0, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 1, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 2, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 3, 1, N'taking longer than 15 seconds';

	INSERT INTO #IOWarningResults 
	EXEC xp_readerrorlog 4, 1, N'taking longer than 15 seconds';

SELECT LogDate, ProcessInfo, LogText
FROM #IOWarningResults
ORDER BY LogDate DESC;

DROP TABLE #IOWarningResults;
]]></Query>
    <!--//////
   
// Show which indexes in the current database are most active for Writes


// Get lock waits for current database (Query 50) (Lock Waits)-->
    <Query id="50" name="Lock Waits" description="Get lock waits for current database" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT o.name AS [table_name], i.name AS [index_name], ios.index_id, ios.partition_number,
		SUM(ios.row_lock_wait_count) AS [total_row_lock_waits], 
		SUM(ios.row_lock_wait_in_ms) AS [total_row_lock_wait_in_ms],
		SUM(ios.page_lock_wait_count) AS [total_page_lock_waits],
		SUM(ios.page_lock_wait_in_ms) AS [total_page_lock_wait_in_ms],
		SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) AS [total_lock_wait_in_ms]
FROM sys.dm_db_index_operational_stats(DB_ID(), NULL, NULL, NULL) AS ios
INNER JOIN sys.objects AS o WITH (NOLOCK)
ON ios.[object_id] = o.[object_id]
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ios.[object_id] = i.[object_id] 
AND ios.index_id = i.index_id
WHERE o.[object_id] > 100
GROUP BY o.name, i.name, ios.index_id, ios.partition_number
HAVING SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) > 0
ORDER BY total_lock_wait_in_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Show which indexes in the current database are most active for Writes


// Get lock waits for current database (Query 63) (Lock Waits)-->
    <Query id="63" name="Lock Waits" description="Get lock waits for current database" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT o.name AS [table_name], i.name AS [index_name], ios.index_id, ios.partition_number,
		SUM(ios.row_lock_wait_count) AS [total_row_lock_waits], 
		SUM(ios.row_lock_wait_in_ms) AS [total_row_lock_wait_in_ms],
		SUM(ios.page_lock_wait_count) AS [total_page_lock_waits],
		SUM(ios.page_lock_wait_in_ms) AS [total_page_lock_wait_in_ms],
		SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) AS [total_lock_wait_in_ms]
FROM sys.dm_db_index_operational_stats(DB_ID(), NULL, NULL, NULL) AS ios
INNER JOIN sys.objects AS o WITH (NOLOCK)
ON ios.[object_id] = o.[object_id]
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ios.[object_id] = i.[object_id] 
AND ios.index_id = i.index_id
WHERE o.[object_id] > 100
GROUP BY o.name, i.name, ios.index_id, ios.partition_number
HAVING SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) > 0
ORDER BY total_lock_wait_in_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Show which indexes in the current database are most active for Writes


// Get lock waits for current database (Query 58) (Lock Waits)-->
    <Query id="58" name="Lock Waits" description="Get lock waits for current database" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT o.name AS [table_name], i.name AS [index_name], ios.index_id, ios.partition_number,
		SUM(ios.row_lock_wait_count) AS [total_row_lock_waits], 
		SUM(ios.row_lock_wait_in_ms) AS [total_row_lock_wait_in_ms],
		SUM(ios.page_lock_wait_count) AS [total_page_lock_waits],
		SUM(ios.page_lock_wait_in_ms) AS [total_page_lock_wait_in_ms],
		SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) AS [total_lock_wait_in_ms]
FROM sys.dm_db_index_operational_stats(DB_ID(), NULL, NULL, NULL) AS ios
INNER JOIN sys.objects AS o WITH (NOLOCK)
ON ios.[object_id] = o.[object_id]
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ios.[object_id] = i.[object_id] 
AND ios.index_id = i.index_id
WHERE o.[object_id] > 100
GROUP BY o.name, i.name, ios.index_id, ios.partition_number
HAVING SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) > 0
ORDER BY total_lock_wait_in_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Show which indexes in the current database are most active for Writes


// Get lock waits for current database (Query 64) (Lock Waits)-->
    <Query id="64" name="Lock Waits" description="Get lock waits for current database" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT o.name AS [table_name], i.name AS [index_name], ios.index_id, ios.partition_number,
		SUM(ios.row_lock_wait_count) AS [total_row_lock_waits], 
		SUM(ios.row_lock_wait_in_ms) AS [total_row_lock_wait_in_ms],
		SUM(ios.page_lock_wait_count) AS [total_page_lock_waits],
		SUM(ios.page_lock_wait_in_ms) AS [total_page_lock_wait_in_ms],
		SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) AS [total_lock_wait_in_ms]
FROM sys.dm_db_index_operational_stats(DB_ID(), NULL, NULL, NULL) AS ios
INNER JOIN sys.objects AS o WITH (NOLOCK)
ON ios.[object_id] = o.[object_id]
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ios.[object_id] = i.[object_id] 
AND ios.index_id = i.index_id
WHERE o.[object_id] > 100
GROUP BY o.name, i.name, ios.index_id, ios.partition_number
HAVING SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) > 0
ORDER BY total_lock_wait_in_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you some index usage statistics for in-memory OLTP
// Returns no data if you are not using in-memory OLTP

// Guidelines for Using Indexes on Memory-Optimized Tables
// https://msdn.microsoft.com/en-us/library/dn133166.aspx


// Get lock waits for current database (Query 71) (Lock Waits)-->
    <Query id="71" name="Lock Waits" description="Get lock waits for current database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT o.name AS [table_name], i.name AS [index_name], ios.index_id, ios.partition_number,
		SUM(ios.row_lock_wait_count) AS [total_row_lock_waits], 
		SUM(ios.row_lock_wait_in_ms) AS [total_row_lock_wait_in_ms],
		SUM(ios.page_lock_wait_count) AS [total_page_lock_waits],
		SUM(ios.page_lock_wait_in_ms) AS [total_page_lock_wait_in_ms],
		SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) AS [total_lock_wait_in_ms]
FROM sys.dm_db_index_operational_stats(DB_ID(), NULL, NULL, NULL) AS ios
INNER JOIN sys.objects AS o WITH (NOLOCK)
ON ios.[object_id] = o.[object_id]
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ios.[object_id] = i.[object_id] 
AND ios.index_id = i.index_id
WHERE o.[object_id] > 100
GROUP BY o.name, i.name, ios.index_id, ios.partition_number
HAVING SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) > 0
ORDER BY total_lock_wait_in_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// sys.dm_db_column_store_row_group_physical_stats (Transact-SQL)
// https://msdn.microsoft.com/en-us/library/dn832030.aspx


// Get lock waits for current database (Query 74) (Lock Waits)-->
    <Query id="74" name="Lock Waits" description="Get lock waits for current database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT o.name AS [table_name], i.name AS [index_name], ios.index_id, ios.partition_number,
		SUM(ios.row_lock_wait_count) AS [total_row_lock_waits], 
		SUM(ios.row_lock_wait_in_ms) AS [total_row_lock_wait_in_ms],
		SUM(ios.page_lock_wait_count) AS [total_page_lock_waits],
		SUM(ios.page_lock_wait_in_ms) AS [total_page_lock_wait_in_ms],
		SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) AS [total_lock_wait_in_ms]
FROM sys.dm_db_index_operational_stats(DB_ID(), NULL, NULL, NULL) AS ios
INNER JOIN sys.objects AS o WITH (NOLOCK)
ON ios.[object_id] = o.[object_id]
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ios.[object_id] = i.[object_id] 
AND ios.index_id = i.index_id
WHERE o.[object_id] > 100
GROUP BY o.name, i.name, ios.index_id, ios.partition_number
HAVING SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) > 0
ORDER BY total_lock_wait_in_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// sys.dm_db_column_store_row_group_physical_stats (Transact-SQL)
// https://msdn.microsoft.com/en-us/library/dn832030.aspx


// Get lock waits for current database (Query 74) (Lock Waits)-->
    <Query id="74" name="Lock Waits" description="Get lock waits for current database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT o.name AS [table_name], i.name AS [index_name], ios.index_id, ios.partition_number,
		SUM(ios.row_lock_wait_count) AS [total_row_lock_waits], 
		SUM(ios.row_lock_wait_in_ms) AS [total_row_lock_wait_in_ms],
		SUM(ios.page_lock_wait_count) AS [total_page_lock_waits],
		SUM(ios.page_lock_wait_in_ms) AS [total_page_lock_wait_in_ms],
		SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) AS [total_lock_wait_in_ms]
FROM sys.dm_db_index_operational_stats(DB_ID(), NULL, NULL, NULL) AS ios
INNER JOIN sys.objects AS o WITH (NOLOCK)
ON ios.[object_id] = o.[object_id]
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON ios.[object_id] = i.[object_id] 
AND ios.index_id = i.index_id
WHERE o.[object_id] > 100
GROUP BY o.name, i.name, ios.index_id, ios.partition_number
HAVING SUM(ios.page_lock_wait_in_ms)+ SUM(row_lock_wait_in_ms) > 0
ORDER BY total_lock_wait_in_ms DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at how large and how full the files are and where they are located
// Make sure the transaction log is not full!!


// Log space usage for current database  (Query 49) (Log Space Usage)-->
    <Query id="49" name="Log Space Usage" description="Log space usage for current database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT DB_NAME(lsu.database_id) AS [Database Name], db.recovery_model_desc AS [Recovery Model],
		CAST(lsu.total_log_size_in_bytes/1048576.0 AS DECIMAL(10, 2)) AS [Total Log Space (MB)],
		CAST(lsu.used_log_space_in_bytes/1048576.0 AS DECIMAL(10, 2)) AS [Used Log Space (MB)], 
		CAST(lsu.used_log_space_in_percent AS DECIMAL(10, 2)) AS [Used Log Space %],
		CAST(lsu.log_space_in_bytes_since_last_backup/1048576.0 AS DECIMAL(10, 2)) AS [Used Log Space Since Last Backup (MB)],
		db.log_reuse_wait_desc		 
FROM sys.dm_db_log_space_usage AS lsu WITH (NOLOCK)
INNER JOIN sys.databases AS db WITH (NOLOCK)
ON lsu.database_id = db.database_id
OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at how large and how full the files are and where they are located
// Make sure the transaction log is not full!!

// is_autogrow_all_files is new for SQL Server 2016. Equivalent to TF 1117 for user databases

// SQL Server 2016: Changes in default behavior for autogrow and allocations for tempdb and user databases
// http://bit.ly/2evRZSR


// Log space usage for current database  (Query 50) (Log Space Usage)-->
    <Query id="50" name="Log Space Usage" description="Log space usage for current database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT DB_NAME(lsu.database_id) AS [Database Name], db.recovery_model_desc AS [Recovery Model],
		CAST(lsu.total_log_size_in_bytes/1048576.0 AS DECIMAL(10, 2)) AS [Total Log Space (MB)],
		CAST(lsu.used_log_space_in_bytes/1048576.0 AS DECIMAL(10, 2)) AS [Used Log Space (MB)], 
		CAST(lsu.used_log_space_in_percent AS DECIMAL(10, 2)) AS [Used Log Space %],
		CAST(lsu.log_space_in_bytes_since_last_backup/1048576.0 AS DECIMAL(10, 2)) AS [Used Log Space Since Last Backup (MB)],
		db.log_reuse_wait_desc		 
FROM sys.dm_db_log_space_usage AS lsu WITH (NOLOCK)
INNER JOIN sys.databases AS db WITH (NOLOCK)
ON lsu.database_id = db.database_id
OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at how large and how full the files are and where they are located
// Make sure the transaction log is not full!!

// is_autogrow_all_files is new for SQL Server 2016. Equivalent to TF 1117 for user databases

// SQL Server 2016: Changes in default behavior for autogrow and allocations for tempdb and user databases
// http://bit.ly/2evRZSR


// Log space usage for current database  (Query 50) (Log Space Usage)-->
    <Query id="50" name="Log Space Usage" description="Log space usage for current database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT DB_NAME(lsu.database_id) AS [Database Name], db.recovery_model_desc AS [Recovery Model],
		CAST(lsu.total_log_size_in_bytes/1048576.0 AS DECIMAL(10, 2)) AS [Total Log Space (MB)],
		CAST(lsu.used_log_space_in_bytes/1048576.0 AS DECIMAL(10, 2)) AS [Used Log Space (MB)], 
		CAST(lsu.used_log_space_in_percent AS DECIMAL(10, 2)) AS [Used Log Space %],
		CAST(lsu.log_space_in_bytes_since_last_backup/1048576.0 AS DECIMAL(10, 2)) AS [Used Log Space Since Last Backup (MB)],
		db.log_reuse_wait_desc		 
FROM sys.dm_db_log_space_usage AS lsu WITH (NOLOCK)
INNER JOIN sys.databases AS db WITH (NOLOCK)
ON lsu.database_id = db.database_id
OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Memory Grants Pending above zero for a sustained period is a very strong indicator of memory pressure


// Memory Clerk Usage for instance  (Query 29) (Memory Clerk Usage)
// Look for high value for CACHESTORE_SQLCP (Ad-hoc query plans)-->
    <Query id="29" name="Memory Clerk Usage" description="Memory Clerk Usage for instance" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT TOP(10) [type] AS [Memory Clerk Type], SUM(single_pages_kb)/1024 AS [SPA Memory Usage (MB)] 
FROM sys.dm_os_memory_clerks WITH (NOLOCK)
GROUP BY [type]  
ORDER BY SUM(single_pages_kb) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Memory Grants Pending above zero for a sustained period is a very strong indicator of memory pressure


// Memory Clerk Usage for instance  (Query 38) (Memory Clerk Usage)
// Look for high value for CACHESTORE_SQLCP (Ad-hoc query plans)-->
    <Query id="38" name="Memory Clerk Usage" description="Memory Clerk Usage for instance" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT TOP(10) [type] AS [Memory Clerk Type], SUM(single_pages_kb)/1024 AS [SPA Memory Usage (MB)] 
FROM sys.dm_os_memory_clerks WITH (NOLOCK)
GROUP BY [type]  
ORDER BY SUM(single_pages_kb) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Memory Grants Pending above zero for a sustained period is a very strong indicator of memory pressure


// Memory Clerk Usage for instance  (Query 34) (Memory Clerk Usage)
// Look for high value for CACHESTORE_SQLCP (Ad-hoc query plans)-->
    <Query id="34" name="Memory Clerk Usage" description="Memory Clerk Usage for instance" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT TOP(10) [type] AS [Memory Clerk Type], SUM(single_pages_kb)/1024 AS [SPA Memory Usage (MB)] 
FROM sys.dm_os_memory_clerks WITH (NOLOCK)
GROUP BY [type]  
ORDER BY SUM(single_pages_kb) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Run multiple times, and run periodically if you suspect you are under memory pressure
// Memory Grants Pending above zero for a sustained period is a very strong indicator of internal memory pressure


// Memory Clerk Usage for instance  (Query 39) (Memory Clerk Usage)
// Look for high value for CACHESTORE_SQLCP (Ad-hoc query plans)-->
    <Query id="39" name="Memory Clerk Usage" description="Memory Clerk Usage for instance" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT TOP(10) mc.[type] AS [Memory Clerk Type], 
       CAST((SUM(mc.pages_kb)/1024.0) AS DECIMAL (15,2)) AS [Memory Usage (MB)] 
FROM sys.dm_os_memory_clerks AS mc WITH (NOLOCK)
GROUP BY mc.[type]  
ORDER BY SUM(mc.pages_kb) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Run multiple times, and run periodically if you suspect you are under memory pressure
// Memory Grants Pending above zero for a sustained period is a very strong indicator of internal memory pressure


// Memory Clerk Usage for instance  (Query 44) (Memory Clerk Usage)
// Look for high value for CACHESTORE_SQLCP (Ad-hoc query plans)-->
    <Query id="44" name="Memory Clerk Usage" description="Memory Clerk Usage for instance" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT TOP(10) mc.[type] AS [Memory Clerk Type], 
       CAST((SUM(mc.pages_kb)/1024.0) AS DECIMAL (15,2)) AS [Memory Usage (MB)] 
FROM sys.dm_os_memory_clerks AS mc WITH (NOLOCK)
GROUP BY mc.[type]  
ORDER BY SUM(mc.pages_kb) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Run multiple times, and run periodically if you suspect you are under memory pressure
// Memory Grants Pending above zero for a sustained period is a very strong indicator of internal memory pressure


// Memory Clerk Usage for instance  (Query 44) (Memory Clerk Usage)
// Look for high value for CACHESTORE_SQLCP (Ad-hoc query plans)-->
    <Query id="44" name="Memory Clerk Usage" description="Memory Clerk Usage for instance" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT TOP(10) mc.[type] AS [Memory Clerk Type], 
       CAST((SUM(mc.pages_kb)/1024.0) AS DECIMAL (15,2)) AS [Memory Usage (MB)] 
FROM sys.dm_os_memory_clerks AS mc WITH (NOLOCK)
GROUP BY mc.[type]  
ORDER BY SUM(mc.pages_kb) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Run multiple times, and run periodically if you suspect you are under memory pressure
// Memory Grants Pending above zero for a sustained period is a very strong indicator of internal memory pressure


// Memory Clerk Usage for instance  (Query 44) (Memory Clerk Usage)
// Look for high value for CACHESTORE_SQLCP (Ad-hoc query plans)-->
    <Query id="44" name="Memory Clerk Usage" description="Memory Clerk Usage for instance" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT TOP(10) mc.[type] AS [Memory Clerk Type], 
       CAST((SUM(mc.pages_kb)/1024.0) AS DECIMAL (15,2)) AS [Memory Usage (MB)] 
FROM sys.dm_os_memory_clerks AS mc WITH (NOLOCK)
GROUP BY mc.[type]  
ORDER BY SUM(mc.pages_kb) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Focus on these settings:
// backup compression default (should be 1 in most cases)
// clr enabled (only enable if it is needed)
// cost threshold for parallelism (depends on your workload)
// lightweight pooling (should be zero)
// max degree of parallelism (depends on your workload)
// max server memory (MB) (set to an appropriate value, not the default)
// optimize for ad hoc workloads (should be 1)
// priority boost (should be zero)
// remote admin connections (should be 1)




// Get information on location, time and size of any memory dumps from SQL Server (SQL Server 2008 R2 SP1 or greater)  (Query 15) (Memory Dump Info)-->
    <Query id="15" name="Memory Dump Info" description="Get information on location, time and size of any memory dumps from SQL Server (SQL Server 2008 R2 SP1 or greater)" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT [filename], creation_time, size_in_bytes/1048576.0 AS [Size (MB)]
FROM sys.dm_server_memory_dumps WITH (NOLOCK) 
ORDER BY creation_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you the model number and rated clock speed of your processor(s)
// Your processors may be running at less than the rated clock speed due
// to the Windows Power Plan or hardware power management

// You can use CPU-Z to get your actual CPU core speed and a lot of other useful information
// http://www.cpuid.com/softwares/cpu-z.html

// You can learn more about processor selection for SQL Server by following this link
// http://www.sqlskills.com/blogs/glenn/processor-selection-for-sql-server/



// Get information on location, time and size of any memory dumps from SQL Server  (Query 19) (Memory Dump Info)-->
    <Query id="19" name="Memory Dump Info" description="Get information on location, time and size of any memory dumps from SQL Server" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT [filename], creation_time, size_in_bytes/1048576.0 AS [Size (MB)]
FROM sys.dm_server_memory_dumps WITH (NOLOCK) 
ORDER BY creation_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You will see no results if BPE is not enabled or if there is no BPE usage


// Get information on location, time and size of any memory dumps from SQL Server  (Query 23) (Memory Dump Info)-->
    <Query id="23" name="Memory Dump Info" description="Get information on location, time and size of any memory dumps from SQL Server" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT [filename], creation_time, size_in_bytes/1048576.0 AS [Size (MB)]
FROM sys.dm_server_memory_dumps WITH (NOLOCK) 
ORDER BY creation_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You will see no results if BPE is not enabled or if there is no BPE usage


// Get information on location, time and size of any memory dumps from SQL Server  (Query 23) (Memory Dump Info)-->
    <Query id="23" name="Memory Dump Info" description="Get information on location, time and size of any memory dumps from SQL Server" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT [filename], creation_time, size_in_bytes/1048576.0 AS [Size (MB)]
FROM sys.dm_server_memory_dumps WITH (NOLOCK) 
ORDER BY creation_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You will see no results if BPE is not enabled or if there is no BPE usage


// Get information on location, time and size of any memory dumps from SQL Server  (Query 23) (Memory Dump Info)-->
    <Query id="23" name="Memory Dump Info" description="Get information on location, time and size of any memory dumps from SQL Server" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT [filename], creation_time, size_in_bytes/1048576.0 AS [Size (MB)]
FROM sys.dm_server_memory_dumps WITH (NOLOCK) 
ORDER BY creation_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// PLE is a good measurement of memory pressure.
// Higher PLE is better. Watch the trend over time, not the absolute value.
// This will only return one row for non-NUMA systems.

// Page Life Expectancy isnt what you think
// http://www.sqlskills.com/blogs/paul/page-life-expectancy-isnt-what-you-think/



// Memory Grants Pending value for current instance (Query 28) (Memory Grants Pending)-->
    <Query id="28" name="Memory Grants Pending" description="Memory Grants Pending value for current instance" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], cntr_value AS [Memory Grants Pending]                                                                                                       
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Memory Manager%' -- Handles named instances
AND counter_name = N'Memory Grants Pending' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// PLE is a good measurement of memory pressure.
// Higher PLE is better. Watch the trend over time, not the absolute value.
// This will only return one row for non-NUMA systems.

// Page Life Expectancy isnt what you think
// http://www.sqlskills.com/blogs/paul/page-life-expectancy-isnt-what-you-think/



// Memory Grants Pending value for current instance  (Query 37) (Memory Grants Pending)-->
    <Query id="37" name="Memory Grants Pending" description="Memory Grants Pending value for current instance" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], cntr_value AS [Memory Grants Pending]                                                                                                       
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Memory Manager%' -- Handles named instances
AND counter_name = N'Memory Grants Pending' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// PLE is a good measurement of memory pressure.
// Higher PLE is better. Watch the trend over time, not the absolute value.
// This will only return one row for non-NUMA systems.

// Page Life Expectancy isnt what you think
// http://www.sqlskills.com/blogs/paul/page-life-expectancy-isnt-what-you-think/



// Memory Grants Pending value for current instance  (Query 33) (Memory Grants Pending)-->
    <Query id="33" name="Memory Grants Pending" description="Memory Grants Pending value for current instance" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], cntr_value AS [Memory Grants Pending]                                                                                                       
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Memory Manager%' -- Handles named instances
AND counter_name = N'Memory Grants Pending' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// PLE is a good measurement of internal memory pressure
// Higher PLE is better. Watch the trend over time, not the absolute value
// This will only return one row for non-NUMA systems

// Page Life Expectancy isnt what you think
// http://www.sqlskills.com/blogs/paul/page-life-expectancy-isnt-what-you-think/


// Memory Grants Pending value for current instance  (Query 38) (Memory Grants Pending)-->
    <Query id="38" name="Memory Grants Pending" description="Memory Grants Pending value for current instance" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], cntr_value AS [Memory Grants Pending]                                                                                                       
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Memory Manager%' -- Handles named instances
AND counter_name = N'Memory Grants Pending' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// PLE is a good measurement of internal memory pressure
// Higher PLE is better. Watch the trend over time, not the absolute value
// This will only return one row for non-NUMA systems

// Page Life Expectancy isnt what you think
// http://www.sqlskills.com/blogs/paul/page-life-expectancy-isnt-what-you-think/


// Memory Grants Pending value for current instance  (Query 43) (Memory Grants Pending)-->
    <Query id="43" name="Memory Grants Pending" description="Memory Grants Pending value for current instance" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], cntr_value AS [Memory Grants Pending]                                                                                                       
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Memory Manager%' -- Handles named instances
AND counter_name = N'Memory Grants Pending' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// PLE is a good measurement of internal memory pressure
// Higher PLE is better. Watch the trend over time, not the absolute value
// This will only return one row for non-NUMA systems

// Page Life Expectancy isnt what you think
// http://www.sqlskills.com/blogs/paul/page-life-expectancy-isnt-what-you-think/


// Memory Grants Pending value for current instance  (Query 43) (Memory Grants Pending)-->
    <Query id="43" name="Memory Grants Pending" description="Memory Grants Pending value for current instance" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], cntr_value AS [Memory Grants Pending]                                                                                                       
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Memory Manager%' -- Handles named instances
AND counter_name = N'Memory Grants Pending' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// PLE is a good measurement of internal memory pressure
// Higher PLE is better. Watch the trend over time, not the absolute value
// This will only return one row for non-NUMA systems

// Page Life Expectancy isnt what you think
// http://www.sqlskills.com/blogs/paul/page-life-expectancy-isnt-what-you-think/


// Memory Grants Pending value for current instance  (Query 43) (Memory Grants Pending)-->
    <Query id="43" name="Memory Grants Pending" description="Memory Grants Pending value for current instance" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], cntr_value AS [Memory Grants Pending]                                                                                                       
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Memory Manager%' -- Handles named instances
AND counter_name = N'Memory Grants Pending' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at index advantage, last user seek time, number of user seeks to help determine source and importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!


// Find missing index warnings for cached plans in the current database  (Query 42) (Missing Index Warnings)
// Note: This query could take some time on a busy instance-->
    <Query id="42" name="Missing Index Warnings" description="Find missing index warnings for cached plans in the current database" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db" longTextColumns="query_plan"><![CDATA[
SELECT TOP(25) OBJECT_NAME(objectid) AS [ObjectName], 
               query_plan, cp.objtype, cp.usecounts
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_query_plan(cp.plan_handle) AS qp
WHERE CAST(query_plan AS NVARCHAR(MAX)) LIKE N'%MissingIndex%'
AND dbid = DB_ID()
ORDER BY cp.usecounts DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at index advantage, last user seek time, number of user seeks to help determine source and importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!


// Find missing index warnings for cached plans in the current database  (Query 53) (Missing Index Warnings)
// Note: This query could take some time on a busy instance-->
    <Query id="53" name="Missing Index Warnings" description="Find missing index warnings for cached plans in the current database" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db" longTextColumns="query_plan"><![CDATA[
SELECT TOP(25) OBJECT_NAME(objectid) AS [ObjectName], 
               query_plan, cp.objtype, cp.usecounts
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_query_plan(cp.plan_handle) AS qp
WHERE CAST(query_plan AS NVARCHAR(MAX)) LIKE N'%MissingIndex%'
AND dbid = DB_ID()
ORDER BY cp.usecounts DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at index advantage, last user seek time, number of user seeks to help determine source and importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!


// Find missing index warnings for cached plans in the current database  (Query 49) (Missing Index Warnings)
// Note: This query could take some time on a busy instance-->
    <Query id="49" name="Missing Index Warnings" description="Find missing index warnings for cached plans in the current database" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db" longTextColumns="query_plan"><![CDATA[
SELECT TOP(25) OBJECT_NAME(objectid) AS [ObjectName], 
               query_plan, cp.objtype, cp.usecounts
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_query_plan(cp.plan_handle) AS qp
WHERE CAST(query_plan AS NVARCHAR(MAX)) LIKE N'%MissingIndex%'
AND dbid = DB_ID()
ORDER BY cp.usecounts DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at index advantage, last user seek time, number of user seeks to help determine source and importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!


// Find missing index warnings for cached plans in the current database  (Query 55) (Missing Index Warnings)
// Note: This query could take some time on a busy instance-->
    <Query id="55" name="Missing Index Warnings" description="Find missing index warnings for cached plans in the current database" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db" longTextColumns="query_plan"><![CDATA[
SELECT TOP(25) OBJECT_NAME(objectid) AS [ObjectName], 
               cp.objtype, cp.usecounts, cp.size_in_bytes, query_plan
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_query_plan(cp.plan_handle) AS qp
WHERE CAST(query_plan AS NVARCHAR(MAX)) LIKE N'%MissingIndex%'
AND dbid = DB_ID()
ORDER BY cp.usecounts DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at index advantage, last user seek time, number of user seeks to help determine source and importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!


// Find missing index warnings for cached plans in the current database  (Query 61) (Missing Index Warnings)
// Note: This query could take some time on a busy instance-->
    <Query id="61" name="Missing Index Warnings" description="Find missing index warnings for cached plans in the current database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db" longTextColumns="query_plan"><![CDATA[
SELECT TOP(25) OBJECT_NAME(objectid) AS [ObjectName], 
               cp.objtype, cp.usecounts, cp.size_in_bytes, query_plan
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_query_plan(cp.plan_handle) AS qp
WHERE CAST(query_plan AS NVARCHAR(MAX)) LIKE N'%MissingIndex%'
AND dbid = DB_ID()
ORDER BY cp.usecounts DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at index advantage, last user seek time, number of user seeks to help determine source and importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!


// Find missing index warnings for cached plans in the current database  (Query 63) (Missing Index Warnings)
// Note: This query could take some time on a busy instance-->
    <Query id="63" name="Missing Index Warnings" description="Find missing index warnings for cached plans in the current database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db" longTextColumns="query_plan"><![CDATA[
SELECT TOP(25) OBJECT_NAME(objectid) AS [ObjectName], 
               cp.objtype, cp.usecounts, cp.size_in_bytes, query_plan
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_query_plan(cp.plan_handle) AS qp
WHERE CAST(query_plan AS NVARCHAR(MAX)) LIKE N'%MissingIndex%'
AND dbid = DB_ID()
ORDER BY cp.usecounts DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at index advantage, last user seek time, number of user seeks to help determine source and importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!


// Find missing index warnings for cached plans in the current database  (Query 63) (Missing Index Warnings)
// Note: This query could take some time on a busy instance-->
    <Query id="63" name="Missing Index Warnings" description="Find missing index warnings for cached plans in the current database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db" longTextColumns="query_plan"><![CDATA[
SELECT TOP(25) OBJECT_NAME(objectid) AS [ObjectName], 
               cp.objtype, cp.usecounts, cp.size_in_bytes, query_plan
FROM sys.dm_exec_cached_plans AS cp WITH (NOLOCK)
CROSS APPLY sys.dm_exec_query_plan(cp.plan_handle) AS qp
WHERE CAST(query_plan AS NVARCHAR(MAX)) LIKE N'%MissingIndex%'
AND dbid = DB_ID()
ORDER BY cp.usecounts DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look for indexes with high numbers of writes and zero or very low numbers of reads
// Consider your complete workload, and how long your instance has been running
// Investigate further before dropping an index!


// Missing Indexes for current database by Index Advantage  (Query 41) (Missing Indexes)-->
    <Query id="41" name="Missing Indexes" description="Missing Indexes for current database by Index Advantage" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT DISTINCT CONVERT(decimal(18,2), user_seeks * avg_total_user_cost * (avg_user_impact * 0.01)) AS [index_advantage], 
migs.last_user_seek, mid.[statement] AS [Database.Schema.Table],
mid.equality_columns, mid.inequality_columns, mid.included_columns,
migs.unique_compiles, migs.user_seeks, migs.avg_total_user_cost, migs.avg_user_impact,
OBJECT_NAME(mid.[object_id]) AS [Table Name], p.rows AS [Table Rows]
FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK)
ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)
ON mig.index_handle = mid.index_handle
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON p.[object_id] = mid.[object_id]
WHERE mid.database_id = DB_ID() 
ORDER BY index_advantage DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look for indexes with high numbers of writes and zero or very low numbers of reads
// Consider your complete workload, and how long your instance has been running
// Investigate further before dropping an index!


// Missing Indexes for current database by Index Advantage  (Query 52) (Missing Indexes)-->
    <Query id="52" name="Missing Indexes" description="Missing Indexes for current database by Index Advantage" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT DISTINCT CONVERT(decimal(18,2), user_seeks * avg_total_user_cost * (avg_user_impact * 0.01)) AS [index_advantage], 
migs.last_user_seek, mid.[statement] AS [Database.Schema.Table],
mid.equality_columns, mid.inequality_columns, mid.included_columns,
migs.unique_compiles, migs.user_seeks, migs.avg_total_user_cost, migs.avg_user_impact,
OBJECT_NAME(mid.[object_id]) AS [Table Name], p.rows AS [Table Rows]
FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK)
ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)
ON mig.index_handle = mid.index_handle
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON p.[object_id] = mid.[object_id]
WHERE mid.database_id = DB_ID() 
ORDER BY index_advantage DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look for indexes with high numbers of writes and zero or very low numbers of reads
// Consider your complete workload, and how long your instance has been running
// Investigate further before dropping an index!


// Missing Indexes for current database by Index Advantage  (Query 48) (Missing Indexes)-->
    <Query id="48" name="Missing Indexes" description="Missing Indexes for current database by Index Advantage" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT DISTINCT CONVERT(decimal(18,2), user_seeks * avg_total_user_cost * (avg_user_impact * 0.01)) AS [index_advantage], 
migs.last_user_seek, mid.[statement] AS [Database.Schema.Table],
mid.equality_columns, mid.inequality_columns, mid.included_columns,
migs.unique_compiles, migs.user_seeks, migs.avg_total_user_cost, migs.avg_user_impact,
OBJECT_NAME(mid.[object_id]) AS [Table Name], p.rows AS [Table Rows]
FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK)
ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)
ON mig.index_handle = mid.index_handle
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON p.[object_id] = mid.[object_id]
WHERE mid.database_id = DB_ID() 
ORDER BY index_advantage DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look for indexes with high numbers of writes and zero or very low numbers of reads
// Consider your complete workload, and how long your instance has been running
// Investigate further before dropping an index!


// Missing Indexes for current database by Index Advantage  (Query 54) (Missing Indexes)-->
    <Query id="54" name="Missing Indexes" description="Missing Indexes for current database by Index Advantage" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT DISTINCT CONVERT(decimal(18,2), user_seeks * avg_total_user_cost * (avg_user_impact * 0.01)) AS [index_advantage], 
migs.last_user_seek, mid.[statement] AS [Database.Schema.Table],
mid.equality_columns, mid.inequality_columns, mid.included_columns,
migs.unique_compiles, migs.user_seeks, migs.avg_total_user_cost, migs.avg_user_impact,
OBJECT_NAME(mid.[object_id]) AS [Table Name], p.rows AS [Table Rows]
FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK)
ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)
ON mig.index_handle = mid.index_handle
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON p.[object_id] = mid.[object_id]
WHERE mid.database_id = DB_ID() 
ORDER BY index_advantage DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look for indexes with high numbers of writes and zero or very low numbers of reads
// Consider your complete workload, and how long your instance has been running
// Investigate further before dropping an index!


// Missing Indexes for current database by Index Advantage  (Query 60) (Missing Indexes)-->
    <Query id="60" name="Missing Indexes" description="Missing Indexes for current database by Index Advantage" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT DISTINCT CONVERT(decimal(18,2), user_seeks * avg_total_user_cost * (avg_user_impact * 0.01)) AS [index_advantage], 
migs.last_user_seek, mid.[statement] AS [Database.Schema.Table],
mid.equality_columns, mid.inequality_columns, mid.included_columns,
migs.unique_compiles, migs.user_seeks, migs.avg_total_user_cost, migs.avg_user_impact,
OBJECT_NAME(mid.[object_id]) AS [Table Name], p.rows AS [Table Rows]
FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK)
ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)
ON mig.index_handle = mid.index_handle
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON p.[object_id] = mid.[object_id]
WHERE mid.database_id = DB_ID() 
ORDER BY index_advantage DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look for indexes with high numbers of writes and zero or very low numbers of reads
// Consider your complete workload, and how long your instance has been running
// Investigate further before dropping an index!


// Missing Indexes for current database by Index Advantage  (Query 62) (Missing Indexes)-->
    <Query id="62" name="Missing Indexes" description="Missing Indexes for current database by Index Advantage" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT DISTINCT CONVERT(decimal(18,2), user_seeks * avg_total_user_cost * (avg_user_impact * 0.01)) AS [index_advantage], 
migs.last_user_seek, mid.[statement] AS [Database.Schema.Table],
mid.equality_columns, mid.inequality_columns, mid.included_columns,
migs.unique_compiles, migs.user_seeks, migs.avg_total_user_cost, migs.avg_user_impact,
OBJECT_NAME(mid.[object_id]) AS [Table Name], p.rows AS [Table Rows]
FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK)
ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)
ON mig.index_handle = mid.index_handle
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON p.[object_id] = mid.[object_id]
WHERE mid.database_id = DB_ID() 
ORDER BY index_advantage DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look for indexes with high numbers of writes and zero or very low numbers of reads
// Consider your complete workload, and how long your instance has been running
// Investigate further before dropping an index!


// Missing Indexes for current database by Index Advantage  (Query 62) (Missing Indexes)-->
    <Query id="62" name="Missing Indexes" description="Missing Indexes for current database by Index Advantage" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT DISTINCT CONVERT(decimal(18,2), user_seeks * avg_total_user_cost * (avg_user_impact * 0.01)) AS [index_advantage], 
migs.last_user_seek, mid.[statement] AS [Database.Schema.Table],
mid.equality_columns, mid.inequality_columns, mid.included_columns,
migs.unique_compiles, migs.user_seeks, migs.avg_total_user_cost, migs.avg_user_impact,
OBJECT_NAME(mid.[object_id]) AS [Table Name], p.rows AS [Table Rows]
FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK)
ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)
ON mig.index_handle = mid.index_handle
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON p.[object_id] = mid.[object_id]
WHERE mid.database_id = DB_ID() 
ORDER BY index_advantage DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Things to look at:
// How many databases are on the instance?
// What recovery models are they using?
// What is the log reuse wait description?
// How full are the transaction logs ?
// What compatibility level are the databases on? 
// What is the Page Verify Option? (should be CHECKSUM)
// Is Auto Update Statistics Asynchronously enabled?
// Make sure auto_shrink and auto_close are not enabled!



// Missing Indexes for all databases by Index Advantage  (Query 16) (Missing Indexes All Databases)-->
    <Query id="16" name="Missing Indexes All Databases" description="Missing Indexes for all databases by Index Advantage" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT CONVERT(decimal(18,2), user_seeks * avg_total_user_cost * (avg_user_impact * 0.01)) AS [index_advantage], 
migs.last_user_seek, mid.[statement] AS [Database.Schema.Table],
mid.equality_columns, mid.inequality_columns, mid.included_columns,
migs.unique_compiles, migs.user_seeks, migs.avg_total_user_cost, migs.avg_user_impact
FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK)
ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)
ON mig.index_handle = mid.index_handle
ORDER BY index_advantage DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Things to look at:
// How many databases are on the instance?
// What recovery models are they using?
// What is the log reuse wait description?
// How full are the transaction logs ?
// What compatibility level are the databases on? 
// What is the Page Verify Option? (should be CHECKSUM)
// Is Auto Update Statistics Asynchronously enabled?
// Make sure auto_shrink and auto_close are not enabled!



// Missing Indexes for all databases by Index Advantage  (Query 22) (Missing Indexes All Databases)-->
    <Query id="22" name="Missing Indexes All Databases" description="Missing Indexes for all databases by Index Advantage" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT CONVERT(decimal(18,2), user_seeks * avg_total_user_cost * (avg_user_impact * 0.01)) AS [index_advantage],  
migs.last_user_seek, mid.[statement] AS [Database.Schema.Table],
mid.equality_columns, mid.inequality_columns, mid.included_columns,
migs.unique_compiles, migs.user_seeks, migs.avg_total_user_cost, migs.avg_user_impact
FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK)
ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)
ON mig.index_handle = mid.index_handle
ORDER BY index_advantage DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Things to look at:
// How many databases are on the instance?
// What recovery models are they using?
// What is the log reuse wait description?
// How full are the transaction logs ?
// What compatibility level are the databases on? 
// What is the Page Verify Option? (should be CHECKSUM)
// Is Auto Update Statistics Asynchronously enabled?
// Make sure auto_shrink and auto_close are not enabled!



// Missing Indexes for all databases by Index Advantage  (Query 18) (Missing Indexes All Databases)-->
    <Query id="18" name="Missing Indexes All Databases" description="Missing Indexes for all databases by Index Advantage" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT CONVERT(decimal(18,2), user_seeks * avg_total_user_cost * (avg_user_impact * 0.01)) AS [index_advantage], 
migs.last_user_seek, mid.[statement] AS [Database.Schema.Table],
mid.equality_columns, mid.inequality_columns, mid.included_columns,
migs.unique_compiles, migs.user_seeks, migs.avg_total_user_cost, migs.avg_user_impact
FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK)
ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)
ON mig.index_handle = mid.index_handle
ORDER BY index_advantage DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Things to look at:
// How many databases are on the instance?
// What recovery models are they using?
// What is the log reuse wait description?
// How full are the transaction logs?
// What compatibility level are the databases on? 
// What is the Page Verify Option? (should be CHECKSUM)
// Is Auto Update Statistics Asynchronously enabled?
// Make sure auto_shrink and auto_close are not enabled!



// Missing Indexes for all databases by Index Advantage  (Query 26) (Missing Indexes All Databases)-->
    <Query id="26" name="Missing Indexes All Databases" description="Missing Indexes for all databases by Index Advantage" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT CONVERT(decimal(18,2), user_seeks * avg_total_user_cost * (avg_user_impact * 0.01)) AS [index_advantage], 
migs.last_user_seek, mid.[statement] AS [Database.Schema.Table],
mid.equality_columns, mid.inequality_columns, mid.included_columns,
migs.unique_compiles, migs.user_seeks, migs.avg_total_user_cost, migs.avg_user_impact
FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK)
ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)
ON mig.index_handle = mid.index_handle
ORDER BY index_advantage DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Things to look at:
// How many databases are on the instance?
// What recovery models are they using?
// What is the log reuse wait description?
// How full are the transaction logs?
// What compatibility level are the databases on? 
// What is the Page Verify Option? (should be CHECKSUM)
// Is Auto Update Statistics Asynchronously enabled?
// Is Delayed Durability enabled
// Make sure auto_shrink and auto_close are not enabled!

// is_mixed_page_allocation_on is a new property for SQL Server 2016. Equivalent to TF 1118 for a user database
// SQL Server 2016: Changes in default behavior for autogrow and allocations for tempdb and user databases
// https://blogs.msdn.microsoft.com/sql_server_team/sql-server-2016-changes-in-default-behavior-for-autogrow-and-allocations-for-tempdb-and-user-databases/

// A non-zero value for target_recovery_time_in_seconds means that indirect checkpoint is enabled 
// If the setting has a zero value it indicates that automatic checkpoint is enabled

// Changes in SQL Server 2016 Checkpoint Behavior
// https://blogs.msdn.microsoft.com/sqlcat/2016/08/03/changes-in-sql-server-2016-checkpoint-behavior/


// Missing Indexes for all databases by Index Advantage  (Query 31) (Missing Indexes All Databases)-->
    <Query id="31" name="Missing Indexes All Databases" description="Missing Indexes for all databases by Index Advantage" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT CONVERT(decimal(18,2), user_seeks * avg_total_user_cost * (avg_user_impact * 0.01)) AS [index_advantage], 
migs.last_user_seek, mid.[statement] AS [Database.Schema.Table],
mid.equality_columns, mid.inequality_columns, mid.included_columns,
migs.unique_compiles, migs.user_seeks, migs.avg_total_user_cost, migs.avg_user_impact
FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK)
ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)
ON mig.index_handle = mid.index_handle
ORDER BY index_advantage DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Things to look at:
// How many databases are on the instance?
// What recovery models are they using?
// What is the log reuse wait description?
// How full are the transaction logs?
// What compatibility level are the databases on? 
// What is the Page Verify Option? (should be CHECKSUM)
// Is Auto Update Statistics Asynchronously enabled?
// Is Delayed Durability enabled
// Make sure auto_shrink and auto_close are not enabled!

// is_mixed_page_allocation_on is a new property for SQL Server 2016. Equivalent to TF 1118 for a user database
// SQL Server 2016: Changes in default behavior for autogrow and allocations for tempdb and user databases
// https://blogs.msdn.microsoft.com/sql_server_team/sql-server-2016-changes-in-default-behavior-for-autogrow-and-allocations-for-tempdb-and-user-databases/

// A non-zero value for target_recovery_time_in_seconds means that indirect checkpoint is enabled 
// If the setting has a zero value it indicates that automatic checkpoint is enabled

// Changes in SQL Server 2016 Checkpoint Behavior
// https://blogs.msdn.microsoft.com/sqlcat/2016/08/03/changes-in-sql-server-2016-checkpoint-behavior/


// Missing Indexes for all databases by Index Advantage  (Query 31) (Missing Indexes All Databases)-->
    <Query id="31" name="Missing Indexes All Databases" description="Missing Indexes for all databases by Index Advantage" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT CONVERT(decimal(18,2), user_seeks * avg_total_user_cost * (avg_user_impact * 0.01)) AS [index_advantage], 
migs.last_user_seek, mid.[statement] AS [Database.Schema.Table],
mid.equality_columns, mid.inequality_columns, mid.included_columns,
migs.unique_compiles, migs.user_seeks, migs.avg_total_user_cost, migs.avg_user_impact
FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK)
INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK)
ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK)
ON mig.index_handle = mid.index_handle
ORDER BY index_advantage DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine whether you have framentation in your relational indexes
// and how effective your index maintenance strategy is


//- Index Read/Write stats (all tables in current DB) ordered by Reads  (Query 48) (Overall Index Usage - Reads)-->
    <Query id="48" name="Overall Index Usage - Reads" description="- Index Read/Write stats (all tables in current DB) ordered by Reads" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(s.[object_id]) AS [ObjectName], i.name AS [IndexName], i.index_id,
	   user_seeks + user_scans + user_lookups AS [Reads], s.user_updates AS [Writes],  
	   i.type_desc AS [IndexType], i.fill_factor AS [FillFactor]
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON s.[object_id] = i.[object_id]
WHERE OBJECTPROPERTY(s.[object_id],'IsUserTable') = 1
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
ORDER BY user_seeks + user_scans + user_lookups DESC OPTION (RECOMPILE); -- Order by reads
]]></Query>
    <!--//////
   
// Helps determine whether you have framentation in your relational indexes
// and how effective your index maintenance strategy is


//- Index Read/Write stats (all tables in current DB) ordered by Reads  (Query 61) (Overall Index Usage - Reads)-->
    <Query id="61" name="Overall Index Usage - Reads" description="- Index Read/Write stats (all tables in current DB) ordered by Reads" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT OBJECT_NAME(s.[object_id]) AS [ObjectName], i.name AS [IndexName], i.index_id,
	   user_seeks + user_scans + user_lookups AS [Reads], s.user_updates AS [Writes],  
	   i.type_desc AS [IndexType], i.fill_factor AS [FillFactor], i.has_filter, i.filter_definition, 
	   s.last_user_scan, s.last_user_lookup, s.last_user_seek
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON s.[object_id] = i.[object_id]
WHERE OBJECTPROPERTY(s.[object_id],'IsUserTable') = 1
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
ORDER BY user_seeks + user_scans + user_lookups DESC OPTION (RECOMPILE); -- Order by reads
]]></Query>
    <!--//////
   
// Helps determine whether you have framentation in your relational indexes
// and how effective your index maintenance strategy is


//- Index Read/Write stats (all tables in current DB) ordered by Reads  (Query 56) (Overall Index Usage - Reads)-->
    <Query id="56" name="Overall Index Usage - Reads" description="- Index Read/Write stats (all tables in current DB) ordered by Reads" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(s.[object_id]) AS [ObjectName], i.name AS [IndexName], i.index_id,
	   user_seeks + user_scans + user_lookups AS [Reads], s.user_updates AS [Writes],  
	   i.type_desc AS [IndexType], i.fill_factor AS [FillFactor], i.has_filter, i.filter_definition, 
	   s.last_user_scan, s.last_user_lookup, s.last_user_seek
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON s.[object_id] = i.[object_id]
WHERE OBJECTPROPERTY(s.[object_id],'IsUserTable') = 1
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
ORDER BY user_seeks + user_scans + user_lookups DESC OPTION (RECOMPILE); -- Order by reads
]]></Query>
    <!--//////
   
// Helps determine whether you have framentation in your relational indexes
// and how effective your index maintenance strategy is


//- Index Read/Write stats (all tables in current DB) ordered by Reads  (Query 62) (Overall Index Usage - Reads)-->
    <Query id="62" name="Overall Index Usage - Reads" description="- Index Read/Write stats (all tables in current DB) ordered by Reads" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(i.[object_id]) AS [ObjectName], i.[name] AS [IndexName], i.index_id, 
       s.user_seeks, s.user_scans, s.user_lookups,
	   s.user_seeks + s.user_scans + s.user_lookups AS [Total Reads], 
	   s.user_updates AS [Writes],  
	   i.[type_desc] AS [Index Type], i.fill_factor AS [Fill Factor], i.has_filter, i.filter_definition, 
	   s.last_user_scan, s.last_user_lookup, s.last_user_seek
FROM sys.indexes AS i WITH (NOLOCK)
LEFT OUTER JOIN sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id]
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
WHERE OBJECTPROPERTY(i.[object_id],'IsUserTable') = 1
ORDER BY s.user_seeks + s.user_scans + s.user_lookups DESC OPTION (RECOMPILE); -- Order by reads
]]></Query>
    <!--//////
   
// Helps determine whether you have framentation in your relational indexes
// and how effective your index maintenance strategy is


//- Index Read/Write stats (all tables in current DB) ordered by Reads  (Query 68) (Overall Index Usage - Reads)-->
    <Query id="68" name="Overall Index Usage - Reads" description="- Index Read/Write stats (all tables in current DB) ordered by Reads" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(i.[object_id]) AS [ObjectName], i.[name] AS [IndexName], i.index_id, 
       s.user_seeks, s.user_scans, s.user_lookups,
	   s.user_seeks + s.user_scans + s.user_lookups AS [Total Reads], 
	   s.user_updates AS [Writes],  
	   i.[type_desc] AS [Index Type], i.fill_factor AS [Fill Factor], i.has_filter, i.filter_definition, 
	   s.last_user_scan, s.last_user_lookup, s.last_user_seek
FROM sys.indexes AS i WITH (NOLOCK)
LEFT OUTER JOIN sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id]
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
WHERE OBJECTPROPERTY(i.[object_id],'IsUserTable') = 1
ORDER BY s.user_seeks + s.user_scans + s.user_lookups DESC OPTION (RECOMPILE); -- Order by reads
]]></Query>
    <!--//////
   
// Helps determine whether you have framentation in your relational indexes
// and how effective your index maintenance strategy is


//- Index Read/Write stats (all tables in current DB) ordered by Reads  (Query 70) (Overall Index Usage - Reads)-->
    <Query id="70" name="Overall Index Usage - Reads" description="- Index Read/Write stats (all tables in current DB) ordered by Reads" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(i.[object_id]) AS [ObjectName], i.[name] AS [IndexName], i.index_id, 
       s.user_seeks, s.user_scans, s.user_lookups,
	   s.user_seeks + s.user_scans + s.user_lookups AS [Total Reads], 
	   s.user_updates AS [Writes],  
	   i.[type_desc] AS [Index Type], i.fill_factor AS [Fill Factor], i.has_filter, i.filter_definition, 
	   s.last_user_scan, s.last_user_lookup, s.last_user_seek
FROM sys.indexes AS i WITH (NOLOCK)
LEFT OUTER JOIN sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id]
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
WHERE OBJECTPROPERTY(i.[object_id],'IsUserTable') = 1
ORDER BY s.user_seeks + s.user_scans + s.user_lookups DESC OPTION (RECOMPILE); -- Order by reads
]]></Query>
    <!--//////
   
// Helps determine whether you have framentation in your relational indexes
// and how effective your index maintenance strategy is


//- Index Read/Write stats (all tables in current DB) ordered by Reads  (Query 70) (Overall Index Usage - Reads)-->
    <Query id="70" name="Overall Index Usage - Reads" description="- Index Read/Write stats (all tables in current DB) ordered by Reads" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(i.[object_id]) AS [ObjectName], i.[name] AS [IndexName], i.index_id, 
       s.user_seeks, s.user_scans, s.user_lookups,
	   s.user_seeks + s.user_scans + s.user_lookups AS [Total Reads], 
	   s.user_updates AS [Writes],  
	   i.[type_desc] AS [Index Type], i.fill_factor AS [Fill Factor], i.has_filter, i.filter_definition, 
	   s.last_user_scan, s.last_user_lookup, s.last_user_seek
FROM sys.indexes AS i WITH (NOLOCK)
LEFT OUTER JOIN sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id]
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
WHERE OBJECTPROPERTY(i.[object_id],'IsUserTable') = 1
ORDER BY s.user_seeks + s.user_scans + s.user_lookups DESC OPTION (RECOMPILE); -- Order by reads
]]></Query>
    <!--//////
   
// Show which indexes in the current database are most active for Reads


//- Index Read/Write stats (all tables in current DB) ordered by Writes  (Query 49) (Overall Index Usage - Writes)-->
    <Query id="49" name="Overall Index Usage - Writes" description="- Index Read/Write stats (all tables in current DB) ordered by Writes" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(s.[object_id]) AS [ObjectName], i.name AS [IndexName], i.index_id,
	   s.user_updates AS [Writes], user_seeks + user_scans + user_lookups AS [Reads], 
	   i.type_desc AS [IndexType], i.fill_factor AS [FillFactor],
	   s.last_system_update, s.last_user_update
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON s.[object_id] = i.[object_id]
WHERE OBJECTPROPERTY(s.[object_id],'IsUserTable') = 1
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
ORDER BY s.user_updates DESC OPTION (RECOMPILE);						 -- Order by writes
]]></Query>
    <!--//////
   

// Show which indexes in the current database are most active for Reads


//- Index Read/Write stats (all tables in current DB) ordered by Writes  (Query 62) (Overall Index Usage - Writes)-->
    <Query id="62" name="Overall Index Usage - Writes" description="- Index Read/Write stats (all tables in current DB) ordered by Writes" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT OBJECT_NAME(s.[object_id]) AS [ObjectName], i.name AS [IndexName], i.index_id,
	   s.user_updates AS [Writes], user_seeks + user_scans + user_lookups AS [Reads], 
	   i.type_desc AS [IndexType], i.fill_factor AS [FillFactor], i.has_filter, i.filter_definition,
	   s.last_system_update, s.last_user_update
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON s.[object_id] = i.[object_id]
WHERE OBJECTPROPERTY(s.[object_id],'IsUserTable') = 1
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
ORDER BY s.user_updates DESC OPTION (RECOMPILE);						 -- Order by writes
]]></Query>
    <!--//////
   

// Show which indexes in the current database are most active for Reads


//- Index Read/Write stats (all tables in current DB) ordered by Writes  (Query 57) (Overall Index Usage - Writes)-->
    <Query id="57" name="Overall Index Usage - Writes" description="- Index Read/Write stats (all tables in current DB) ordered by Writes" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(s.[object_id]) AS [ObjectName], i.name AS [IndexName], i.index_id,
	   s.user_updates AS [Writes], user_seeks + user_scans + user_lookups AS [Reads], 
	   i.type_desc AS [IndexType], i.fill_factor AS [FillFactor], i.has_filter, i.filter_definition,
	   s.last_system_update, s.last_user_update
FROM sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON s.[object_id] = i.[object_id]
WHERE OBJECTPROPERTY(s.[object_id],'IsUserTable') = 1
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
ORDER BY s.user_updates DESC OPTION (RECOMPILE);						 -- Order by writes
]]></Query>
    <!--//////
   
// Show which indexes in the current database are most active for Reads


//- Index Read/Write stats (all tables in current DB) ordered by Writes  (Query 63) (Overall Index Usage - Writes)-->
    <Query id="63" name="Overall Index Usage - Writes" description="- Index Read/Write stats (all tables in current DB) ordered by Writes" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(i.[object_id]) AS [ObjectName], i.[name] AS [IndexName], i.index_id,
	   s.user_updates AS [Writes], s.user_seeks + s.user_scans + s.user_lookups AS [Total Reads], 
	   i.[type_desc] AS [Index Type], i.fill_factor AS [Fill Factor], i.has_filter, i.filter_definition,
	   s.last_system_update, s.last_user_update
FROM sys.indexes AS i WITH (NOLOCK)
LEFT OUTER JOIN sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id]
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
WHERE OBJECTPROPERTY(i.[object_id],'IsUserTable') = 1
ORDER BY s.user_updates DESC OPTION (RECOMPILE);						 -- Order by writes
]]></Query>
    <!--//////
   
// Show which indexes in the current database are most active for Reads


//- Index Read/Write stats (all tables in current DB) ordered by Writes  (Query 69) (Overall Index Usage - Writes)-->
    <Query id="69" name="Overall Index Usage - Writes" description="- Index Read/Write stats (all tables in current DB) ordered by Writes" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(i.[object_id]) AS [ObjectName], i.[name] AS [IndexName], i.index_id,
	   s.user_updates AS [Writes], s.user_seeks + s.user_scans + s.user_lookups AS [Total Reads], 
	   i.[type_desc] AS [Index Type], i.fill_factor AS [Fill Factor], i.has_filter, i.filter_definition,
	   s.last_system_update, s.last_user_update
FROM sys.indexes AS i WITH (NOLOCK)
LEFT OUTER JOIN sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id]
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
WHERE OBJECTPROPERTY(i.[object_id],'IsUserTable') = 1
ORDER BY s.user_updates DESC OPTION (RECOMPILE);						 -- Order by writes
]]></Query>
    <!--//////
   
// Show which indexes in the current database are most active for Reads


//- Index Read/Write stats (all tables in current DB) ordered by Writes  (Query 71) (Overall Index Usage - Writes)-->
    <Query id="71" name="Overall Index Usage - Writes" description="- Index Read/Write stats (all tables in current DB) ordered by Writes" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(i.[object_id]) AS [ObjectName], i.[name] AS [IndexName], i.index_id,
	   s.user_updates AS [Writes], s.user_seeks + s.user_scans + s.user_lookups AS [Total Reads], 
	   i.[type_desc] AS [Index Type], i.fill_factor AS [Fill Factor], i.has_filter, i.filter_definition,
	   s.last_system_update, s.last_user_update
FROM sys.indexes AS i WITH (NOLOCK)
LEFT OUTER JOIN sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id]
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
WHERE OBJECTPROPERTY(i.[object_id],'IsUserTable') = 1
ORDER BY s.user_updates DESC OPTION (RECOMPILE);						 -- Order by writes
]]></Query>
    <!--//////
   
// Show which indexes in the current database are most active for Reads


//- Index Read/Write stats (all tables in current DB) ordered by Writes  (Query 71) (Overall Index Usage - Writes)-->
    <Query id="71" name="Overall Index Usage - Writes" description="- Index Read/Write stats (all tables in current DB) ordered by Writes" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(i.[object_id]) AS [ObjectName], i.[name] AS [IndexName], i.index_id,
	   s.user_updates AS [Writes], s.user_seeks + s.user_scans + s.user_lookups AS [Total Reads], 
	   i.[type_desc] AS [Index Type], i.fill_factor AS [Fill Factor], i.has_filter, i.filter_definition,
	   s.last_system_update, s.last_user_update
FROM sys.indexes AS i WITH (NOLOCK)
LEFT OUTER JOIN sys.dm_db_index_usage_stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id]
AND i.index_id = s.index_id
AND s.database_id = DB_ID()
WHERE OBJECTPROPERTY(i.[object_id],'IsUserTable') = 1
ORDER BY s.user_updates DESC OPTION (RECOMPILE);						 -- Order by writes
]]></Query>
    <!--//////
   
// Look at the trend over the entire period. 
// Also look at high sustained Other Process CPU Utilization values


// Page Life Expectancy (PLE) value for each NUMA node in current instance  (Query 27) (PLE by NUMA Node)-->
    <Query id="27" name="PLE by NUMA Node" description="Page Life Expectancy (PLE) value for each NUMA node in current instance" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], instance_name, cntr_value AS [Page Life Expectancy]
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Buffer Node%' -- Handles named instances
AND counter_name = N'Page life expectancy' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You want to see 0 for process_physical_memory_low
// You want to see 0 for process_virtual_memory_low
// This indicates that you are not under internal memory pressure


// Page Life Expectancy (PLE) value for each NUMA node in current instance  (Query 36) (PLE by NUMA Node)-->
    <Query id="36" name="PLE by NUMA Node" description="Page Life Expectancy (PLE) value for each NUMA node in current instance" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], instance_name, cntr_value AS [Page Life Expectancy]
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Buffer Node%' -- Handles named instances
AND counter_name = N'Page life expectancy' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You want to see 0 for process_physical_memory_low
// You want to see 0 for process_virtual_memory_low
// This indicates that you are not under internal memory pressure


// Page Life Expectancy (PLE) value for each NUMA node in current instance  (Query 32) (PLE by NUMA Node)-->
    <Query id="32" name="PLE by NUMA Node" description="Page Life Expectancy (PLE) value for each NUMA node in current instance" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], instance_name, cntr_value AS [Page Life Expectancy]
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Buffer Node%' -- Handles named instances
AND counter_name = N'Page life expectancy' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// Helps you find the most expensive queries from a CPU perspective across the entire instance
// Can also help track down parameter sniffing issues



// Page Life Expectancy (PLE) value for each NUMA node in current instance  (Query 37) (PLE by NUMA Node)-->
    <Query id="37" name="PLE by NUMA Node" description="Page Life Expectancy (PLE) value for each NUMA node in current instance" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], instance_name, cntr_value AS [Page Life Expectancy]
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Buffer Node%' -- Handles named instances
AND counter_name = N'Page life expectancy' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// Helps you find the most expensive queries from a CPU perspective across the entire instance
// Can also help track down parameter sniffing issues



// Page Life Expectancy (PLE) value for each NUMA node in current instance  (Query 42) (PLE by NUMA Node)-->
    <Query id="42" name="PLE by NUMA Node" description="Page Life Expectancy (PLE) value for each NUMA node in current instance" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], instance_name, cntr_value AS [Page Life Expectancy]
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Buffer Node%' -- Handles named instances
AND counter_name = N'Page life expectancy' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// Helps you find the most expensive queries from a CPU perspective across the entire instance
// Can also help track down parameter sniffing issues



// Page Life Expectancy (PLE) value for each NUMA node in current instance  (Query 42) (PLE by NUMA Node)-->
    <Query id="42" name="PLE by NUMA Node" description="Page Life Expectancy (PLE) value for each NUMA node in current instance" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], instance_name, cntr_value AS [Page Life Expectancy]
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Buffer Node%' -- Handles named instances
AND counter_name = N'Page life expectancy' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// Helps you find the most expensive queries from a CPU perspective across the entire instance
// Can also help track down parameter sniffing issues



// Page Life Expectancy (PLE) value for each NUMA node in current instance  (Query 42) (PLE by NUMA Node)-->
    <Query id="42" name="PLE by NUMA Node" description="Page Life Expectancy (PLE) value for each NUMA node in current instance" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], [object_name], instance_name, cntr_value AS [Page Life Expectancy]
FROM sys.dm_os_performance_counters WITH (NOLOCK)
WHERE [object_name] LIKE N'%Buffer Node%' -- Handles named instances
AND counter_name = N'Page life expectancy' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You want to see "Available physical memory is high"
// This indicates that you are not under external memory pressure


// SQL Server Process Address space info  (Query 35) (Process Memory) 
// (shows whether locked pages is enabled, among other things)-->
    <Query id="35" name="Process Memory" description="SQL Server Process Address space info" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT physical_memory_in_use_kb/1024 AS [SQL Server Memory Usage (MB)],
       large_page_allocations_kb, locked_page_allocations_kb, page_fault_count, 
	   memory_utilization_percentage, available_commit_limit_kb, 
	   process_physical_memory_low, process_virtual_memory_low
FROM sys.dm_os_process_memory WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You want to see "Available physical memory is high"
// This indicates that you are not under external memory pressure


// SQL Server Process Address space info  (Query 31) (Process Memory) 
// (shows whether locked pages is enabled, among other things)-->
    <Query id="31" name="Process Memory" description="SQL Server Process Address space info" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT physical_memory_in_use_kb/1024 AS [SQL Server Memory Usage (MB)],
       large_page_allocations_kb, locked_page_allocations_kb, page_fault_count, 
	   memory_utilization_percentage, available_commit_limit_kb, 
	   process_physical_memory_low, process_virtual_memory_low
FROM sys.dm_os_process_memory WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// If no global trace flags are enabled, no results will be returned.
// It is very useful to know what global trace flags are currently enabled as part of the diagnostic process.

// Common trace flags that should be enabled in most cases
// TF 1117 - When growing a data file, grow all files at the same time so they remain the same size, reducing allocation contention points
//           http://support2.microsoft.com/kb/2154845
// 
// TF 1118 - Helps alleviate allocation contention in tempdb, SQL Server allocates full extents to each database object, 
//           thereby eliminating the contention on SGAM pages (more important with older versions of SQL Server)
//           Recommendations to reduce allocation contention in SQL Server tempdb database
//           http://support2.microsoft.com/kb/2154845

// TF 2371 - Lowers auto update statistics threshold for large tables
//           http://blogs.msdn.com/b/saponsqlserver/archive/2011/09/07/changes-to-automatic-update-statistics-in-sql-server-traceflag-2371.aspx

// TF 3226 - Supresses logging of successful database backup messages to the SQL Server Error Log
//           http://www.sqlskills.com/blogs/paul/fed-up-with-backup-success-messages-bloating-your-error-logs/

// TF 6533 - Spatial performance improvements in SQL Server 2012 and 2014
//           https://support.microsoft.com/en-us/kb/3107399

// TF 6534 - Enables use of native code to improve performance with spatial data
//           https://blogs.msdn.microsoft.com/bobsql/2016/06/03/sql-2016-it-just-runs-faster-native-spatial-implementations/

// SQL Server query optimizer hotfix trace flag 4199 servicing model
// https://support.microsoft.com/en-us/kb/974006



// SQL Server Process Address space info  (Query 6) (Process Memory)
// (shows whether locked pages is enabled, among other things)-->
    <Query id="6" name="Process Memory" description="SQL Server Process Address space info" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT physical_memory_in_use_kb/1024 AS [SQL Server Memory Usage (MB)],
       large_page_allocations_kb, locked_page_allocations_kb, page_fault_count, 
	   memory_utilization_percentage, available_commit_limit_kb, 
	   process_physical_memory_low, process_virtual_memory_low
FROM sys.dm_os_process_memory WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// SQL Server Process Address space info  (Query 7) (Process Memory)
// (shows whether locked pages is enabled, among other things)-->
    <Query id="7" name="Process Memory" description="SQL Server Process Address space info" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT physical_memory_in_use_kb/1024 AS [SQL Server Memory Usage (MB)],
       large_page_allocations_kb, locked_page_allocations_kb, page_fault_count, 
	   memory_utilization_percentage, available_commit_limit_kb, 
	   process_physical_memory_low, process_virtual_memory_low
FROM sys.dm_os_process_memory WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Lets you determine whether Instant File Initialization (IFI) is enabled for the instance
// This should be enabled in the vast majority of cases
// SQL Server 2016 lets you enable this during the SQL server installation process

// Misconceptions around instant file initialization
// http://www.sqlskills.com/blogs/paul/misconceptions-around-instant-file-initialization/



// SQL Server Process Address space info  (Query 7) (Process Memory)
// (shows whether locked pages is enabled, among other things)-->
    <Query id="7" name="Process Memory" description="SQL Server Process Address space info" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT physical_memory_in_use_kb/1024 AS [SQL Server Memory Usage (MB)],
       large_page_allocations_kb, locked_page_allocations_kb, page_fault_count, 
	   memory_utilization_percentage, available_commit_limit_kb, 
	   process_physical_memory_low, process_virtual_memory_low
FROM sys.dm_os_process_memory WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Lets you determine whether Instant File Initialization (IFI) is enabled for the instance
// This should be enabled in the vast majority of cases
// SQL Server 2016 lets you enable this during the SQL server installation process

// Misconceptions around instant file initialization
// http://www.sqlskills.com/blogs/paul/misconceptions-around-instant-file-initialization/



// SQL Server Process Address space info  (Query 7) (Process Memory)
// (shows whether locked pages is enabled, among other things)-->
    <Query id="7" name="Process Memory" description="SQL Server Process Address space info" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT physical_memory_in_use_kb/1024 AS [SQL Server Memory Usage (MB)],
       large_page_allocations_kb, locked_page_allocations_kb, page_fault_count, 
	   memory_utilization_percentage, available_commit_limit_kb, 
	   process_physical_memory_low, process_virtual_memory_low
FROM sys.dm_os_process_memory WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////  
   
// This can help you determine the capabilities
// and capacities of your database server
// This often comes back with no results on SQL Server 2005


// Get processor description from Windows Registry  (Query 9) (Processor Description)-->
    <Query id="9" name="Processor Description" description="Get processor description from Windows Registry" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
EXEC sys.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'HARDWARE\DESCRIPTION\System\CentralProcessor\0', N'ProcessorNameString';
]]></Query>
    <!--////// 
   
// This can help you determine the capabilities
// and capacities of your database server


// Get processor description from Windows Registry  (Query 12) (Processor Description)-->
    <Query id="12" name="Processor Description" description="Get processor description from Windows Registry" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
EXEC sys.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'HARDWARE\DESCRIPTION\System\CentralProcessor\0', N'ProcessorNameString';
]]></Query>
    <!--////// 
   
// This can help you determine the capabilities
// and capacities of your database server


// Get processor description from Windows Registry  (Query 10) (Processor Description)-->
    <Query id="10" name="Processor Description" description="Get processor description from Windows Registry" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
EXEC sys.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'HARDWARE\DESCRIPTION\System\CentralProcessor\0', N'ProcessorNameString';
]]></Query>
    <!--////// 
   
// This can help you determine the capabilities and capacities of your database server
// Can also be used to confirm if you are running in a VM
// This query might take a few seconds if you have not recycled your error log recently
// This query will return no results if your error log has been recycled since the instance was started


// Get processor description from Windows Registry  (Query 18) (Processor Description)-->
    <Query id="18" name="Processor Description" description="Get processor description from Windows Registry" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
EXEC sys.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'HARDWARE\DESCRIPTION\System\CentralProcessor\0', N'ProcessorNameString';
]]></Query>
    <!--////// 
   
// This can help you determine the capabilities and capacities of your database server
// Can also be used to confirm if you are running in a VM
// This query might take a few seconds if you have not recycled your error log recently
// This query will return no results if your error log has been recycled since the instance was started


// Get processor description from Windows Registry  (Query 20) (Processor Description)-->
    <Query id="20" name="Processor Description" description="Get processor description from Windows Registry" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
EXEC sys.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'HARDWARE\DESCRIPTION\System\CentralProcessor\0', N'ProcessorNameString';
]]></Query>
    <!--////// 
   
// This can help you determine the capabilities and capacities of your database server
// Can also be used to confirm if you are running in a VM
// This query might take a few seconds if you have not recycled your error log recently
// This query will return no results if your error log has been recycled since the instance was started


// Get processor description from Windows Registry  (Query 20) (Processor Description)-->
    <Query id="20" name="Processor Description" description="Get processor description from Windows Registry" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
EXEC sys.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'HARDWARE\DESCRIPTION\System\CentralProcessor\0', N'ProcessorNameString';
]]></Query>
    <!--////// 
   
// This can help you determine the capabilities and capacities of your database server
// Can also be used to confirm if you are running in a VM
// This query might take a few seconds if you have not recycled your error log recently
// This query will return no results if your error log has been recycled since the instance was started


// Get processor description from Windows Registry  (Query 20) (Processor Description)-->
    <Query id="20" name="Processor Description" description="Get processor description from Windows Registry" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
EXEC sys.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'HARDWARE\DESCRIPTION\System\CentralProcessor\0', N'ProcessorNameString';
]]></Query>
    <!--//////
   
// This helps you characterize your workload better from an I/O perspective for this database
// It helps you determine whether you has an OLTP or DW/DSS type of workload



// Top cached queries by Execution Count (SQL Server 2008 R2)  (Query 42) (Query Execution Counts)
// SQL Server 2008 R2 SP1 and greater only-->
    <Query id="42" name="Query Execution Counts" description="Top cached queries by Execution Count (SQL Server 2008 R2)" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db" longTextColumns="query_text"><![CDATA[
SELECT TOP (100) qs.execution_count, qs.total_rows, qs.last_rows, qs.min_rows, qs.max_rows,
qs.last_elapsed_time, qs.min_elapsed_time, qs.max_elapsed_time,
total_worker_time, total_logical_reads, 
SUBSTRING(qt.TEXT,qs.statement_start_offset/2 +1,
(CASE WHEN qs.statement_end_offset = -1
			THEN LEN(CONVERT(NVARCHAR(MAX), qt.TEXT)) * 2
	  ELSE qs.statement_end_offset END - qs.statement_start_offset)/2) AS query_text 
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS qt
ORDER BY qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you characterize your workload better from an I/O perspective for this database
// It helps you determine whether you has an OLTP or DW/DSS type of workload



// Top cached queries by Execution Count (SQL Server 2008)  (Query 38) (Query Execution Counts)-->
    <Query id="38" name="Query Execution Counts" description="Top cached queries by Execution Count (SQL Server 2008)" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db" longTextColumns="query_text"><![CDATA[
SELECT TOP (100) qs.execution_count, qs.total_worker_time, qs.total_logical_reads, qs.total_elapsed_time,
SUBSTRING(qt.TEXT,qs.statement_start_offset/2 +1,
(CASE WHEN qs.statement_end_offset = -1
			THEN LEN(CONVERT(NVARCHAR(MAX), qt.TEXT)) * 2
	  ELSE qs.statement_end_offset END - qs.statement_start_offset)/2) AS query_text 
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS qt
ORDER BY qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you characterize your workload better from an I/O perspective for this database
// It helps you determine whether you has an OLTP or DW/DSS type of workload



// Get most frequently executed queries for this database (Query 45) (Query Execution Counts)-->
    <Query id="45" name="Query Execution Counts" description="Get most frequently executed queries for this database" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) 
qs.execution_count AS [Execution Count],
qs.total_logical_reads AS [Total Logical Reads],
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads],
qs.total_worker_time AS [Total Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.total_elapsed_time AS [Total Elapsed Time],
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.creation_time AS [Creation Time],
t.[text] AS [QueryText], 
qp.query_plan AS [QueryPlan] -- uncomment out these columns if not copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
WHERE t.dbid = DB_ID()
ORDER BY qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you characterize your workload better from an I/O perspective for this database
// It helps you determine whether you has an OLTP or DW/DSS type of workload



// Get most frequently executed queries for this database (Query 51) (Query Execution Counts)-->
    <Query id="51" name="Query Execution Counts" description="Get most frequently executed queries for this database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) qs.execution_count AS [Execution Count],
qs.total_logical_reads AS [Total Logical Reads],
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads],
qs.total_worker_time AS [Total Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.total_elapsed_time AS [Total Elapsed Time],
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.creation_time AS [Creation Time],
t.[text] AS [QueryText], 
qp.query_plan AS [QueryPlan] -- uncomment out these columns if not copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
WHERE t.dbid = DB_ID()
ORDER BY qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you characterize your workload better from an I/O perspective for this database
// It helps you determine whether you has an OLTP or DW/DSS type of workload



// Get most frequently executed queries for this database (Query 53) (Query Execution Counts)-->
    <Query id="53" name="Query Execution Counts" description="Get most frequently executed queries for this database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) LEFT(t.[text], 50) AS [Short Query Text], qs.execution_count AS [Execution Count],
qs.total_logical_reads AS [Total Logical Reads],
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads],
qs.total_worker_time AS [Total Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.total_elapsed_time AS [Total Elapsed Time],
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.creation_time AS [Creation Time],
t.[text] AS [QueryText], 
qp.query_plan AS [QueryPlan] -- uncomment out these columns if not copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
WHERE t.dbid = DB_ID()
ORDER BY qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you characterize your workload better from an I/O perspective for this database
// It helps you determine whether you has an OLTP or DW/DSS type of workload



// Get most frequently executed queries for this database (Query 53) (Query Execution Counts)-->
    <Query id="53" name="Query Execution Counts" description="Get most frequently executed queries for this database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) 
qs.execution_count AS [Execution Count],
qs.total_logical_reads AS [Total Logical Reads],
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads],
qs.total_worker_time AS [Total Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.total_elapsed_time AS [Total Elapsed Time],
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.creation_time AS [Creation Time],
t.[text] AS [QueryText], 
qp.query_plan AS [QueryPlan] -- uncomment out these columns if not copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
WHERE t.dbid = DB_ID()
ORDER BY qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// New for SQL Server 2016
// Helps you investigate scalar UDF performance issues

// sys.dm_exec_function_stats (Transact-SQL)
// https://msdn.microsoft.com/en-US/library/mt429371.aspx


// Get QueryStore Options for this database (Query 76) (QueryStore Options)-->
    <Query id="76" name="QueryStore Options" description="Get QueryStore Options for this database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT actual_state_desc, desired_state_desc,
       current_storage_size_mb, [max_storage_size_mb], 
	   query_capture_mode_desc, size_based_cleanup_mode_desc
FROM sys.database_query_store_options WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// New for SQL Server 2016
// Helps you investigate scalar UDF performance issues

// sys.dm_exec_function_stats (Transact-SQL)
// https://msdn.microsoft.com/en-US/library/mt429371.aspx


// Get QueryStore Options for this database (Query 76) (QueryStore Options)-->
    <Query id="76" name="QueryStore Options" description="Get QueryStore Options for this database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT actual_state_desc, desired_state_desc,
       current_storage_size_mb, [max_storage_size_mb], 
	   query_capture_mode_desc, size_based_cleanup_mode_desc
FROM sys.database_query_store_options WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This query is helpful for troubleshooting blocking and deadlocking issues


// Look at recent Full backups for the current database (Query 51) (Recent Full Backups)-->
    <Query id="51" name="Recent Full Backups" description="Look at recent Full backups for the current database" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT TOP (30) bs.server_name, bs.database_name AS [Database Name], 
CONVERT (BIGINT, bs.backup_size / 1048576 ) AS [Backup Size (MB)],
DATEDIFF (SECOND, bs.backup_start_date, bs.backup_finish_date) AS [Backup Elapsed Time (sec)],
bs.backup_finish_date AS [Backup Finish Date]
FROM msdb.dbo.backupset AS bs WITH (NOLOCK)
WHERE DATEDIFF (SECOND, bs.backup_start_date, bs.backup_finish_date) > 0 
AND bs.backup_size > 0
AND bs.type = 'D' -- Change to L if you want Log backups
AND database_name = DB_NAME(DB_ID())
ORDER BY bs.backup_finish_date DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This query is helpful for troubleshooting blocking and deadlocking issues


// Look at recent Full backups for the current database (Query 64) (Recent Full Backups)-->
    <Query id="64" name="Recent Full Backups" description="Look at recent Full backups for the current database" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT TOP (30) bs.machine_name, bs.server_name, bs.database_name AS [Database Name], bs.recovery_model,
CONVERT (BIGINT, bs.backup_size / 1048576 ) AS [Uncompressed Backup Size (MB)],
CONVERT (BIGINT, bs.compressed_backup_size / 1048576 ) AS [Compressed Backup Size (MB)],
CONVERT (NUMERIC (20,2), (CONVERT (FLOAT, bs.backup_size) /
CONVERT (FLOAT, bs.compressed_backup_size))) AS [Compression Ratio], bs.has_backup_checksums, bs.is_copy_only,
DATEDIFF (SECOND, bs.backup_start_date, bs.backup_finish_date) AS [Backup Elapsed Time (sec)],
bs.backup_finish_date AS [Backup Finish Date]
FROM msdb.dbo.backupset AS bs WITH (NOLOCK)
WHERE DATEDIFF (SECOND, bs.backup_start_date, bs.backup_finish_date) > 0 
AND bs.backup_size > 0
AND bs.type = 'D' -- Change to L if you want Log backups
AND database_name = DB_NAME(DB_ID())
ORDER BY bs.backup_finish_date DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This query is helpful for troubleshooting blocking and deadlocking issues


// Look at recent Full backups for the current database (Query 59) (Recent Full Backups)-->
    <Query id="59" name="Recent Full Backups" description="Look at recent Full backups for the current database" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT TOP (30) bs.machine_name, bs.server_name, bs.database_name AS [Database Name], bs.recovery_model,
CONVERT (BIGINT, bs.backup_size / 1048576 ) AS [Uncompressed Backup Size (MB)],
CONVERT (BIGINT, bs.compressed_backup_size / 1048576 ) AS [Compressed Backup Size (MB)],
CONVERT (NUMERIC (20,2), (CONVERT (FLOAT, bs.backup_size) /
CONVERT (FLOAT, bs.compressed_backup_size))) AS [Compression Ratio], 
DATEDIFF (SECOND, bs.backup_start_date, bs.backup_finish_date) AS [Backup Elapsed Time (sec)],
bs.backup_finish_date AS [Backup Finish Date]
FROM msdb.dbo.backupset AS bs WITH (NOLOCK)
WHERE DATEDIFF (SECOND, bs.backup_start_date, bs.backup_finish_date) > 0 
AND bs.backup_size > 0
AND bs.type = 'D' -- Change to L if you want Log backups
AND database_name = DB_NAME(DB_ID())
ORDER BY bs.backup_finish_date DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This query is helpful for troubleshooting blocking and deadlocking issues


// Look at recent Full backups for the current database (Query 65) (Recent Full Backups)-->
    <Query id="65" name="Recent Full Backups" description="Look at recent Full backups for the current database" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT TOP (30) bs.machine_name, bs.server_name, bs.database_name AS [Database Name], bs.recovery_model,
CONVERT (BIGINT, bs.backup_size / 1048576 ) AS [Uncompressed Backup Size (MB)],
CONVERT (BIGINT, bs.compressed_backup_size / 1048576 ) AS [Compressed Backup Size (MB)],
CONVERT (NUMERIC (20,2), (CONVERT (FLOAT, bs.backup_size) /
CONVERT (FLOAT, bs.compressed_backup_size))) AS [Compression Ratio], bs.has_backup_checksums, bs.is_copy_only,
DATEDIFF (SECOND, bs.backup_start_date, bs.backup_finish_date) AS [Backup Elapsed Time (sec)],
bs.backup_finish_date AS [Backup Finish Date]
FROM msdb.dbo.backupset AS bs WITH (NOLOCK)
WHERE bs.database_name = DB_NAME(DB_ID())
AND bs.[type] = 'D' -- Change to L if you want Log backups
ORDER BY bs.backup_finish_date DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you input buffer information from all non-system sessions for the current database
// Replaces DBCC INPUTBUFFER
// Requires SQL Server 2014 SP2 or later

// New DMF for retrieving input buffer in SQL Server
// https://blogs.msdn.microsoft.com/sql_server_team/new-dmf-for-retrieving-input-buffer-in-sql-server/


// Look at recent Full backups for the current database (Query 73) (Recent Full Backups)-->
    <Query id="73" name="Recent Full Backups" description="Look at recent Full backups for the current database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT TOP (30) bs.machine_name, bs.server_name, bs.database_name AS [Database Name], bs.recovery_model,
CONVERT (BIGINT, bs.backup_size / 1048576 ) AS [Uncompressed Backup Size (MB)],
CONVERT (BIGINT, bs.compressed_backup_size / 1048576 ) AS [Compressed Backup Size (MB)],
CONVERT (NUMERIC (20,2), (CONVERT (FLOAT, bs.backup_size) /
CONVERT (FLOAT, bs.compressed_backup_size))) AS [Compression Ratio], bs.has_backup_checksums, bs.is_copy_only, bs.encryptor_type,
DATEDIFF (SECOND, bs.backup_start_date, bs.backup_finish_date) AS [Backup Elapsed Time (sec)],
bs.backup_finish_date AS [Backup Finish Date]
FROM msdb.dbo.backupset AS bs WITH (NOLOCK)
WHERE bs.database_name = DB_NAME(DB_ID())
AND bs.[type] = 'D' -- Change to L if you want Log backups
ORDER BY bs.backup_finish_date DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you input buffer information from all non-system sessions for the current database
// Replaces DBCC INPUTBUFFER

// New DMF for retrieving input buffer in SQL Server
// https://blogs.msdn.microsoft.com/sql_server_team/new-dmf-for-retrieving-input-buffer-in-sql-server/



// Look at recent Full backups for the current database (Query 79) (Recent Full Backups)-->
    <Query id="79" name="Recent Full Backups" description="Look at recent Full backups for the current database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT TOP (30) bs.machine_name, bs.server_name, bs.database_name AS [Database Name], bs.recovery_model,
CONVERT (BIGINT, bs.backup_size / 1048576 ) AS [Uncompressed Backup Size (MB)],
CONVERT (BIGINT, bs.compressed_backup_size / 1048576 ) AS [Compressed Backup Size (MB)],
CONVERT (NUMERIC (20,2), (CONVERT (FLOAT, bs.backup_size) /
CONVERT (FLOAT, bs.compressed_backup_size))) AS [Compression Ratio], bs.has_backup_checksums, bs.is_copy_only, bs.encryptor_type,
DATEDIFF (SECOND, bs.backup_start_date, bs.backup_finish_date) AS [Backup Elapsed Time (sec)],
bs.backup_finish_date AS [Backup Finish Date]
FROM msdb.dbo.backupset AS bs WITH (NOLOCK)
WHERE bs.database_name = DB_NAME(DB_ID())
AND bs.[type] = 'D' -- Change to L if you want Log backups
ORDER BY bs.backup_finish_date DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you input buffer information from all non-system sessions for the current database
// Replaces DBCC INPUTBUFFER

// New DMF for retrieving input buffer in SQL Server
// https://blogs.msdn.microsoft.com/sql_server_team/new-dmf-for-retrieving-input-buffer-in-sql-server/



// Look at recent Full backups for the current database (Query 79) (Recent Full Backups)-->
    <Query id="79" name="Recent Full Backups" description="Look at recent Full backups for the current database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT TOP (30) bs.machine_name, bs.server_name, bs.database_name AS [Database Name], bs.recovery_model,
CONVERT (BIGINT, bs.backup_size / 1048576 ) AS [Uncompressed Backup Size (MB)],
CONVERT (BIGINT, bs.compressed_backup_size / 1048576 ) AS [Compressed Backup Size (MB)],
CONVERT (NUMERIC (20,2), (CONVERT (FLOAT, bs.backup_size) /
CONVERT (FLOAT, bs.compressed_backup_size))) AS [Compression Ratio], bs.has_backup_checksums, bs.is_copy_only, bs.encryptor_type,
DATEDIFF (SECOND, bs.backup_start_date, bs.backup_finish_date) AS [Backup Elapsed Time (sec)],
bs.backup_finish_date AS [Backup Finish Date]
FROM msdb.dbo.backupset AS bs WITH (NOLOCK)
WHERE bs.database_name = DB_NAME(DB_ID())
AND bs.[type] = 'D' -- Change to L if you want Log backups
ORDER BY bs.backup_finish_date DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you the date and time that SQL Server was installed
// It is a good idea to know how old your instance is



// Get selected server properties (Query 3) (Server Properties)-->
    <Query id="3" name="Server Properties" description="Get selected server properties" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT SERVERPROPERTY('MachineName') AS [MachineName], SERVERPROPERTY('ServerName') AS [ServerName],  
SERVERPROPERTY('InstanceName') AS [Instance], SERVERPROPERTY('IsClustered') AS [IsClustered], 
SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS [ComputerNamePhysicalNetBIOS], 
SERVERPROPERTY('Edition') AS [Edition], SERVERPROPERTY('ProductLevel') AS [ProductLevel], 
SERVERPROPERTY('ProductVersion') AS [ProductVersion], SERVERPROPERTY('ProcessID') AS [ProcessID],
SERVERPROPERTY('Collation') AS [Collation], SERVERPROPERTY('IsFullTextInstalled') AS [IsFullTextInstalled], 
SERVERPROPERTY('IsIntegratedSecurityOnly') AS [IsIntegratedSecurityOnly];
]]></Query>
    <!--//////
   
// Tells you the date and time that SQL Server was installed
// It is a good idea to know how old your instance is


// Get selected server properties (Query 3) (Server Properties)-->
    <Query id="3" name="Server Properties" description="Get selected server properties" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT SERVERPROPERTY('MachineName') AS [MachineName], SERVERPROPERTY('ServerName') AS [ServerName],  
SERVERPROPERTY('InstanceName') AS [Instance], SERVERPROPERTY('IsClustered') AS [IsClustered], 
SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS [ComputerNamePhysicalNetBIOS], 
SERVERPROPERTY('Edition') AS [Edition], SERVERPROPERTY('ProductLevel') AS [ProductLevel], 
SERVERPROPERTY('ProductVersion') AS [ProductVersion], SERVERPROPERTY('ProcessID') AS [ProcessID],
SERVERPROPERTY('Collation') AS [Collation], SERVERPROPERTY('IsFullTextInstalled') AS [IsFullTextInstalled], 
SERVERPROPERTY('IsIntegratedSecurityOnly') AS [IsIntegratedSecurityOnly];
]]></Query>
    <!--//////
   
// Tells you the date and time that SQL Server was installed
// It is a good idea to know how old your instance is


// Get selected server properties (Query 3) (Server Properties)-->
    <Query id="3" name="Server Properties" description="Get selected server properties" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT SERVERPROPERTY('MachineName') AS [MachineName], SERVERPROPERTY('ServerName') AS [ServerName],  
SERVERPROPERTY('InstanceName') AS [Instance], SERVERPROPERTY('IsClustered') AS [IsClustered], 
SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS [ComputerNamePhysicalNetBIOS], 
SERVERPROPERTY('Edition') AS [Edition], SERVERPROPERTY('ProductLevel') AS [ProductLevel], 
SERVERPROPERTY('ProductVersion') AS [ProductVersion], SERVERPROPERTY('ProcessID') AS [ProcessID],
SERVERPROPERTY('Collation') AS [Collation], SERVERPROPERTY('IsFullTextInstalled') AS [IsFullTextInstalled], 
SERVERPROPERTY('IsIntegratedSecurityOnly') AS [IsIntegratedSecurityOnly];
]]></Query>
    <!--//////
   
// This can help you determine the exact core counts used by SQL Server and whether HT is enabled or not
// It can also help you confirm your SQL Server licensing model
// Be on the lookout for this message "using 20 logical processors based on SQL Server licensing" 
// (when you have more than 20 logical cores) which means grandfathered Server/CAL licensing
// This query will return no results if your error log has been recycled since the instance was last started



// Get selected server properties (Query 3) (Server Properties)-->
    <Query id="3" name="Server Properties" description="Get selected server properties" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT SERVERPROPERTY('MachineName') AS [MachineName], 
SERVERPROPERTY('ServerName') AS [ServerName],  
SERVERPROPERTY('InstanceName') AS [Instance], 
SERVERPROPERTY('IsClustered') AS [IsClustered], 
SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS [ComputerNamePhysicalNetBIOS], 
SERVERPROPERTY('Edition') AS [Edition], 
SERVERPROPERTY('ProductLevel') AS [ProductLevel],				-- What servicing branch (RTM/SP/CU)
SERVERPROPERTY('ProductUpdateLevel') AS [ProductUpdateLevel],	-- Within a servicing branch, what CU# is applied
SERVERPROPERTY('ProductVersion') AS [ProductVersion],
SERVERPROPERTY('ProductMajorVersion') AS [ProductMajorVersion], 
SERVERPROPERTY('ProductMinorVersion') AS [ProductMinorVersion], 
SERVERPROPERTY('ProductBuild') AS [ProductBuild], 
SERVERPROPERTY('ProductBuildType') AS [ProductBuildType],		      -- Is this a GDR or OD hotfix (NULL if on a CU build)
SERVERPROPERTY('ProductUpdateReference') AS [ProductUpdateReference], -- KB article number that is applicable for this build
SERVERPROPERTY('ProcessID') AS [ProcessID],
SERVERPROPERTY('Collation') AS [Collation], 
SERVERPROPERTY('IsFullTextInstalled') AS [IsFullTextInstalled], 
SERVERPROPERTY('IsIntegratedSecurityOnly') AS [IsIntegratedSecurityOnly],
SERVERPROPERTY('FilestreamConfiguredLevel') AS [FilestreamConfiguredLevel],
SERVERPROPERTY('IsHadrEnabled') AS [IsHadrEnabled], 
SERVERPROPERTY('HadrManagerStatus') AS [HadrManagerStatus],
SERVERPROPERTY('InstanceDefaultDataPath') AS [InstanceDefaultDataPath],
SERVERPROPERTY('InstanceDefaultLogPath') AS [InstanceDefaultLogPath],
SERVERPROPERTY('BuildClrVersion') AS [Build CLR Version];
]]></Query>
    <!--//////
   
// This can help you determine the exact core counts used by SQL Server and whether HT is enabled or not
// It can also help you confirm your SQL Server licensing model
// Be on the lookout for this message "using 20 logical processors based on SQL Server licensing" 
// (when you have more than 20 logical cores) which means grandfathered Server/CAL licensing
// This query will return no results if your error log has been recycled since the instance was last started



// Get selected server properties (Query 3) (Server Properties)-->
    <Query id="3" name="Server Properties" description="Get selected server properties" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT SERVERPROPERTY('MachineName') AS [MachineName], 
SERVERPROPERTY('ServerName') AS [ServerName],  
SERVERPROPERTY('InstanceName') AS [Instance], 
SERVERPROPERTY('IsClustered') AS [IsClustered], 
SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS [ComputerNamePhysicalNetBIOS], 
SERVERPROPERTY('Edition') AS [Edition], 
SERVERPROPERTY('ProductLevel') AS [ProductLevel],				-- What servicing branch (RTM/SP/CU)
SERVERPROPERTY('ProductUpdateLevel') AS [ProductUpdateLevel],	-- Within a servicing branch, what CU# is applied
SERVERPROPERTY('ProductVersion') AS [ProductVersion],
SERVERPROPERTY('ProductMajorVersion') AS [ProductMajorVersion], 
SERVERPROPERTY('ProductMinorVersion') AS [ProductMinorVersion], 
SERVERPROPERTY('ProductBuild') AS [ProductBuild], 
SERVERPROPERTY('ProductBuildType') AS [ProductBuildType],		      -- Is this a GDR or OD hotfix (NULL if on a CU build)
SERVERPROPERTY('ProductUpdateReference') AS [ProductUpdateReference], -- KB article number that is applicable for this build
SERVERPROPERTY('ProcessID') AS [ProcessID],
SERVERPROPERTY('Collation') AS [Collation], 
SERVERPROPERTY('IsFullTextInstalled') AS [IsFullTextInstalled], 
SERVERPROPERTY('IsIntegratedSecurityOnly') AS [IsIntegratedSecurityOnly],
SERVERPROPERTY('FilestreamConfiguredLevel') AS [FilestreamConfiguredLevel],
SERVERPROPERTY('IsHadrEnabled') AS [IsHadrEnabled], 
SERVERPROPERTY('HadrManagerStatus') AS [HadrManagerStatus],
SERVERPROPERTY('InstanceDefaultDataPath') AS [InstanceDefaultDataPath],
SERVERPROPERTY('InstanceDefaultLogPath') AS [InstanceDefaultLogPath],
SERVERPROPERTY('BuildClrVersion') AS [Build CLR Version],
SERVERPROPERTY('IsXTPSupported') AS [IsXTPSupported];
]]></Query>
    <!--//////
   
// This can help you determine the exact core counts used by SQL Server and whether HT is enabled or not
// It can also help you confirm your SQL Server licensing model
// Be on the lookout for this message "using 20 logical processors based on SQL Server licensing" 
// (when you have more than 20 logical cores) which means grandfathered Server/CAL licensing
// This query will return no results if your error log has been recycled since the instance was last started



// Get selected server properties (Query 3) (Server Properties)-->
    <Query id="3" name="Server Properties" description="Get selected server properties" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT SERVERPROPERTY('MachineName') AS [MachineName], 
SERVERPROPERTY('ServerName') AS [ServerName],  
SERVERPROPERTY('InstanceName') AS [Instance], 
SERVERPROPERTY('IsClustered') AS [IsClustered], 
SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS [ComputerNamePhysicalNetBIOS], 
SERVERPROPERTY('Edition') AS [Edition], 
SERVERPROPERTY('ProductLevel') AS [ProductLevel],				-- What servicing branch (RTM/SP/CU)
SERVERPROPERTY('ProductUpdateLevel') AS [ProductUpdateLevel],	-- Within a servicing branch, what CU# is applied
SERVERPROPERTY('ProductVersion') AS [ProductVersion],
SERVERPROPERTY('ProductMajorVersion') AS [ProductMajorVersion], 
SERVERPROPERTY('ProductMinorVersion') AS [ProductMinorVersion], 
SERVERPROPERTY('ProductBuild') AS [ProductBuild], 
SERVERPROPERTY('ProductBuildType') AS [ProductBuildType],			  -- Is this a GDR or OD hotfix (NULL if on a CU build)
SERVERPROPERTY('ProductUpdateReference') AS [ProductUpdateReference], -- KB article number that is applicable for this build
SERVERPROPERTY('ProcessID') AS [ProcessID],
SERVERPROPERTY('Collation') AS [Collation], 
SERVERPROPERTY('IsFullTextInstalled') AS [IsFullTextInstalled], 
SERVERPROPERTY('IsIntegratedSecurityOnly') AS [IsIntegratedSecurityOnly],
SERVERPROPERTY('FilestreamConfiguredLevel') AS [FilestreamConfiguredLevel],
SERVERPROPERTY('IsHadrEnabled') AS [IsHadrEnabled], 
SERVERPROPERTY('HadrManagerStatus') AS [HadrManagerStatus],
SERVERPROPERTY('InstanceDefaultDataPath') AS [InstanceDefaultDataPath],
SERVERPROPERTY('InstanceDefaultLogPath') AS [InstanceDefaultLogPath],
SERVERPROPERTY('BuildClrVersion') AS [Build CLR Version],
SERVERPROPERTY('IsXTPSupported') AS [IsXTPSupported],
SERVERPROPERTY('IsPolybaseInstalled') AS [IsPolybaseInstalled],				-- New for SQL Server 2016
SERVERPROPERTY('IsAdvancedAnalyticsInstalled') AS [IsRServicesInstalled];	-- New for SQL Server 2016
]]></Query>
    <!--//////
   
// This can help you determine the exact core counts used by SQL Server and whether HT is enabled or not
// It can also help you confirm your SQL Server licensing model
// Be on the lookout for this message "using 20 logical processors based on SQL Server licensing" 
// (when you have more than 20 logical cores) which means grandfathered Server/CAL licensing
// This query will return no results if your error log has been recycled since the instance was last started



// Get selected server properties (Query 3) (Server Properties)-->
    <Query id="3" name="Server Properties" description="Get selected server properties" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT SERVERPROPERTY('MachineName') AS [MachineName], 
SERVERPROPERTY('ServerName') AS [ServerName],  
SERVERPROPERTY('InstanceName') AS [Instance], 
SERVERPROPERTY('IsClustered') AS [IsClustered], 
SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS [ComputerNamePhysicalNetBIOS], 
SERVERPROPERTY('Edition') AS [Edition], 
SERVERPROPERTY('ProductLevel') AS [ProductLevel],				-- What servicing branch (RTM/SP/CU)
SERVERPROPERTY('ProductUpdateLevel') AS [ProductUpdateLevel],	-- Within a servicing branch, what CU# is applied
SERVERPROPERTY('ProductVersion') AS [ProductVersion],
SERVERPROPERTY('ProductMajorVersion') AS [ProductMajorVersion], 
SERVERPROPERTY('ProductMinorVersion') AS [ProductMinorVersion], 
SERVERPROPERTY('ProductBuild') AS [ProductBuild], 
SERVERPROPERTY('ProductBuildType') AS [ProductBuildType],			  -- Is this a GDR or OD hotfix (NULL if on a CU build)
SERVERPROPERTY('ProductUpdateReference') AS [ProductUpdateReference], -- KB article number that is applicable for this build
SERVERPROPERTY('ProcessID') AS [ProcessID],
SERVERPROPERTY('Collation') AS [Collation], 
SERVERPROPERTY('IsFullTextInstalled') AS [IsFullTextInstalled], 
SERVERPROPERTY('IsIntegratedSecurityOnly') AS [IsIntegratedSecurityOnly],
SERVERPROPERTY('FilestreamConfiguredLevel') AS [FilestreamConfiguredLevel],
SERVERPROPERTY('IsHadrEnabled') AS [IsHadrEnabled], 
SERVERPROPERTY('HadrManagerStatus') AS [HadrManagerStatus],
SERVERPROPERTY('InstanceDefaultDataPath') AS [InstanceDefaultDataPath],
SERVERPROPERTY('InstanceDefaultLogPath') AS [InstanceDefaultLogPath],
SERVERPROPERTY('BuildClrVersion') AS [Build CLR Version],
SERVERPROPERTY('IsXTPSupported') AS [IsXTPSupported],
SERVERPROPERTY('IsPolybaseInstalled') AS [IsPolybaseInstalled],				-- New for SQL Server 2016
SERVERPROPERTY('IsAdvancedAnalyticsInstalled') AS [IsRServicesInstalled];	-- New for SQL Server 2016
]]></Query>
    <!--//////
   
// Cumulative wait stats are not as useful on an idle instance that is not under load or performance pressure

// SQL Server Wait Types Library (Paul Randal)
// https://www.sqlskills.com/help/waits/

// The SQL Server Wait Type Repository
// http://blogs.msdn.com/b/psssql/archive/2009/11/03/the-sql-server-wait-type-repository.aspx

// Wait statistics, or please tell me where it hurts
// http://www.sqlskills.com/blogs/paul/wait-statistics-or-please-tell-me-where-it-hurts/

// SQL Server 2005 Performance Tuning using the Waits and Queues
// http://technet.microsoft.com/en-us/library/cc966413.aspx

// sys.dm_os_wait_stats (Transact-SQL)
// http://msdn.microsoft.com/en-us/library/ms179984(v=sql.105).aspx



// Signal Waits for instance  (Query 22) (Signal Waits)-->
    <Query id="22" name="Signal Waits" description="Signal Waits for instance" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT CAST(100.0 * SUM(signal_wait_time_ms) / SUM (wait_time_ms) AS NUMERIC(20,2)) AS [% Signal (CPU) Waits],
CAST(100.0 * SUM(wait_time_ms - signal_wait_time_ms) / SUM (wait_time_ms) AS NUMERIC(20,2)) AS [% Resource Waits]
FROM sys.dm_os_wait_stats WITH (NOLOCK)
WHERE wait_type NOT IN (
        N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP',
		N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE',
        N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE',
        N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE',
		N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE',
        N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX',
        N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', 
		N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE',
        N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', N'ONDEMAND_TASK_QUEUE',
        N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
        N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH',
		N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP',
		N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY',
        N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK',
        N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP',
		N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES',
		N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT',
		N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'XE_DISPATCHER_JOIN',
        N'XE_DISPATCHER_WAIT', N'XE_TIMER_EVENT') OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Cumulative wait stats are not as useful on an idle instance that is not under load or performance pressure

// SQL Server Wait Types Library (Paul Randal)
// https://www.sqlskills.com/help/waits/

// The SQL Server Wait Type Repository
// http://blogs.msdn.com/b/psssql/archive/2009/11/03/the-sql-server-wait-type-repository.aspx

// Wait statistics, or please tell me where it hurts
// http://www.sqlskills.com/blogs/paul/wait-statistics-or-please-tell-me-where-it-hurts/

// SQL Server 2005 Performance Tuning using the Waits and Queues
// http://technet.microsoft.com/en-us/library/cc966413.aspx

// sys.dm_os_wait_stats (Transact-SQL)
// http://msdn.microsoft.com/en-us/library/ms179984(v=sql.105).aspx




// Signal Waits for instance  (Query 28) (Signal Waits)-->
    <Query id="28" name="Signal Waits" description="Signal Waits for instance" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT CAST(100.0 * SUM(signal_wait_time_ms) / SUM (wait_time_ms) AS NUMERIC(20,2)) AS [% Signal (CPU) Waits],
CAST(100.0 * SUM(wait_time_ms - signal_wait_time_ms) / SUM (wait_time_ms) AS NUMERIC(20,2)) AS [% Resource Waits]
FROM sys.dm_os_wait_stats WITH (NOLOCK)
WHERE wait_type NOT IN (
        N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP',
		N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE',
        N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE',
        N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE',
		N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE',
        N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX',
        N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', 
		N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE',
        N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', N'ONDEMAND_TASK_QUEUE',
        N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
        N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH',
		N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP',
		N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY',
        N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK',
        N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP',
		N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES',
		N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT',
		N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'XE_DISPATCHER_JOIN',
        N'XE_DISPATCHER_WAIT', N'XE_TIMER_EVENT') OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Cumulative wait stats are not as useful on an idle instance that is not under load or performance pressure

// SQL Server Wait Types Library (Paul Randal)
// https://www.sqlskills.com/help/waits/

// The SQL Server Wait Type Repository
// http://blogs.msdn.com/b/psssql/archive/2009/11/03/the-sql-server-wait-type-repository.aspx

// Wait statistics, or please tell me where it hurts
// http://www.sqlskills.com/blogs/paul/wait-statistics-or-please-tell-me-where-it-hurts/

// SQL Server 2005 Performance Tuning using the Waits and Queues
// http://technet.microsoft.com/en-us/library/cc966413.aspx

// sys.dm_os_wait_stats (Transact-SQL)
// http://msdn.microsoft.com/en-us/library/ms179984(v=sql.105).aspx




// Signal Waits for instance  (Query 24) (Signal Waits)-->
    <Query id="24" name="Signal Waits" description="Signal Waits for instance" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT CAST(100.0 * SUM(signal_wait_time_ms) / SUM (wait_time_ms) AS NUMERIC(20,2)) AS [% Signal (CPU) Waits],
CAST(100.0 * SUM(wait_time_ms - signal_wait_time_ms) / SUM (wait_time_ms) AS NUMERIC(20,2)) AS [% Resource Waits]
FROM sys.dm_os_wait_stats WITH (NOLOCK)
WHERE wait_type NOT IN (
        N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP',
		N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE',
        N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE',
        N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE',
		N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE',
        N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX',
        N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', 
		N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE',
        N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', N'ONDEMAND_TASK_QUEUE',
        N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
        N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH',
		N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP',
		N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY',
        N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK',
        N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP',
		N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES',
		N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT',
		N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'XE_DISPATCHER_JOIN',
        N'XE_DISPATCHER_WAIT', N'XE_TIMER_EVENT') OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you which cached stored procedures are called the most often
// This helps you characterize and baseline your workload


// Top Cached SPs By Avg Elapsed Time (SQL 2005)  (Query 34) (SP Avg Elapsed Time)-->
    <Query id="34" name="SP Avg Elapsed Time" description="Top Cached SPs By Avg Elapsed Time (SQL 2005)" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT TOP(25) OBJECT_NAME(objectid, dbid) AS [SP Name], qt.[text] AS [SP Text],  
ISNULL(qs.total_elapsed_time/qs.execution_count, 0) AS [AvgElapsedTime], 
qs.execution_count AS [Execution Count], qs.total_worker_time AS [TotalWorkerTime], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime],
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.creation_time, GETDATE()), 0) AS [Calls/Minute],
qs.max_logical_reads, qs.max_logical_writes, 
DATEDIFF(Minute, qs.creation_time, GETDATE()) AS [Age in Cache]
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.[sql_handle]) AS qt
WHERE qt.[dbid] = DB_ID() 
ORDER BY qs.total_elapsed_time/qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you which cached stored procedures are called the most often
// This helps you characterize and baseline your workload


// Top Cached SPs By Avg Elapsed Time (SQL 2008 R2)  (Query 44) (SP Avg Elapsed Time) -->
    <Query id="44" name="SP Avg Elapsed Time" description="Top Cached SPs By Avg Elapsed Time (SQL 2008 R2)" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time], 
qs.total_elapsed_time, qs.execution_count, ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, 
GETDATE()), 0) AS [Calls/Minute], qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], 
qs.total_worker_time AS [TotalWorkerTime], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
ORDER BY avg_elapsed_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you which cached stored procedures are called the most often
// This helps you characterize and baseline your workload


// Top Cached SPs By Avg Elapsed Time (SQL 2008)  (Query 40) (SP Avg Elapsed Time)-->
    <Query id="40" name="SP Avg Elapsed Time" description="Top Cached SPs By Avg Elapsed Time (SQL 2008)" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time], 
qs.total_elapsed_time, qs.execution_count, ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, 
GETDATE()), 0) AS [Calls/Minute], qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], 
qs.total_worker_time AS [TotalWorkerTime], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
ORDER BY avg_elapsed_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you which cached stored procedures are called the most often
// This helps you characterize and baseline your workload


// Top Cached SPs By Avg Elapsed Time (Query 47) (SP Avg Elapsed Time)-->
    <Query id="47" name="SP Avg Elapsed Time" description="Top Cached SPs By Avg Elapsed Time" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.min_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time], 
qs.max_elapsed_time, qs.last_elapsed_time, qs.total_elapsed_time, qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], 
qs.total_worker_time AS [TotalWorkerTime], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY avg_elapsed_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you which cached stored procedures are called the most often
// This helps you characterize and baseline your workload


// Top Cached SPs By Avg Elapsed Time (Query 53) (SP Avg Elapsed Time)-->
    <Query id="53" name="SP Avg Elapsed Time" description="Top Cached SPs By Avg Elapsed Time" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.min_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time], 
qs.max_elapsed_time, qs.last_elapsed_time, qs.total_elapsed_time, qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], 
qs.total_worker_time AS [TotalWorkerTime], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY avg_elapsed_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you which cached stored procedures are called the most often
// This helps you characterize and baseline your workload


// Top Cached SPs By Avg Elapsed Time (Query 55) (SP Avg Elapsed Time)-->
    <Query id="55" name="SP Avg Elapsed Time" description="Top Cached SPs By Avg Elapsed Time" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.min_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time], 
qs.max_elapsed_time, qs.last_elapsed_time, qs.total_elapsed_time, qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], 
qs.total_worker_time AS [TotalWorkerTime], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY avg_elapsed_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you which cached stored procedures are called the most often
// This helps you characterize and baseline your workload


// Top Cached SPs By Avg Elapsed Time (Query 55) (SP Avg Elapsed Time)-->
    <Query id="55" name="SP Avg Elapsed Time" description="Top Cached SPs By Avg Elapsed Time" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.min_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time], 
qs.max_elapsed_time, qs.last_elapsed_time, qs.total_elapsed_time, qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], 
qs.total_worker_time AS [TotalWorkerTime], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY avg_elapsed_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find long-running cached stored procedures that
// may be easy to optimize with standard query tuning techniques


// Top Cached SPs By Avg Elapsed Time with execution time variability   (Query 45) (SP Avg Elapsed Variable Time)-->
    <Query id="45" name="SP Avg Elapsed Variable Time" description="Top Cached SPs By Avg Elapsed Time with execution time variability" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.execution_count, qs.min_elapsed_time,
qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time],
qs.max_elapsed_time, qs.last_elapsed_time,  qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
ORDER BY avg_elapsed_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find long-running cached stored procedures that
// may be easy to optimize with standard query tuning techniques


// Top Cached SPs By Avg Elapsed Time with execution time variability   (Query 41) (SP Avg Elapsed Variable Time)-->
    <Query id="41" name="SP Avg Elapsed Variable Time" description="Top Cached SPs By Avg Elapsed Time with execution time variability" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.execution_count, qs.min_elapsed_time,
qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time],
qs.max_elapsed_time, qs.last_elapsed_time,  qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
ORDER BY avg_elapsed_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you characterize your workload better from an I/O perspective
// It helps you determine whether you has an OLTP or DW/DSS type of workload



// Cached SP's By Execution Count (SQL 2005)  (Query 33) (SP Execution Counts)-->
    <Query id="33" name="SP Execution Counts" description="Cached SP's By Execution Count (SQL 2005)" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT TOP(25) OBJECT_NAME(objectid, dbid) AS [SP Name], qt.[text] AS [SP Text], 
qs.execution_count AS [Execution Count],  
qs.execution_count/DATEDIFF(Minute, qs.creation_time, GETDATE()) AS [Calls/Minute],
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime],
qs.total_worker_time AS [TotalWorkerTime],
qs.total_elapsed_time/qs.execution_count AS [AvgElapsedTime],
qs.max_logical_reads, qs.max_logical_writes, qs.total_physical_reads, 
DATEDIFF(Minute, qs.creation_time, GetDate()) AS [Age in Cache]
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.[sql_handle]) AS qt
WHERE qt.[dbid] = DB_ID() 
ORDER BY qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Uses several new rows returned columns to help troubleshoot performance problems


// Top Cached SPs By Execution Count (SQL 2008 R2) (Query 43) (SP Execution Counts)-->
    <Query id="43" name="SP Execution Counts" description="Top Cached SPs By Execution Count (SQL 2008 R2)" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT TOP(100) p.name AS [SP Name], qs.execution_count,
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], qs.total_worker_time AS [TotalWorkerTime],  
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time],
qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
ORDER BY qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// Look at non-stored procedure queries


// Top Cached SPs By Execution Count (SQL 2008) (Query 39) (SP Execution Counts)-->
    <Query id="39" name="SP Execution Counts" description="Top Cached SPs By Execution Count (SQL 2008)" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT TOP(100) p.name AS [SP Name], qs.execution_count,
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], qs.total_worker_time AS [TotalWorkerTime],  
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time],
qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
ORDER BY qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// Queries 46 through 51 are the "Bad Man List"
// Top Cached SPs By Execution Count (Query 46) (SP Execution Counts)-->
    <Query id="46" name="SP Execution Counts" description="Top Cached SPs By Execution Count" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT TOP(100) p.name AS [SP Name], qs.execution_count,
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], qs.total_worker_time AS [TotalWorkerTime],  
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time],
qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// Queries 52 through 57 are the "Bad Man List"
// Top Cached SPs By Execution Count (Query 52) (SP Execution Counts)-->
    <Query id="52" name="SP Execution Counts" description="Top Cached SPs By Execution Count" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT TOP(100) p.name AS [SP Name], qs.execution_count,
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], qs.total_worker_time AS [TotalWorkerTime],  
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time],
qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// Queries 54 through 59 are the "Bad Man List"
// Top Cached SPs By Execution Count (Query 54) (SP Execution Counts)-->
    <Query id="54" name="SP Execution Counts" description="Top Cached SPs By Execution Count" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT TOP(100) p.name AS [SP Name], qs.execution_count,
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], qs.total_worker_time AS [TotalWorkerTime],  
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time],
qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// Queries 54 through 59 are the "Bad Man List"
// Top Cached SPs By Execution Count (Query 54) (SP Execution Counts)-->
    <Query id="54" name="SP Execution Counts" description="Top Cached SPs By Execution Count" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT TOP(100) p.name AS [SP Name], qs.execution_count,
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], qs.total_worker_time AS [TotalWorkerTime],  
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time],
qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a CPU perspective
// You should look at this if you see signs of CPU pressure

// Cached SP's By Logical Reads (SQL 2005) Logical reads relate to memory pressure  (Query 36) (SP Logical Reads)-->
    <Query id="36" name="SP Logical Reads" description="Cached SP's By Logical Reads (SQL 2005) Logical reads relate to memory pressure" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT TOP(25) OBJECT_NAME(objectid, dbid) AS [SP Name], qt.[text] AS [SP Text],  
total_logical_reads, qs.max_logical_reads,
total_logical_reads/qs.execution_count AS [AvgLogicalReads], qs.execution_count AS [Execution Count], 
qs.execution_count/DATEDIFF(Minute, qs.creation_time, GETDATE()) AS [Calls/Minute], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime],
qs.total_worker_time AS [TotalWorkerTime],
qs.total_elapsed_time/qs.execution_count AS [AvgElapsedTime],
qs.total_logical_writes,
 qs.max_logical_writes, qs.total_physical_reads, 
DATEDIFF(Minute, qs.creation_time, GETDATE()) AS [Age in Cache]
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.[sql_handle]) AS qt
WHERE qt.[dbid] = DB_ID() 
ORDER BY total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a CPU perspective
// You should look at this if you see signs of CPU pressure


// Top Cached SPs By Total Logical Reads (SQL 2008). Logical reads relate to memory pressure  (Query 43) (SP Logical Reads)-->
    <Query id="43" name="SP Logical Reads" description="Top Cached SPs By Total Logical Reads (SQL 2008). Logical reads relate to memory pressure" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_logical_reads AS [TotalLogicalReads], 
qs.total_logical_reads/qs.execution_count AS [AvgLogicalReads],qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute], 
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
ORDER BY qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a CPU perspective
// You should look at this if you see signs of CPU pressure


// Top Cached SPs By Total Logical Reads. Logical reads relate to memory pressure  (Query 49) (SP Logical Reads)-->
    <Query id="49" name="SP Logical Reads" description="Top Cached SPs By Total Logical Reads. Logical reads relate to memory pressure" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_logical_reads AS [TotalLogicalReads], 
qs.total_logical_reads/qs.execution_count AS [AvgLogicalReads],qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute], 
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a CPU perspective
// You should look at this if you see signs of CPU pressure


// Top Cached SPs By Total Logical Reads. Logical reads relate to memory pressure  (Query 55) (SP Logical Reads)-->
    <Query id="55" name="SP Logical Reads" description="Top Cached SPs By Total Logical Reads. Logical reads relate to memory pressure" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_logical_reads AS [TotalLogicalReads], 
qs.total_logical_reads/qs.execution_count AS [AvgLogicalReads],qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute], 
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a CPU perspective
// You should look at this if you see signs of CPU pressure


// Top Cached SPs By Total Logical Reads. Logical reads relate to memory pressure  (Query 57) (SP Logical Reads)-->
    <Query id="57" name="SP Logical Reads" description="Top Cached SPs By Total Logical Reads. Logical reads relate to memory pressure" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_logical_reads AS [TotalLogicalReads], 
qs.total_logical_reads/qs.execution_count AS [AvgLogicalReads],qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute], 
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a CPU perspective
// You should look at this if you see signs of CPU pressure


// Top Cached SPs By Total Logical Reads. Logical reads relate to memory pressure  (Query 57) (SP Logical Reads)-->
    <Query id="57" name="SP Logical Reads" description="Top Cached SPs By Total Logical Reads. Logical reads relate to memory pressure" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_logical_reads AS [TotalLogicalReads], 
qs.total_logical_reads/qs.execution_count AS [AvgLogicalReads],qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute], 
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a read I/O perspective
// You should look at this if you see signs of I/O pressure or of memory pressure


// Top Cached SPs By Total Logical Writes (SQL 2005)  (Query 38) (SP Logical Writes)
// Logical writes relate to both memory and disk I/O pressure -->
    <Query id="38" name="SP Logical Writes" description="Top Cached SPs By Total Logical Writes (SQL 2005)" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT TOP(25) OBJECT_NAME(objectid, dbid) AS [SP Name], qt.[text] AS [SP Text],  
qs.total_logical_writes, qs.max_logical_writes,
qs.total_logical_writes/qs.execution_count AS [AvgLogicalWrites], qs.execution_count AS [Execution Count], 
qs.execution_count/DATEDIFF(Minute, qs.creation_time, GETDATE()) AS [Calls/Minute], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime],
qs.total_worker_time AS [TotalWorkerTime],
qs.total_elapsed_time/qs.execution_count AS [AvgElapsedTime],
qs.total_physical_reads, 
DATEDIFF(Minute, qs.creation_time, GETDATE()) AS [Age in Cache]
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.[sql_handle]) AS qt
WHERE qt.[dbid] = DB_ID()
AND qs.total_logical_writes > 0 
ORDER BY total_logical_writes DESC OPTION (RECOMPILE);
]]></Query>
    <!--// Top Cached SPs By Total Logical Writes (SQL 2008 R2)  (Query 49) (SP Logical Writes)
   // Logical writes relate to both memory and disk I/O pressure -->
    <Query id="49" name="SP Logical Writes" description="Top Cached SPs By Total Logical Writes (SQL 2008 R2)" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_logical_writes AS [TotalLogicalWrites], 
qs.total_logical_writes/qs.execution_count AS [AvgLogicalWrites], qs.execution_count,
ISNULL(qs.execution_count/DATEDIFF(Second, qs.cached_time, GETDATE()), 0) AS [Calls/Second],
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time], 
qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND qs.total_logical_writes > 0
ORDER BY qs.total_logical_writes DESC OPTION (RECOMPILE);
]]></Query>
    <!--// Top Cached SPs By Total Logical Writes (SQL 2008)  (Query 45) (SP Logical Writes) 
   // Logical writes relate to both memory and disk I/O pressure -->
    <Query id="45" name="SP Logical Writes" description="Top Cached SPs By Total Logical Writes (SQL 2008)" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_logical_writes AS [TotalLogicalWrites], 
qs.total_logical_writes/qs.execution_count AS [AvgLogicalWrites], qs.execution_count,
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time], 
qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND qs.total_logical_writes > 0
ORDER BY qs.total_logical_writes DESC OPTION (RECOMPILE);
]]></Query>
    <!--// Top Cached SPs By Total Logical Writes (Query 51) (SP Logical Writes)
   // Logical writes relate to both memory and disk I/O pressure -->
    <Query id="51" name="SP Logical Writes" description="Top Cached SPs By Total Logical Writes" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_logical_writes AS [TotalLogicalWrites], 
qs.total_logical_writes/qs.execution_count AS [AvgLogicalWrites], qs.execution_count,
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time], 
qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND qs.total_logical_writes > 0
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.total_logical_writes DESC OPTION (RECOMPILE);
]]></Query>
    <!--// Top Cached SPs By Total Logical Writes (Query 57) (SP Logical Writes)
   // Logical writes relate to both memory and disk I/O pressure -->
    <Query id="57" name="SP Logical Writes" description="Top Cached SPs By Total Logical Writes" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_logical_writes AS [TotalLogicalWrites], 
qs.total_logical_writes/qs.execution_count AS [AvgLogicalWrites], qs.execution_count,
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count AS [avg_elapsed_time], 
qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND qs.total_logical_writes > 0
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.total_logical_writes DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a memory perspective
// You should look at this if you see signs of memory pressure


// Cached SP's By Physical Reads (SQL 2005) Physical reads relate to read I/O pressure  (Query 37) (SP Physical Reads)-->
    <Query id="37" name="SP Physical Reads" description="Cached SP's By Physical Reads (SQL 2005) Physical reads relate to read I/O pressure" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT TOP(25) OBJECT_NAME(objectid, dbid) AS [SP Name], qt.[text] AS [SP Text],  
qs.total_physical_reads, total_logical_reads, qs.max_logical_reads,
total_logical_reads/qs.execution_count AS [AvgLogicalReads], qs.execution_count AS [Execution Count], 
qs.execution_count/DATEDIFF(Minute, qs.creation_time, GETDATE()) AS [Calls/Minute], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime],
qs.total_worker_time AS [TotalWorkerTime],
qs.total_elapsed_time/qs.execution_count AS [AvgElapsedTime],
DATEDIFF(Minute, qs.creation_time, GETDATE()) AS [Age in Cache]
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.[sql_handle]) AS qt
WHERE qt.[dbid] = DB_ID() -- Filter by current database
AND qs.total_physical_reads > 0
ORDER BY qs.total_physical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a memory perspective
// You should look at this if you see signs of memory pressure


// Top Cached SPs By Total Physical Reads (SQL 2008 R2). Physical reads relate to disk I/O pressure  (Query 48) (SP Physical Reads)-->
    <Query id="48" name="SP Physical Reads" description="Top Cached SPs By Total Physical Reads (SQL 2008 R2). Physical reads relate to disk I/O pressure" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name],qs.total_physical_reads AS [TotalPhysicalReads], 
qs.total_physical_reads/qs.execution_count AS [AvgPhysicalReads], qs.execution_count, 
qs.total_logical_reads,qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time 
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND qs.total_physical_reads > 0
ORDER BY qs.total_physical_reads DESC, qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a memory perspective
// You should look at this if you see signs of memory pressure


// Top Cached SPs By Total Physical Reads (SQL 2008). Physical reads relate to disk I/O pressure  (Query 44) (SP Physical Reads)-->
    <Query id="44" name="SP Physical Reads" description="Top Cached SPs By Total Physical Reads (SQL 2008). Physical reads relate to disk I/O pressure" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name],qs.total_physical_reads AS [TotalPhysicalReads], 
qs.total_physical_reads/qs.execution_count AS [AvgPhysicalReads], qs.execution_count, 
qs.total_logical_reads,qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time 
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND qs.total_physical_reads > 0
ORDER BY qs.total_physical_reads DESC, qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a memory perspective
// You should look at this if you see signs of memory pressure


// Top Cached SPs By Total Physical Reads. Physical reads relate to disk read I/O pressure  (Query 50) (SP Physical Reads)-->
    <Query id="50" name="SP Physical Reads" description="Top Cached SPs By Total Physical Reads. Physical reads relate to disk read I/O pressure" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name],qs.total_physical_reads AS [TotalPhysicalReads], 
qs.total_physical_reads/qs.execution_count AS [AvgPhysicalReads], qs.execution_count, 
qs.total_logical_reads,qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time 
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND qs.total_physical_reads > 0
ORDER BY qs.total_physical_reads DESC, qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a memory perspective
// You should look at this if you see signs of memory pressure


// Top Cached SPs By Total Physical Reads. Physical reads relate to disk read I/O pressure  (Query 56) (SP Physical Reads)-->
    <Query id="56" name="SP Physical Reads" description="Top Cached SPs By Total Physical Reads. Physical reads relate to disk read I/O pressure" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name],qs.total_physical_reads AS [TotalPhysicalReads], 
qs.total_physical_reads/qs.execution_count AS [AvgPhysicalReads], qs.execution_count, 
qs.total_logical_reads,qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time 
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND qs.total_physical_reads > 0
ORDER BY qs.total_physical_reads DESC, qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a memory perspective
// You should look at this if you see signs of memory pressure


// Top Cached SPs By Total Physical Reads. Physical reads relate to disk read I/O pressure  (Query 58) (SP Physical Reads)-->
    <Query id="58" name="SP Physical Reads" description="Top Cached SPs By Total Physical Reads. Physical reads relate to disk read I/O pressure" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name],qs.total_physical_reads AS [TotalPhysicalReads], 
qs.total_physical_reads/qs.execution_count AS [AvgPhysicalReads], qs.execution_count, 
qs.total_logical_reads,qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time 
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND qs.total_physical_reads > 0
ORDER BY qs.total_physical_reads DESC, qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a memory perspective
// You should look at this if you see signs of memory pressure


// Top Cached SPs By Total Physical Reads. Physical reads relate to disk read I/O pressure  (Query 58) (SP Physical Reads)-->
    <Query id="58" name="SP Physical Reads" description="Top Cached SPs By Total Physical Reads. Physical reads relate to disk read I/O pressure" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name],qs.total_physical_reads AS [TotalPhysicalReads], 
qs.total_physical_reads/qs.execution_count AS [AvgPhysicalReads], qs.execution_count, 
qs.total_logical_reads,qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time 
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND qs.total_physical_reads > 0
ORDER BY qs.total_physical_reads DESC, qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find long-running cached stored procedures that
// may be easy to optimize with standard query tuning techniques

// Cached SP's By Worker Time (SQL 2005) Worker time relates to CPU cost  (Query 35) (SP Worker Time)-->
    <Query id="35" name="SP Worker Time" description="Cached SP's By Worker Time (SQL 2005) Worker time relates to CPU cost" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT TOP(25) OBJECT_NAME(objectid, dbid) AS [SP Name], qt.[text] AS [SP Text], 
qs.total_worker_time AS [TotalWorkerTime], qs.total_worker_time/qs.execution_count AS [AvgWorkerTime],
qs.execution_count AS [Execution Count], 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.creation_time, GETDATE()), 0) AS [Calls/Minute],
ISNULL(qs.total_elapsed_time/qs.execution_count, 0) AS [AvgElapsedTime], 
qs.max_logical_reads, qs.max_logical_writes, 
DATEDIFF(Minute, qs.creation_time, GETDATE()) AS [Age in Cache]
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.[sql_handle]) AS qt
WHERE qt.[dbid] = DB_ID() 
ORDER BY qs.total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you some interesting information about the variability in the
// execution time of your cached stored procedures, which is useful for tuning


// Top Cached SPs By Total Worker time (SQL 2008 R2). Worker time relates to CPU cost  (Query 46) (SP Worker Time)-->
    <Query id="46" name="SP Worker Time" description="Top Cached SPs By Total Worker time (SQL 2008 R2). Worker time relates to CPU cost" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_worker_time AS [TotalWorkerTime], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
ORDER BY qs.total_worker_time DESC OPTION (RECOMPILE);

-- This helps you find the most expensive cached stored procedures from a CPU perspective
-- You should look at this if you see signs of CPU pressure


-- Top Cached SPs By Total Logical Reads (SQL 2008 R2). Logical reads relate to memory pressure  (Query 47) (SP Logical Reads)
SELECT TOP(25) p.name AS [SP Name], qs.total_logical_reads AS [TotalLogicalReads], 
qs.total_logical_reads/qs.execution_count AS [AvgLogicalReads],qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute], 
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
ORDER BY qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you some interesting information about the variability in the
// execution time of your cached stored procedures, which is useful for tuning


// Top Cached SPs By Total Worker time (SQL 2008). Worker time relates to CPU cost  (Query 42) (SP Worker Time)-->
    <Query id="42" name="SP Worker Time" description="Top Cached SPs By Total Worker time (SQL 2008). Worker time relates to CPU cost" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_worker_time AS [TotalWorkerTime], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
ORDER BY qs.total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find high average elapsed time cached stored procedures that
// may be easy to optimize with standard query tuning techniques



// Top Cached SPs By Total Worker time. Worker time relates to CPU cost  (Query 48) (SP Worker Time)-->
    <Query id="48" name="SP Worker Time" description="Top Cached SPs By Total Worker time. Worker time relates to CPU cost" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_worker_time AS [TotalWorkerTime], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find high average elapsed time cached stored procedures that
// may be easy to optimize with standard query tuning techniques



// Top Cached SPs By Total Worker time. Worker time relates to CPU cost  (Query 54) (SP Worker Time)-->
    <Query id="54" name="SP Worker Time" description="Top Cached SPs By Total Worker time. Worker time relates to CPU cost" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_worker_time AS [TotalWorkerTime], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find high average elapsed time cached stored procedures that
// may be easy to optimize with standard query tuning techniques



// Top Cached SPs By Total Worker time. Worker time relates to CPU cost  (Query 56) (SP Worker Time)-->
    <Query id="56" name="SP Worker Time" description="Top Cached SPs By Total Worker time. Worker time relates to CPU cost" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_worker_time AS [TotalWorkerTime], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find high average elapsed time cached stored procedures that
// may be easy to optimize with standard query tuning techniques



// Top Cached SPs By Total Worker time. Worker time relates to CPU cost  (Query 56) (SP Worker Time)-->
    <Query id="56" name="SP Worker Time" description="Top Cached SPs By Total Worker time. Worker time relates to CPU cost" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT TOP(25) p.name AS [SP Name], qs.total_worker_time AS [TotalWorkerTime], 
qs.total_worker_time/qs.execution_count AS [AvgWorkerTime], qs.execution_count, 
ISNULL(qs.execution_count/DATEDIFF(Minute, qs.cached_time, GETDATE()), 0) AS [Calls/Minute],
qs.total_elapsed_time, qs.total_elapsed_time/qs.execution_count 
AS [avg_elapsed_time], qs.cached_time
FROM sys.procedures AS p WITH (NOLOCK)
INNER JOIN sys.dm_exec_procedure_stats AS qs WITH (NOLOCK)
ON p.[object_id] = qs.[object_id]
WHERE qs.database_id = DB_ID()
AND DATEDIFF(Minute, qs.cached_time, GETDATE()) > 0
ORDER BY qs.total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent jobs, who owns them and how they are configured
// Look for Agent jobs that are not owned by sa
// Look for jobs that have a notify_email_operator_id set to 0 (meaning no operator)
// Look for jobs that have a notify_level_email set to 0 (meaning no e-mail is ever sent)
//
// MSDN sysjobs documentation
// http://msdn.microsoft.com/en-us/library/ms189817.aspx


// Get SQL Server Agent Alert Information (Query 5) (SQL Server Agent Alerts)-->
    <Query id="5" name="SQL Server Agent Alerts" description="Get SQL Server Agent Alert Information" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT name, event_source, message_id, severity, [enabled], has_notification, 
       delay_between_responses, occurrence_count, last_occurrence_date, last_occurrence_time
FROM msdb.dbo.sysalerts WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent jobs, who owns them and how they are configured
// Look for Agent jobs that are not owned by sa
// Look for jobs that have a notify_email_operator_id set to 0 (meaning no operator)
// Look for jobs that have a notify_level_email set to 0 (meaning no e-mail is ever sent)
//
// MSDN sysjobs documentation
// http://msdn.microsoft.com/en-us/library/ms189817.aspx


// Get SQL Server Agent Alert Information (Query 5) (SQL Server Agent Alerts)-->
    <Query id="5" name="SQL Server Agent Alerts" description="Get SQL Server Agent Alert Information" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT name, event_source, message_id, severity, [enabled], has_notification, 
       delay_between_responses, occurrence_count, last_occurrence_date, last_occurrence_time
FROM msdb.dbo.sysalerts WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent jobs, who owns them and how they are configured
// Look for Agent jobs that are not owned by sa
// Look for jobs that have a notify_email_operator_id set to 0 (meaning no operator)
// Look for jobs that have a notify_level_email set to 0 (meaning no e-mail is ever sent)
//
// MSDN sysjobs documentation
// http://msdn.microsoft.com/en-us/library/ms189817.aspx


// Get SQL Server Agent Alert Information (Query 5) (SQL Server Agent Alerts)-->
    <Query id="5" name="SQL Server Agent Alerts" description="Get SQL Server Agent Alert Information" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT name, event_source, message_id, severity, [enabled], has_notification, 
       delay_between_responses, occurrence_count, last_occurrence_date, last_occurrence_time
FROM msdb.dbo.sysalerts WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent jobs, who owns them and how they are configured
// Look for Agent jobs that are not owned by sa
// Look for jobs that have a notify_email_operator_id set to 0 (meaning no operator)
// Look for jobs that have a notify_level_email set to 0 (meaning no e-mail is ever sent)
//
// MSDN sysjobs documentation
// http://msdn.microsoft.com/en-us/library/ms189817.aspx

// SQL Server Maintenance Solution
// https://ola.hallengren.com/


// Get SQL Server Agent Alert Information (Query 9) (SQL Server Agent Alerts)-->
    <Query id="9" name="SQL Server Agent Alerts" description="Get SQL Server Agent Alert Information" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT name, event_source, message_id, severity, [enabled], has_notification, 
       delay_between_responses, occurrence_count, last_occurrence_date, last_occurrence_time
FROM msdb.dbo.sysalerts WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent jobs, who owns them and how they are configured
// Look for Agent jobs that are not owned by sa
// Look for jobs that have a notify_email_operator_id set to 0 (meaning no operator)
// Look for jobs that have a notify_level_email set to 0 (meaning no e-mail is ever sent)
//
// MSDN sysjobs documentation
// http://msdn.microsoft.com/en-us/library/ms189817.aspx

// SQL Server Maintenance Solution
// https://ola.hallengren.com/


// Get SQL Server Agent Alert Information (Query 10) (SQL Server Agent Alerts)-->
    <Query id="10" name="SQL Server Agent Alerts" description="Get SQL Server Agent Alert Information" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT name, event_source, message_id, severity, [enabled], has_notification, 
       delay_between_responses, occurrence_count, last_occurrence_date, last_occurrence_time
FROM msdb.dbo.sysalerts WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent jobs, who owns them and how they are configured
// Look for Agent jobs that are not owned by sa
// Look for jobs that have a notify_email_operator_id set to 0 (meaning no operator)
// Look for jobs that have a notify_level_email set to 0 (meaning no e-mail is ever sent)
//
// MSDN sysjobs documentation
// http://msdn.microsoft.com/en-us/library/ms189817.aspx

// SQL Server Maintenance Solution
// https://ola.hallengren.com/


// Get SQL Server Agent Alert Information (Query 10) (SQL Server Agent Alerts)-->
    <Query id="10" name="SQL Server Agent Alerts" description="Get SQL Server Agent Alert Information" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT name, event_source, message_id, severity, [enabled], has_notification, 
       delay_between_responses, occurrence_count, last_occurrence_date, last_occurrence_time
FROM msdb.dbo.sysalerts WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent jobs, who owns them and how they are configured
// Look for Agent jobs that are not owned by sa
// Look for jobs that have a notify_email_operator_id set to 0 (meaning no operator)
// Look for jobs that have a notify_level_email set to 0 (meaning no e-mail is ever sent)
//
// MSDN sysjobs documentation
// http://msdn.microsoft.com/en-us/library/ms189817.aspx

// SQL Server Maintenance Solution
// https://ola.hallengren.com/


// Get SQL Server Agent Alert Information (Query 10) (SQL Server Agent Alerts)-->
    <Query id="10" name="SQL Server Agent Alerts" description="Get SQL Server Agent Alert Information" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT name, event_source, message_id, severity, [enabled], has_notification, 
       delay_between_responses, occurrence_count, last_occurrence_date, last_occurrence_time
FROM msdb.dbo.sysalerts WITH (NOLOCK)
ORDER BY name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you a lot of useful information about your instance of SQL Server,
// such as the ProcessID for SQL Server and your collation


// Get SQL Server Agent jobs and Category information (Query 4) (SQL Server Agent Jobs)-->
    <Query id="4" name="SQL Server Agent Jobs" description="Get SQL Server Agent jobs and Category information" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT sj.name AS [JobName], sj.[description] AS [JobDescription], SUSER_SNAME(sj.owner_sid) AS [JobOwner],
sj.date_created, sj.[enabled], sj.notify_email_operator_id, sj.notify_level_email, sc.name AS [CategoryName],
js.next_run_date, js.next_run_time
FROM msdb.dbo.sysjobs AS sj WITH (NOLOCK)
INNER JOIN msdb.dbo.syscategories AS sc WITH (NOLOCK)
ON sj.category_id = sc.category_id
LEFT OUTER JOIN msdb.dbo.sysjobschedules AS js WITH (NOLOCK)
ON sj.job_id = js.job_id
ORDER BY sj.name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you a lot of useful information about your instance of SQL Server,
// such as the ProcessID for SQL Server and your collation


// Get SQL Server Agent jobs and Category information (Query 4) (SQL Server Agent Jobs)-->
    <Query id="4" name="SQL Server Agent Jobs" description="Get SQL Server Agent jobs and Category information" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT sj.name AS [JobName], sj.[description] AS [JobDescription], SUSER_SNAME(sj.owner_sid) AS [JobOwner],
sj.date_created, sj.[enabled], sj.notify_email_operator_id, sj.notify_level_email, sc.name AS [CategoryName],
js.next_run_date, js.next_run_time
FROM msdb.dbo.sysjobs AS sj WITH (NOLOCK)
INNER JOIN msdb.dbo.syscategories AS sc WITH (NOLOCK)
ON sj.category_id = sc.category_id
LEFT OUTER JOIN msdb.dbo.sysjobschedules AS js WITH (NOLOCK)
ON sj.job_id = js.job_id
ORDER BY sj.name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This gives you a lot of useful information about your instance of SQL Server,
// such as the ProcessID for SQL Server and your collation


// Get SQL Server Agent jobs and Category information (Query 4) (SQL Server Agent Jobs)-->
    <Query id="4" name="SQL Server Agent Jobs" description="Get SQL Server Agent jobs and Category information" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT sj.name AS [JobName], sj.[description] AS [JobDescription], SUSER_SNAME(sj.owner_sid) AS [JobOwner],
sj.date_created, sj.[enabled], sj.notify_email_operator_id, sj.notify_level_email, sc.name AS [CategoryName],
js.next_run_date, js.next_run_time
FROM msdb.dbo.sysjobs AS sj WITH (NOLOCK)
INNER JOIN msdb.dbo.syscategories AS sc WITH (NOLOCK)
ON sj.category_id = sc.category_id
LEFT OUTER JOIN msdb.dbo.sysjobschedules AS js WITH (NOLOCK)
ON sj.job_id = js.job_id
ORDER BY sj.name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you the account being used for the SQL Server Service and the SQL Agent Service
// Shows the process_id, when they were last started, and their current status
// Shows whether you are running on a failover cluster instance


// Get SQL Server Agent jobs and Category information (Query 8) (SQL Server Agent Jobs)-->
    <Query id="8" name="SQL Server Agent Jobs" description="Get SQL Server Agent jobs and Category information" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT sj.name AS [JobName], sj.[description] AS [JobDescription], SUSER_SNAME(sj.owner_sid) AS [JobOwner],
sj.date_created, sj.[enabled], sj.notify_email_operator_id, sj.notify_level_email, sc.name AS [CategoryName],
js.next_run_date, js.next_run_time
FROM msdb.dbo.sysjobs AS sj WITH (NOLOCK)
INNER JOIN msdb.dbo.syscategories AS sc WITH (NOLOCK)
ON sj.category_id = sc.category_id
LEFT OUTER JOIN msdb.dbo.sysjobschedules AS js WITH (NOLOCK)
ON sj.job_id = js.job_id
ORDER BY sj.name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you the account being used for the SQL Server Service and the SQL Agent Service
// Shows the process_id, when they were last started, and their current status
// Shows whether you are running on a failover cluster instance


// Get SQL Server Agent jobs and Category information (Query 9) (SQL Server Agent Jobs)-->
    <Query id="9" name="SQL Server Agent Jobs" description="Get SQL Server Agent jobs and Category information" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT sj.name AS [JobName], sj.[description] AS [JobDescription], SUSER_SNAME(sj.owner_sid) AS [JobOwner],
sj.date_created, sj.[enabled], sj.notify_email_operator_id, sj.notify_level_email, sc.name AS [CategoryName],
js.next_run_date, js.next_run_time
FROM msdb.dbo.sysjobs AS sj WITH (NOLOCK)
INNER JOIN msdb.dbo.syscategories AS sc WITH (NOLOCK)
ON sj.category_id = sc.category_id
LEFT OUTER JOIN msdb.dbo.sysjobschedules AS js WITH (NOLOCK)
ON sj.job_id = js.job_id
ORDER BY sj.name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you the account being used for the SQL Server Service and the SQL Agent Service
// Shows the process_id, when they were last started, and their current status
// Shows whether you are running on a failover cluster instance


// Get SQL Server Agent jobs and Category information (Query 9) (SQL Server Agent Jobs)-->
    <Query id="9" name="SQL Server Agent Jobs" description="Get SQL Server Agent jobs and Category information" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT sj.name AS [JobName], sj.[description] AS [JobDescription], SUSER_SNAME(sj.owner_sid) AS [JobOwner],
sj.date_created, sj.[enabled], sj.notify_email_operator_id, sj.notify_level_email, sc.name AS [CategoryName],
js.next_run_date, js.next_run_time
FROM msdb.dbo.sysjobs AS sj WITH (NOLOCK)
INNER JOIN msdb.dbo.syscategories AS sc WITH (NOLOCK)
ON sj.category_id = sc.category_id
LEFT OUTER JOIN msdb.dbo.sysjobschedules AS js WITH (NOLOCK)
ON sj.job_id = js.job_id
ORDER BY sj.name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you the account being used for the SQL Server Service and the SQL Agent Service
// Shows the process_id, when they were last started, and their current status
// Shows whether you are running on a failover cluster instance


// Get SQL Server Agent jobs and Category information (Query 9) (SQL Server Agent Jobs)-->
    <Query id="9" name="SQL Server Agent Jobs" description="Get SQL Server Agent jobs and Category information" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT sj.name AS [JobName], sj.[description] AS [JobDescription], SUSER_SNAME(sj.owner_sid) AS [JobOwner],
sj.date_created, sj.[enabled], sj.notify_email_operator_id, sj.notify_level_email, sc.name AS [CategoryName],
js.next_run_date, js.next_run_time
FROM msdb.dbo.sysjobs AS sj WITH (NOLOCK)
INNER JOIN msdb.dbo.syscategories AS sc WITH (NOLOCK)
ON sj.category_id = sc.category_id
LEFT OUTER JOIN msdb.dbo.sysjobschedules AS js WITH (NOLOCK)
ON sj.job_id = js.job_id
ORDER BY sj.name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// SQL Server 2005 is out of mainsteam support from Microsoft
// Build 9.0.5266 was the last cumulative update


//   SQL 2005 SP2 Builds             SQL 2005 SP3 Builds            SQL 2005 SP4 Builds
// Build          Description         Build         Description     Build		   Description
// 9.0.3042        SP2 RTM			  9.0.4035        SP3 RTM
// 9.0.3161        SP2 CU1			  9.0.4207        SP3 CU1
// 9.0.3175        SP2 CU2			  9.0.4211        SP3 CU2 
// 9.0.3186        SP2 CU3			  9.0.4220       SP3 CU3         
// 9.0.3200        SP2 CU4			  9.0.4226        SP3 CU4         
// 9.0.3215        SP2 CU5			  9.0.4230		  SP3 CU5          
// 9.0.3228		   SP2 CU6			  9.0.4266        SP3 CU6        
// 9.0.3239        SP2 CU7			  9.0.4273		  SP3 CU7        
// 9.0.3257        SP2 CU8			  9.0.4285        SP3 CU8
// 9.0.3282        SP2 CU9			  9.0.4294		  SP3 CU9
// 9.0.3294		   SP2 CU10			  9.0.4305        SP3 CU10
// 9.0.3301		   SP2 CU11			  9.0.4309		  SP3 CU11  //-> 9.0.5000		SP4 RTM
// 9.0.3315        SP2 CU12           9.0.4311        SP3 CU12  //-> 9.0.5254       SP4 CU1		12/22/2010
// 9.0.3325		   SP2 CU13			  9.0.4315		  SP3 CU13
// 9.0.3328        SP2 CU14			  9.0.4317		  SP3 CU14	//-> 9.0.5259		SP4 CU2		 2/21/2011
// 9.0.3330        SP2 CU15			  9.0.4325		  SP3 CU15	//-> 9.0.5266		SP4 CU3      3/21/2011
// 9.0.3355        SP2 CU16
// 9.0.3356		   SP2 CU17



// The SQL Server 2005 builds that were released after SQL Server 2005 Service Pack 2 was released
// http://support.microsoft.com/kb/937137

// The SQL Server 2005 builds that were released after SQL Server 2005 Service Pack 3 was released
// http://support.microsoft.com/kb/960598

// The SQL Server 2005 builds that were released after SQL Server 2005 Service Pack 4 was released 
// http://support.microsoft.com/kb/2485757

// SQL Server 2005 fell out of Mainsteam Support on April 12, 2011
// This means no more Service Packs or Cumulative Updates
// SQL Server 2005 will end Extended Support on April 12, 2016 

// SQL Server 2005 Service Pack 4
// http://www.microsoft.com/en-us/download/details.aspx?id=7218



// When was SQL Server installed  (Query 2) (SQL Server Install Date)  -->
    <Query id="2" name="SQL Server Install Date" description="When was SQL Server installed" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], create_date AS [SQL Server Install Date] 
FROM sys.server_principals WITH (NOLOCK)
WHERE name = N'NT AUTHORITY\SYSTEM'
OR name = N'NT AUTHORITY\NETWORK SERVICE' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// SQL Server 2008 R2 Builds				SQL Server 2008 R2 SP1 Builds			SQL Server 2008 R2 SP2 Builds							SQL Server 2008 R2 SP3 Builds
// Build			Description				Build		Description					Build		Description									Build		Description
// 10.50.1092		August 2009 CTP2		
// 10.50.1352		November 2009 CTP3
// 10.50.1450		Release Candidate
// 10.50.1600		RTM
// 10.50.1702		RTM CU1
// 10.50.1720		RTM CU2
// 10.50.1734		RTM CU3
// 10.50.1746		RTM CU4
// 10.50.1753		RTM CU5
// 10.50.1765		RTM CU6	 //->			10.50.2500	SP1 RTM
// 10.50.1777		RTM CU7
// 10.50.1797		RTM CU8	 //->			10.50.2769  SP1 CU1
// 10.50.1804       RTM CU9  //->			10.50.2772  SP1 CU2
// 10.50.1807		RTM CU10 //->           10.50.2789  SP1 CU3
// 10.50.1809       RTM CU11 //->			10.50.2796  SP1 CU4 
// 10.50.1810		RTM CU12 //->			10.50.2806	SP1 CU5		//->			10.50.4000	SP2 RTM
// 10.50.1815		RTM CU13 //->           10.50.2811  SP1 CU6
// 10.50.1817		RTM CU14 //->			10.50.2817  SP1 CU7		//->			10.50.4260	SP2 CU1			         7/24/2012
// RTM Branch Retired        //->			10.50.2822  SP1 CU8     //->			10.50.4263  SP2 CU2                  8/31/2012   
//											10.50.2866  SP1 CU9     //->			10.50.4266  SP2 CU3					10/15/2012
//                                          10.50.2868  SP1 CU10    //->			10.50.4270  SP2 CU4					12/17/2012
//                                          10.50.2869  SP1 CU11    //->            10.50.4276  SP2 CU5				     2/18/2013
//                                          10.50.2874  SP1 CU12    //->            10.50.4279  SP2 CU6                  4/15/2013
//                                          10.50.2876  SP1 CU13    //->            10.50.4286  SP2 CU7					 6/17/2013
//                                          10.50.2881  SP1 CU14    //->            10.50.4290  SP2 CU8                  8/22/2013
//                                                                                  10.50.4295  SP2 CU9                 10/28/2013  
//                                                                                  10.50.4297  SP2 CU10                12/16/2013 
//                                                                                  10.50.4302  SP2 CU11                 2/17/2014
//                                                                                  10.50.4305	SP2 CU12                 4/21/2014
//                                                                                  10.50.4319  SP2 CU13                 6/30/2014   
//																																			10.50.6000	SP3 RTM		9/26/2014
//                                                                                                                                          10.50.6525  SP3 + HF     2/9/2015
//                                                                                                                                          http://support.microsoft.com/kb/3033860
// Any build older than 10.50.4000 is on an "unsupported service pack"
// SQL Server 2008 R2 SP3 RTM (Build 10.50.6000) is the final public build of SQL Server 2008 R2, barring any later security fixes.          



// SQL Server 2008 R2 RTM was considered an "unsupported service pack" as of July 12, 2012
// SQL Server 2008 R2 SP1 was considered an "unsupported service pack" as of August 8, 2013										

// The SQL Server 2008 R2 builds that were released after SQL Server 2008 R2 was released
// http://support.microsoft.com/kb/981356

// The SQL Server 2008 R2 builds that were released after SQL Server 2008 R2 Service Pack 1 was released 
// http://support.microsoft.com/kb/2567616

// Microsoft released SQL Server 2008 R2 SP1 CU14 on 8/8/2013, then pulled it the next day, "since SP1 is ending mainstream support"

// The SQL Server 2008 R2 builds that were released after SQL Server 2008 R2 Service Pack 2 was released
// http://support.microsoft.com/kb/2730301 

// SQL Server 2008 R2 SP2 CU13 is the final cumulative update for SQL Server 2008 R2

// SQL Server 2008 R2 SP3 Release information
// http://support2.microsoft.com/kb/2979597

// When was SQL Server installed  (Query 2) (SQL Server Install Date) -->
    <Query id="2" name="SQL Server Install Date" description="When was SQL Server installed" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], create_date AS [SQL Server Install Date] 
FROM sys.server_principals WITH (NOLOCK)
WHERE name = N'NT AUTHORITY\SYSTEM'
OR name = N'NT AUTHORITY\NETWORK SERVICE' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// SQL Server 2008 RTM Builds       SQL Server 2008 SP1 Builds       SQL Server 2008 SP2 Builds		      SQL Server 2008 SP3 Builds						SQL Server 2008 SP4 Builds
// Build           Description      Build          Description		 Build     Description			      Build		    Description							Build		Description
// 10.0.1600        Gold RTM
// 10.0.1763        RTM CU1
// 10.0.1779        RTM CU2
// 10.0.1787        RTM CU3    //>	10.0.2531		SP1 RTM
// 10.0.1798        RTM CU4    //>	10.0.2710       SP1 CU1
// 10.0.1806        RTM CU5    //>	10.0.2714       SP1 CU2 
// 10.0.1812		RTM CU6    //>	10.0.2723       SP1 CU3
// 10.0.1818        RTM CU7    //>	10.0.2734       SP1 CU4
// 10.0.1823        RTM CU8    //>	10.0.2746		SP1 CU5
// 10.0.1828		RTM CU9    //>	10.0.2757		SP1 CU6
// 10.0.1835	    RTM CU10   //>	10.0.2766		SP1 CU7
// RTM Branch Retired          //>	10.0.2775		SP1 CU8		//>  10.0.4000	   SP2 RTM
//								    10.0.2789		SP1 CU9
//								    10.0.2799		SP1 CU10	
//								    10.0.2804		SP1 CU11	//>  10.0.4266     SP2 CU1		
//								    10.0.2808		SP1 CU12	//>  10.0.4272	   SP2 CU2	
//								    10.0.2816	    SP1 CU13    //>  10.0.4279     SP2 CU3	
//								    10.0.2821		SP1 CU14	//>  10.0.4285	   SP2 CU4	//>				10.0.5500		SP3 RTM
//								    10.0.2847		SP1 CU15	//>  10.0.4316	   SP2 CU5  
//								    10.0.2850		SP1 CU16	//>  10.0.4321	   SP2 CU6	//>				10.0.5766		SP3 CU1	      10/17/2011
//                                  SP1 Branch Retired          //>  10.0.4323     SP2 CU7  //>             10.0.5768       SP3 CU2       11/21/2011
//                                                                   10.0.4326	   SP2 CU8  //>             10.0.5770		SP3 CU3       1/16/2012
//														             10.0.4330	   SP2 CU9  //>				10.0.5775		SP3 CU4       3/19/2012
//															         10.0.4332	   SP2 CU10 //>             10.0.5785       SP3 CU5		  5/21/2012
//															         10.0.4333     SP2 CU11 //>			    10.0.5788       SP3 CU6		  7/16/2012
//															         SP2 Branch Retired					    10.0.5794       SP3 CU7		  9/17/2012
//																								            10.0.5828       SP3 CU8		  11/19/2012
//																								            10.0.5829       SP3 CU9       1/21/2013
//																								            10.0.5835       SP3 CU10      3/19/2013
//                                                                                                          10.0.5841       SP3 CU11      5/20/2013
//                                                                                                          10.0.5844       SP3 CU12      7/15/2013
//                                                                                                          10.0.5846       SP3 CU13      9/16/2013
//                                                                                                          10.0.5848       SP3 CU14      11/18/2013
//                                                                                                          10.0.5850		SP3 CU15      1/20/2014
//                                                                                                          10.0.5852       SP3 CU16      3/17/2014
//                                                                                                          10.0.5861       SP3 CU17      5/19/2014			
//                                                                                                          10.0.5867       SP3 CU17+					  10.0.6000		SP4 RTM		9/30/2014
//                                                                                                                                                        10.0.6526     SP4 + HF    2/9/2015 
//                                                                                                                                                        http://support.microsoft.com/kb/3034373
//
// SQL Server 2008 RTM is considered an "unsupported service pack" as of April 13, 2010
// SQL Server 2008 SP1 is considered an "unsupported service pack" as of September 19, 2011
// SQL Server 2008 SP2 is considered an "unsupported service pack" as of September 17, 2012
// Any build older than 10.0.5500 is on an "unsupported service pack"

// SQL Server 2008 fell out of Mainstream Support on July 8, 2014

// The SQL Server 2008 builds that were released after SQL Server 2008 was released
// http://support.microsoft.com/kb/956909
//
// The SQL Server 2008 builds that were released after SQL Server 2008 Service Pack 1 was released
// http://support.microsoft.com/kb/970365
//
// The SQL Server 2008 builds that were released after SQL Server 2008 Service Pack 2 was released 
// http://support.microsoft.com/kb/2402659	
//
// The SQL Server 2008 builds that were released after SQL Server 2008 Service Pack 3 was released
// http://support.microsoft.com/kb/2629969					   



// When was SQL Server installed  (Query 2) (SQL Server Install Date)   -->
    <Query id="2" name="SQL Server Install Date" description="When was SQL Server installed" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT @@SERVERNAME AS [Server Name], create_date AS [SQL Server Install Date] 
FROM sys.server_principals WITH (NOLOCK)
WHERE name = N'NT AUTHORITY\SYSTEM'
OR name = N'NT AUTHORITY\NETWORK SERVICE' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you the account being used for the SQL Server Service and the SQL Agent Service
// Shows the processid, when they were last started, and their current status
// Shows whether you are running on a failover cluster instance


// SQL Server NUMA Node information  (Query 9) (SQL Server NUMA Info)-->
    <Query id="9" name="SQL Server NUMA Info" description="SQL Server NUMA Node information" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT node_id, node_state_desc, memory_node_id, processor_group, online_scheduler_count, 
       active_worker_count, avg_load_balance, resource_monitor_state
FROM sys.dm_os_nodes WITH (NOLOCK) 
WHERE node_state_desc <> N'ONLINE DAC' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// If no global trace flags are enabled, no results will be returned.
// It is very useful to know what global trace flags are currently enabled as part of the diagnostic process.

// Common trace flags that should be enabled in most cases
// TF 1117 - When growing a data file, grow all files at the same time so they remain the same size, reducing allocation contention points
//           http://support2.microsoft.com/kb/2154845
// 
// TF 1118 - Helps alleviate allocation contention in tempdb, SQL Server allocates full extents to each database object, 
//           thereby eliminating the contention on SGAM pages (more important with older versions of SQL Server)
//           Recommendations to reduce allocation contention in SQL Server tempdb database
//           http://support2.microsoft.com/kb/2154845

// TF 2371 - Lowers auto update statistics threshold for large tables
//           http://blogs.msdn.com/b/saponsqlserver/archive/2011/09/07/changes-to-automatic-update-statistics-in-sql-server-traceflag-2371.aspx

// TF 3226 - Supresses logging of successful database backup messages to the SQL Server Error Log
//           http://www.sqlskills.com/blogs/paul/fed-up-with-backup-success-messages-bloating-your-error-logs/


// SQL Server NUMA Node information  (Query 7) (SQL Server NUMA Info)-->
    <Query id="7" name="SQL Server NUMA Info" description="SQL Server NUMA Node information" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT node_id, node_state_desc, memory_node_id, online_scheduler_count, 
       active_worker_count, avg_load_balance, resource_monitor_state
FROM sys.dm_os_nodes WITH (NOLOCK) 
WHERE node_state_desc <> N'ONLINE DAC' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you major OS version, Service Pack, Edition, and language info for the operating system
// 6.3 is either Windows 8.1, Windows 10 or Windows Server 2012 R2, Windows Server 2016 
// 6.2 is either Windows 8 or Windows Server 2012
// 6.1 is either Windows 7 or Windows Server 2008 R2
// 6.0 is either Windows Vista or Windows Server 2008

// Windows SKU codes
// 4 is Enterprise Edition
// 7 is Standard Server Edition
// 8 is Datacenter Server Edition
// 10 is Enterprise Server Edition
// 48 is Professional Edition

// 1033 for os_language_version is US-English

// SQL Server 2012 requires Windows Server 2008 SP2 or newer

// Hardware and Software Requirements for Installing SQL Server 2012
// http://msdn.microsoft.com/en-us/library/ms143506.aspx

// Using SQL Server in Windows 8 and later versions of Windows operating system 
// https://support.microsoft.com/en-us/kb/2681562



// SQL Server NUMA Node information  (Query 11) (SQL Server NUMA Info)-->
    <Query id="11" name="SQL Server NUMA Info" description="SQL Server NUMA Node information" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT node_id, node_state_desc, memory_node_id, processor_group, online_scheduler_count, 
       active_worker_count, avg_load_balance, resource_monitor_state
FROM sys.dm_os_nodes WITH (NOLOCK) 
WHERE node_state_desc <> N'ONLINE DAC' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you major OS version, Service Pack, Edition, and language info for the operating system
// 6.3 is either Windows 8.1, Windows 10 or Windows Server 2012 R2, Windows Server 2016  
// 6.2 is either Windows 8 or Windows Server 2012
// 6.1 is either Windows 7 or Windows Server 2008 R2
// 6.0 is either Windows Vista or Windows Server 2008

// Windows SKU codes
// 4 is Enterprise Edition
// 7 is Standard Server Edition
// 8 is Datacenter Server Edition
// 10 is Enterprise Server Edition
// 48 is Professional Edition

// 1033 for os_language_version is US-English

// SQL Server 2014 requires Windows Server 2008 SP2 or newer

// Hardware and Software Requirements for Installing SQL Server 2014
// http://msdn.microsoft.com/en-us/library/ms143506.aspx

// Using SQL Server in Windows 8 and later versions of Windows operating system 
// https://support.microsoft.com/en-us/kb/2681562



// SQL Server NUMA Node information  (Query 12) (SQL Server NUMA Info)-->
    <Query id="12" name="SQL Server NUMA Info" description="SQL Server NUMA Node information" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT node_id, node_state_desc, memory_node_id, processor_group, online_scheduler_count, 
       active_worker_count, avg_load_balance, resource_monitor_state
FROM sys.dm_os_nodes WITH (NOLOCK) 
WHERE node_state_desc <> N'ONLINE DAC' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you major OS version, Service Pack, Edition, and language info for the operating system
// 6.3 is either Windows 8.1, Windows 10 or Windows Server 2012 R2, Windows Server 2016 
// 6.2 is either Windows 8 or Windows Server 2012
// 6.1 is either Windows 7 or Windows Server 2008 R2
// 6.0 is either Windows Vista or Windows Server 2008

// Windows SKU codes
// 4 is Enterprise Edition
// 7 is Standard Server Edition
// 8 is Datacenter Server Edition
// 10 is Enterprise Server Edition
// 48 is Professional Edition

// 1033 for os_language_version is US-English

// SQL Server 2016 requires Windows Server 2012 or newer

// Quick-Start Installation of SQL Server 2016
// https://msdn.microsoft.com/en-us/library/bb500433(v=sql.130).aspx

// Hardware and Software Requirements for Installing SQL Server 2016
// https://msdn.microsoft.com/en-us/library/ms143506(v=sql.130).aspx

// Using SQL Server in Windows 8 and later versions of Windows operating system 
// https://support.microsoft.com/en-us/kb/2681562


// SQL Server NUMA Node information  (Query 12) (SQL Server NUMA Info)-->
    <Query id="12" name="SQL Server NUMA Info" description="SQL Server NUMA Node information" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT node_id, node_state_desc, memory_node_id, processor_group, online_scheduler_count, 
       active_worker_count, avg_load_balance, resource_monitor_state
FROM sys.dm_os_nodes WITH (NOLOCK) 
WHERE node_state_desc <> N'ONLINE DAC' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// host_release codes (only valid for Windows)
// 6.3 is either Windows 8.1, Windows 10 or Windows Server 2012 R2, Windows Server 2016 
// 6.2 is either Windows 8 or Windows Server 2012


// host_sku codes (only valid for Windows)
// 4 is Enterprise Edition
// 7 is Standard Server Edition
// 8 is Datacenter Server Edition
// 10 is Enterprise Server Edition
// 48 is Professional Edition

// 1033 for os_language_version is US-English

// SQL Server vNext requires Windows Server 2012 or newer

// Quick-Start Installation of SQL Server 2016
// https://msdn.microsoft.com/en-us/library/bb500433(v=sql.130).aspx

// Hardware and Software Requirements for Installing SQL Server 2016
// https://msdn.microsoft.com/en-us/library/ms143506(v=sql.130).aspx

// Using SQL Server in Windows 8 and later versions of Windows operating system 
// https://support.microsoft.com/en-us/kb/2681562


// SQL Server NUMA Node information  (Query 12) (SQL Server NUMA Info)-->
    <Query id="12" name="SQL Server NUMA Info" description="SQL Server NUMA Node information" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT node_id, node_state_desc, memory_node_id, processor_group, online_scheduler_count, 
       active_worker_count, avg_load_balance, resource_monitor_state
FROM sys.dm_os_nodes WITH (NOLOCK) 
WHERE node_state_desc <> N'ONLINE DAC' OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you major OS version, Service Pack, Edition, and language info for the operating system 
// 6.3 is either Windows 8.1 or Windows Server 2012 R2
// 6.2 is either Windows 8 or Windows Server 2012
// 6.1 is either Windows 7 or Windows Server 2008 R2
// 6.0 is either Windows Vista or Windows Server 2008
// 5.2 is either Windows XP or Windows Server 2003

// Windows SKU codes
// 4 is Enterprise Edition
// 7 is Standard Server Edition
// 8 is Datacenter Server Edition
// 10 is Enterprise Server Edition
// 48 is Professional Edition

// 1033 for os_language_version is US-English

// Hardware and Software Requirements for Installing SQL Server 2008 R2
// http://msdn.microsoft.com/en-us/library/ms143506(v=sql.105).aspx

// Using SQL Server in Windows 8, Windows 8.1, Windows Server 2012 and Windows Server 2012 R2 environments
// http://support.microsoft.com/kb/2681562


// SQL Server Services information (SQL Server 2008 R2 SP1 or greater)  (Query 8) (SQL Server Services Info)-->
    <Query id="8" name="SQL Server Services Info" description="SQL Server Services information (SQL Server 2008 R2 SP1 or greater)" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT servicename, process_id, startup_type_desc, status_desc, 
last_startup_time, service_account, is_clustered, cluster_nodename, [filename]
FROM sys.dm_server_services WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You want to see 0 for process_physical_memory_low
// You want to see 0 for process_virtual_memory_low
// This indicates that you are not under internal memory pressure
// If locked_page_allocations_kb > 0, then LPIM is enabled

// How to enable the "locked pages" feature in SQL Server 2012
// https://support.microsoft.com/en-us/kb/2659143



// SQL Server Services information (Query 7) (SQL Server Services Info)-->
    <Query id="7" name="SQL Server Services Info" description="SQL Server Services information" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT servicename, process_id, startup_type_desc, status_desc, 
last_startup_time, service_account, is_clustered, cluster_nodename, [filename]
FROM sys.dm_server_services WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You want to see 0 for process_physical_memory_low
// You want to see 0 for process_virtual_memory_low
// This indicates that you are not under internal memory pressure
// If locked_page_allocations_kb > 0, then LPIM is enabled

// How to enable the "locked pages" feature in SQL Server 2012
// https://support.microsoft.com/en-us/kb/2659143



// SQL Server Services information (Query 8) (SQL Server Services Info)-->
    <Query id="8" name="SQL Server Services Info" description="SQL Server Services information" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT servicename, process_id, startup_type_desc, status_desc, 
last_startup_time, service_account, is_clustered, cluster_nodename, [filename]
FROM sys.dm_server_services WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You want to see 0 for process_physical_memory_low
// You want to see 0 for process_virtual_memory_low
// This indicates that you are not under internal memory pressure
// If locked_page_allocations_kb > 0, then LPIM is enabled

// How to enable the "locked pages" feature in SQL Server 2012
// https://support.microsoft.com/en-us/kb/2659143



// SQL Server Services information (Query 8) (SQL Server Services Info)-->
    <Query id="8" name="SQL Server Services Info" description="SQL Server Services information" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT servicename, process_id, startup_type_desc, status_desc, 
last_startup_time, service_account, is_clustered, cluster_nodename, [filename], 
instant_file_initialization_enabled -- New in SQL Server 2016 SP1
FROM sys.dm_server_services WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// You want to see 0 for process_physical_memory_low
// You want to see 0 for process_virtual_memory_low
// This indicates that you are not under internal memory pressure
// If locked_page_allocations_kb > 0, then LPIM is enabled

// How to enable the "locked pages" feature in SQL Server 2012
// https://support.microsoft.com/en-us/kb/2659143



// SQL Server Services information (Query 8) (SQL Server Services Info)-->
    <Query id="8" name="SQL Server Services Info" description="SQL Server Services information" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT servicename, process_id, startup_type_desc, status_desc, 
last_startup_time, service_account, is_clustered, cluster_nodename, [filename], 
instant_file_initialization_enabled -- New for SQL Server 2016 SP1
FROM sys.dm_server_services WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps troubleshoot blocking and deadlocking issues
// The results will change from second to second on a busy system
// You should run this query multiple times when you see signs of blocking


// When were Statistics last updated on all indexes?  (Query 46) (Statistics Update)-->
    <Query id="46" name="Statistics Update" description="When were Statistics last updated on all indexes?" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT SCHEMA_NAME(o.Schema_ID) + N'.' + o.NAME AS [Object Name], o.type_desc AS [Object Type],
      i.name AS [Index Name], STATS_DATE(i.[object_id], i.index_id) AS [Statistics Date], 
      s.auto_created, s.no_recompute, s.user_created, st.row_count, st.used_page_count
FROM sys.objects AS o WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON o.[object_id] = i.[object_id]
INNER JOIN sys.stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id] 
AND i.index_id = s.stats_id
INNER JOIN sys.dm_db_partition_stats AS st WITH (NOLOCK)
ON o.[object_id] = st.[object_id]
AND i.[index_id] = st.[index_id]
WHERE o.[type] IN ('U', 'V')
AND st.row_count > 0
ORDER BY STATS_DATE(i.[object_id], i.index_id) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps troubleshoot blocking and deadlocking issues
// The results will change from second to second on a busy system
// You should run this query multiple times when you see signs of blocking



// When were Statistics last updated on all indexes?  (Query 58) (Statistics Update)-->
    <Query id="58" name="Statistics Update" description="When were Statistics last updated on all indexes?" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT SCHEMA_NAME(o.Schema_ID) + N'.' + o.NAME AS [Object Name], o.type_desc AS [Object Type],
      i.name AS [Index Name], STATS_DATE(i.[object_id], i.index_id) AS [Statistics Date], 
      s.auto_created, s.no_recompute, s.user_created, st.row_count, st.used_page_count
FROM sys.objects AS o WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON o.[object_id] = i.[object_id]
INNER JOIN sys.stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id] 
AND i.index_id = s.stats_id
INNER JOIN sys.dm_db_partition_stats AS st WITH (NOLOCK)
ON o.[object_id] = st.[object_id]
AND i.[index_id] = st.[index_id]
WHERE o.[type] IN ('U', 'V')
AND st.row_count > 0
ORDER BY STATS_DATE(i.[object_id], i.index_id) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps troubleshoot blocking and deadlocking issues
// The results will change from second to second on a busy system
// You should run this query multiple times when you see signs of blocking



// When were Statistics last updated on all indexes?  (Query 54) (Statistics Update)-->
    <Query id="54" name="Statistics Update" description="When were Statistics last updated on all indexes?" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT SCHEMA_NAME(o.Schema_ID) + N'.' + o.NAME AS [Object Name], o.type_desc AS [Object Type],
      i.name AS [Index Name], STATS_DATE(i.[object_id], i.index_id) AS [Statistics Date], 
      s.auto_created, s.no_recompute, s.user_created, st.row_count, st.used_page_count
FROM sys.objects AS o WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON o.[object_id] = i.[object_id]
INNER JOIN sys.stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id] 
AND i.index_id = s.stats_id
INNER JOIN sys.dm_db_partition_stats AS st WITH (NOLOCK)
ON o.[object_id] = st.[object_id]
AND i.[index_id] = st.[index_id]
WHERE o.[type] IN ('U', 'V')
AND st.row_count > 0
ORDER BY STATS_DATE(i.[object_id], i.index_id) DESC OPTION (RECOMPILE); 
]]></Query>
    <!--//////
   
// Gives you some good information about your tables



// When were Statistics last updated on all indexes?  (Query 59) (Statistics Update)-->
    <Query id="59" name="Statistics Update" description="When were Statistics last updated on all indexes?" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT SCHEMA_NAME(o.Schema_ID) + N'.' + o.NAME AS [Object Name], o.type_desc AS [Object Type],
      i.name AS [Index Name], STATS_DATE(i.[object_id], i.index_id) AS [Statistics Date], 
      s.auto_created, s.no_recompute, s.user_created, s.is_temporary,
	  st.row_count, st.used_page_count
FROM sys.objects AS o WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON o.[object_id] = i.[object_id]
INNER JOIN sys.stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id] 
AND i.index_id = s.stats_id
INNER JOIN sys.dm_db_partition_stats AS st WITH (NOLOCK)
ON o.[object_id] = st.[object_id]
AND i.[index_id] = st.[index_id]
WHERE o.[type] IN ('U', 'V')
AND st.row_count > 0
ORDER BY STATS_DATE(i.[object_id], i.index_id) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some good information about your tables
// Is Memory optimized and durability description are Hekaton-related properties that were new in SQL Server 2014



// When were Statistics last updated on all indexes?  (Query 65) (Statistics Update)-->
    <Query id="65" name="Statistics Update" description="When were Statistics last updated on all indexes?" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT SCHEMA_NAME(o.Schema_ID) + N'.' + o.[NAME] AS [Object Name], o.[type_desc] AS [Object Type],
      i.[name] AS [Index Name], STATS_DATE(i.[object_id], i.index_id) AS [Statistics Date], 
      s.auto_created, s.no_recompute, s.user_created, s.is_incremental, s.is_temporary,
	  st.row_count, st.used_page_count
FROM sys.objects AS o WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON o.[object_id] = i.[object_id]
INNER JOIN sys.stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id] 
AND i.index_id = s.stats_id
INNER JOIN sys.dm_db_partition_stats AS st WITH (NOLOCK)
ON o.[object_id] = st.[object_id]
AND i.[index_id] = st.[index_id]
WHERE o.[type] IN ('U', 'V')
AND st.row_count > 0
ORDER BY STATS_DATE(i.[object_id], i.index_id) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some good information about your tables
// is_memory_optimized and durability_desc were new in SQL Server 2014
// temporal_type_desc, is_remote_data_archive_enabled, is_external are new in SQL Server 2016

// sys.tables (Transact-SQL)
// https://msdn.microsoft.com/en-us/library/ms187406.aspx



// When were Statistics last updated on all indexes?  (Query 67) (Statistics Update)-->
    <Query id="67" name="Statistics Update" description="When were Statistics last updated on all indexes?" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT SCHEMA_NAME(o.Schema_ID) + N'.' + o.[NAME] AS [Object Name], o.[type_desc] AS [Object Type],
      i.[name] AS [Index Name], STATS_DATE(i.[object_id], i.index_id) AS [Statistics Date], 
      s.auto_created, s.no_recompute, s.user_created, s.is_incremental, s.is_temporary,
	  st.row_count, st.used_page_count
FROM sys.objects AS o WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON o.[object_id] = i.[object_id]
INNER JOIN sys.stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id] 
AND i.index_id = s.stats_id
INNER JOIN sys.dm_db_partition_stats AS st WITH (NOLOCK)
ON o.[object_id] = st.[object_id]
AND i.[index_id] = st.[index_id]
WHERE o.[type] IN ('U', 'V')
AND st.row_count > 0
ORDER BY STATS_DATE(i.[object_id], i.index_id) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some good information about your tables
// is_memory_optimized and durability_desc were new in SQL Server 2014
// temporal_type_desc, is_remote_data_archive_enabled, is_external are new in SQL Server 2016

// sys.tables (Transact-SQL)
// https://msdn.microsoft.com/en-us/library/ms187406.aspx



// When were Statistics last updated on all indexes?  (Query 67) (Statistics Update)-->
    <Query id="67" name="Statistics Update" description="When were Statistics last updated on all indexes?" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT SCHEMA_NAME(o.Schema_ID) + N'.' + o.[NAME] AS [Object Name], o.[type_desc] AS [Object Type],
      i.[name] AS [Index Name], STATS_DATE(i.[object_id], i.index_id) AS [Statistics Date], 
      s.auto_created, s.no_recompute, s.user_created, s.is_incremental, s.is_temporary,
	  st.row_count, st.used_page_count
FROM sys.objects AS o WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON o.[object_id] = i.[object_id]
INNER JOIN sys.stats AS s WITH (NOLOCK)
ON i.[object_id] = s.[object_id] 
AND i.index_id = s.stats_id
INNER JOIN sys.dm_db_partition_stats AS st WITH (NOLOCK)
ON o.[object_id] = st.[object_id]
AND i.[index_id] = st.[index_id]
WHERE o.[type] IN ('U', 'V')
AND st.row_count > 0
ORDER BY STATS_DATE(i.[object_id], i.index_id) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some good basic hardware information about your database server


// Get System Manufacturer and model number from (Query 8) (System Manufacturer)
// SQL Server Error log. This query might take a few seconds 
// if you have not recycled your error log recently  -->
    <Query id="8" name="System Manufacturer" description="Get System Manufacturer and model number from" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
EXEC sys.xp_readerrorlog 0, 1, N'Manufacturer';
]]></Query>
    <!--//////
   
// Gives you some good basic hardware information about your database server


// Get System Manufacturer and model number from  (Query 11) (System Manufacturer)
// SQL Server Error log. This query might take a few seconds 
// if you have not recycled your error log recently-->
    <Query id="11" name="System Manufacturer" description="Get System Manufacturer and model number from" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
EXEC sys.xp_readerrorlog 0, 1, N'Manufacturer';
]]></Query>
    <!--//////
   
// Gives you some good basic hardware information about your database server


// Get System Manufacturer and model number from  (Query 9) (System Manufacturer)
// SQL Server Error log. This query might take a few seconds 
// if you have not recycled your error log recently-->
    <Query id="9" name="System Manufacturer" description="Get System Manufacturer and model number from" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
EXEC sys.xp_readerrorlog 0, 1, N'Manufacturer';
]]></Query>
    <!--//////
   
// Gives you some good basic hardware information about your database server
// Cannot distinguish between HT and multi-core
// Note: virtual_machine_type_desc of HYPERVISOR does not automatically mean you are running SQL Server inside of a VM
// It merely indicates that you have a hypervisor running on your host


// Get System Manufacturer and model number from SQL Server Error log (Query 17) (System Manufacturer)-->
    <Query id="17" name="System Manufacturer" description="Get System Manufacturer and model number from SQL Server Error log" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
EXEC sys.xp_readerrorlog 0, 1, N'Manufacturer';
]]></Query>
    <!--//////
   
// Gives you some good basic hardware information about your database server
// Cannot distinguish between HT and multi-core
// Note: virtual_machine_type_desc of HYPERVISOR does not automatically mean you are running SQL Server inside of a VM
// It merely indicates that you have a hypervisor running on your host


// Get System Manufacturer and model number from SQL Server Error log (Query 19) (System Manufacturer)-->
    <Query id="19" name="System Manufacturer" description="Get System Manufacturer and model number from SQL Server Error log" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
EXEC sys.xp_readerrorlog 0, 1, N'Manufacturer';
]]></Query>
    <!--//////
   

// Helps you find the most expensive queries from a CPU perspective across the entire instance



// Good basic information about OS memory amounts and state  (Query 34) (System Memory)-->
    <Query id="34" name="System Memory" description="Good basic information about OS memory amounts and state" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT total_physical_memory_kb/1024 AS [Physical Memory (MB)], 
       available_physical_memory_kb/1024 AS [Available Memory (MB)], 
       total_page_file_kb/1024 AS [Total Page File (MB)], 
	   available_page_file_kb/1024 AS [Available Page File (MB)], 
	   system_cache_kb/1024 AS [System Cache (MB)],
       system_memory_state_desc AS [System Memory State]
FROM sys.dm_os_sys_memory WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// Helps you find the most expensive queries from a CPU perspective across the entire instance



// Good basic information about OS memory amounts and state  (Query 30) (System Memory)-->
    <Query id="30" name="System Memory" description="Good basic information about OS memory amounts and state" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
SELECT total_physical_memory_kb/1024 AS [Physical Memory (MB)], 
       available_physical_memory_kb/1024 AS [Available Memory (MB)], 
       total_page_file_kb/1024 AS [Total Page File (MB)], 
	   available_page_file_kb/1024 AS [Available Page File (MB)], 
	   system_cache_kb/1024 AS [System Cache (MB)],
       system_memory_state_desc AS [System Memory State]
FROM sys.dm_os_sys_memory WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some useful information about the composition and relative load on your NUMA nodes
// You want to see an equal number of schedulers on each NUMA node
// Watch out if SQL Server 2012 Standard Edition has been installed on a machine with more than 16 physical cores
// Watch out if you have a VM with more than 4 NUMA nodes with SQL Server Standard Edition, since there is a four-socket license limit

// Balancing Your Available SQL Server Core Licenses Evenly Across NUMA Nodes
// http://www.sqlskills.com/blogs/glenn/balancing-your-available-sql-server-core-licenses-evenly-across-numa-nodes/



// Good basic information about OS memory amounts and state  (Query 12) (System Memory)-->
    <Query id="12" name="System Memory" description="Good basic information about OS memory amounts and state" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT total_physical_memory_kb/1024 AS [Physical Memory (MB)], 
       available_physical_memory_kb/1024 AS [Available Memory (MB)], 
       total_page_file_kb/1024 AS [Total Page File (MB)], 
	   available_page_file_kb/1024 AS [Available Page File (MB)], 
	   system_cache_kb/1024 AS [System Cache (MB)],
       system_memory_state_desc AS [System Memory State]
FROM sys.dm_os_sys_memory WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some useful information about the composition and relative load on your NUMA nodes
// You want to see an equal number of schedulers on each NUMA node
// Watch out if SQL Server 2014 Standard Edition has been installed on a machine with more than 16 physical cores
// Watch out if you have a VM with more than 4 NUMA nodes with SQL Server Standard Edition, since there is a four-socket license limit

// Balancing Your Available SQL Server Core Licenses Evenly Across NUMA Nodes
// http://www.sqlskills.com/blogs/glenn/balancing-your-available-sql-server-core-licenses-evenly-across-numa-nodes/



// Good basic information about OS memory amounts and state  (Query 13) (System Memory)-->
    <Query id="13" name="System Memory" description="Good basic information about OS memory amounts and state" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT total_physical_memory_kb/1024 AS [Physical Memory (MB)], 
       available_physical_memory_kb/1024 AS [Available Memory (MB)], 
       total_page_file_kb/1024 AS [Total Page File (MB)], 
	   available_page_file_kb/1024 AS [Available Page File (MB)], 
	   system_cache_kb/1024 AS [System Cache (MB)],
       system_memory_state_desc AS [System Memory State]
FROM sys.dm_os_sys_memory WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some useful information about the composition and relative load on your NUMA nodes
// You want to see an equal number of schedulers on each NUMA node
// Watch out if SQL Server 2016 Standard Edition has been installed on a machine with more than 24 physical cores
// Watch out if you have a VM with more than 4 NUMA nodes with SQL Server Standard Edition, since there is a four-socket license limit

// Balancing Your Available SQL Server Core Licenses Evenly Across NUMA Nodes
// http://www.sqlskills.com/blogs/glenn/balancing-your-available-sql-server-core-licenses-evenly-across-numa-nodes/



// Good basic information about OS memory amounts and state  (Query 13) (System Memory)-->
    <Query id="13" name="System Memory" description="Good basic information about OS memory amounts and state" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT total_physical_memory_kb/1024 AS [Physical Memory (MB)], 
       available_physical_memory_kb/1024 AS [Available Memory (MB)], 
       total_page_file_kb/1024 AS [Total Page File (MB)], 
	   available_page_file_kb/1024 AS [Available Page File (MB)], 
	   system_cache_kb/1024 AS [System Cache (MB)],
       system_memory_state_desc AS [System Memory State]
FROM sys.dm_os_sys_memory WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some useful information about the composition and relative load on your NUMA nodes
// You want to see an equal number of schedulers on each NUMA node
// Watch out if SQL Server 2016 Standard Edition has been installed on a machine with more than 24 physical cores
// Watch out if you have a VM with more than 4 NUMA nodes with SQL Server Standard Edition, since there is a four-socket license limit

// Balancing Your Available SQL Server Core Licenses Evenly Across NUMA Nodes
// http://www.sqlskills.com/blogs/glenn/balancing-your-available-sql-server-core-licenses-evenly-across-numa-nodes/



// Good basic information about OS memory amounts and state  (Query 13) (System Memory)-->
    <Query id="13" name="System Memory" description="Good basic information about OS memory amounts and state" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT total_physical_memory_kb/1024 AS [Physical Memory (MB)], 
       available_physical_memory_kb/1024 AS [Available Memory (MB)], 
       total_page_file_kb/1024 AS [Total Page File (MB)], 
	   available_page_file_kb/1024 AS [Available Page File (MB)], 
	   system_cache_kb/1024 AS [System Cache (MB)],
       system_memory_state_desc AS [System Memory State]
FROM sys.dm_os_sys_memory WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you an idea of table sizes, and possible data compression opportunities



// Get some key table properties (Query 56) (Table Properties)-->
    <Query id="56" name="Table Properties" description="Get some key table properties" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT [name], create_date, lock_on_bulk_load, is_replicated, has_replication_filter, 
       is_tracked_by_cdc, lock_escalation_desc
FROM sys.tables WITH (NOLOCK) 
ORDER BY [name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you an idea of table sizes, and possible data compression opportunities


// Get some key table properties (Query 52) (Table Properties)-->
    <Query id="52" name="Table Properties" description="Get some key table properties" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT [name], create_date, lock_on_bulk_load, is_replicated, has_replication_filter, 
       is_tracked_by_cdc, lock_escalation_desc
FROM sys.tables WITH (NOLOCK) 
ORDER BY [name] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you an idea of table sizes, and possible data compression opportunities



// Get some key table properties (Query 58) (Table Properties)-->
    <Query id="58" name="Table Properties" description="Get some key table properties" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(t.[object_id]) AS [ObjectName], p.[rows] AS [Table Rows], p.index_id, 
       p.data_compression_desc AS [Index Data Compression],
       t.create_date, t.lock_on_bulk_load, t.is_replicated, t.has_replication_filter, 
       t.is_tracked_by_cdc, t.lock_escalation_desc, t.is_filetable
FROM sys.tables AS t WITH (NOLOCK)
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON t.[object_id] = p.[object_id]
WHERE OBJECT_NAME(t.[object_id]) NOT LIKE N'sys%'
ORDER BY OBJECT_NAME(t.[object_id]), p.index_id OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you an idea of table sizes, and possible data compression opportunities



// Get some key table properties (Query 64) (Table Properties)-->
    <Query id="64" name="Table Properties" description="Get some key table properties" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(t.[object_id]) AS [ObjectName], p.[rows] AS [Table Rows], p.index_id, 
       p.data_compression_desc AS [Index Data Compression],
       t.create_date, t.lock_on_bulk_load, t.is_replicated, t.has_replication_filter, 
       t.is_tracked_by_cdc, t.lock_escalation_desc, t.is_filetable, 
	   t.is_memory_optimized, t.durability_desc  -- new for SQL Server 2014
FROM sys.tables AS t WITH (NOLOCK)
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON t.[object_id] = p.[object_id]
WHERE OBJECT_NAME(t.[object_id]) NOT LIKE N'sys%'
ORDER BY OBJECT_NAME(t.[object_id]), p.index_id OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you an idea of table sizes, and possible data compression opportunities



// Get some key table properties (Query 66) (Table Properties)-->
    <Query id="66" name="Table Properties" description="Get some key table properties" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(t.[object_id]) AS [ObjectName], p.[rows] AS [Table Rows], p.index_id, 
       p.data_compression_desc AS [Index Data Compression],
       t.create_date, t.lock_on_bulk_load, t.is_replicated, t.has_replication_filter, 
       t.is_tracked_by_cdc, t.lock_escalation_desc, t.is_filetable, 
	   t.is_memory_optimized, t.durability_desc, 
	   t.temporal_type_desc, t.is_remote_data_archive_enabled, t.is_external -- new for SQL Server 2016
FROM sys.tables AS t WITH (NOLOCK)
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON t.[object_id] = p.[object_id]
WHERE OBJECT_NAME(t.[object_id]) NOT LIKE N'sys%'
ORDER BY OBJECT_NAME(t.[object_id]), p.index_id OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you an idea of table sizes, and possible data compression opportunities



// Get some key table properties (Query 66) (Table Properties)-->
    <Query id="66" name="Table Properties" description="Get some key table properties" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(t.[object_id]) AS [ObjectName], p.[rows] AS [Table Rows], p.index_id, 
       p.data_compression_desc AS [Index Data Compression],
       t.create_date, t.lock_on_bulk_load, t.is_replicated, t.has_replication_filter, 
       t.is_tracked_by_cdc, t.lock_escalation_desc, t.is_filetable, 
	   t.is_memory_optimized, t.durability_desc, 
	   t.temporal_type_desc, t.is_remote_data_archive_enabled, t.is_external -- new for SQL Server 2016
FROM sys.tables AS t WITH (NOLOCK)
INNER JOIN sys.partitions AS p WITH (NOLOCK)
ON t.[object_id] = p.[object_id]
WHERE OBJECT_NAME(t.[object_id]) NOT LIKE N'sys%'
ORDER BY OBJECT_NAME(t.[object_id]), p.index_id OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you what tables and indexes are using the most memory in the buffer cache


// Get Table names, row counts  (Query 44) (Table Sizes)-->
    <Query id="44" name="Table Sizes" description="Get Table names, row counts" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(object_id) AS [ObjectName], SUM(Rows) AS [RowCount]
FROM sys.partitions WITH (NOLOCK)
WHERE index_id < 2 --ignore the partitions from the non-clustered index if any
AND OBJECT_NAME(object_id) NOT LIKE N'sys%'
AND OBJECT_NAME(object_id) NOT LIKE N'queue_%' 
AND OBJECT_NAME(object_id) NOT LIKE N'filestream_tombstone%'
AND OBJECT_NAME(object_id) NOT LIKE N'fulltext%' 
GROUP BY [object_id]
ORDER BY SUM(Rows) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you what tables and indexes are using the most memory in the buffer cache
// It can help identify possible candidates for data compression


// Get Table names, row counts, and compression status for clustered index or heap  (Query 55) (Table Sizes)-->
    <Query id="55" name="Table Sizes" description="Get Table names, row counts, and compression status for clustered index or heap" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT OBJECT_NAME(object_id) AS [ObjectName], 
SUM(Rows) AS [RowCount], data_compression_desc AS [CompressionType]
FROM sys.partitions WITH (NOLOCK)
WHERE index_id < 2 --ignore the partitions from the non-clustered index if any
AND OBJECT_NAME(object_id) NOT LIKE N'sys%'
AND OBJECT_NAME(object_id) NOT LIKE N'queue_%' 
AND OBJECT_NAME(object_id) NOT LIKE N'filestream_tombstone%' 
AND OBJECT_NAME(object_id) NOT LIKE N'fulltext%'
AND OBJECT_NAME(object_id) NOT LIKE N'ifts_comp_fragment%'
AND OBJECT_NAME(object_id) NOT LIKE N'xml_index_nodes%'
GROUP BY object_id, data_compression_desc
ORDER BY SUM(Rows) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you what tables and indexes are using the most memory in the buffer cache
// It can help identify possible candidates for data compression


// Get Table names, row counts, and compression status for clustered index or heap  (Query 51) (Table Sizes)-->
    <Query id="51" name="Table Sizes" description="Get Table names, row counts, and compression status for clustered index or heap" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(object_id) AS [ObjectName], 
SUM(Rows) AS [RowCount], data_compression_desc AS [CompressionType]
FROM sys.partitions WITH (NOLOCK)
WHERE index_id < 2 --ignore the partitions from the non-clustered index if any
AND OBJECT_NAME(object_id) NOT LIKE N'sys%'
AND OBJECT_NAME(object_id) NOT LIKE N'queue_%' 
AND OBJECT_NAME(object_id) NOT LIKE N'filestream_tombstone%' 
AND OBJECT_NAME(object_id) NOT LIKE N'fulltext%'
AND OBJECT_NAME(object_id) NOT LIKE N'ifts_comp_fragment%'
AND OBJECT_NAME(object_id) NOT LIKE N'xml_index_nodes%'
GROUP BY object_id, data_compression_desc
ORDER BY SUM(Rows) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you what tables and indexes are using the most memory in the buffer cache
// It can help identify possible candidates for data compression


// Get Table names, row counts, and compression status for clustered index or heap  (Query 57) (Table Sizes)-->
    <Query id="57" name="Table Sizes" description="Get Table names, row counts, and compression status for clustered index or heap" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(object_id) AS [ObjectName], 
SUM(Rows) AS [RowCount], data_compression_desc AS [CompressionType]
FROM sys.partitions WITH (NOLOCK)
WHERE index_id < 2 --ignore the partitions from the non-clustered index if any
AND OBJECT_NAME(object_id) NOT LIKE N'sys%'
AND OBJECT_NAME(object_id) NOT LIKE N'queue_%' 
AND OBJECT_NAME(object_id) NOT LIKE N'filestream_tombstone%' 
AND OBJECT_NAME(object_id) NOT LIKE N'fulltext%'
AND OBJECT_NAME(object_id) NOT LIKE N'ifts_comp_fragment%'
AND OBJECT_NAME(object_id) NOT LIKE N'filetable_updates%'
AND OBJECT_NAME(object_id) NOT LIKE N'xml_index_nodes%'
AND OBJECT_NAME(object_id) NOT LIKE N'sqlagent_job%'
AND OBJECT_NAME(object_id) NOT LIKE N'plan_persist%'
GROUP BY object_id, data_compression_desc
ORDER BY SUM(Rows) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you what tables and indexes are using the most memory in the buffer cache
// It can help identify possible candidates for data compression


// Get Table names, row counts, and compression status for clustered index or heap  (Query 63) (Table Sizes)-->
    <Query id="63" name="Table Sizes" description="Get Table names, row counts, and compression status for clustered index or heap" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(object_id) AS [ObjectName], 
SUM(Rows) AS [RowCount], data_compression_desc AS [CompressionType]
FROM sys.partitions WITH (NOLOCK)
WHERE index_id < 2 --ignore the partitions from the non-clustered index if any
AND OBJECT_NAME(object_id) NOT LIKE N'sys%'
AND OBJECT_NAME(object_id) NOT LIKE N'queue_%' 
AND OBJECT_NAME(object_id) NOT LIKE N'filestream_tombstone%' 
AND OBJECT_NAME(object_id) NOT LIKE N'fulltext%'
AND OBJECT_NAME(object_id) NOT LIKE N'ifts_comp_fragment%'
AND OBJECT_NAME(object_id) NOT LIKE N'filetable_updates%'
AND OBJECT_NAME(object_id) NOT LIKE N'xml_index_nodes%'
AND OBJECT_NAME(object_id) NOT LIKE N'sqlagent_job%'
AND OBJECT_NAME(object_id) NOT LIKE N'plan_persist%'
GROUP BY object_id, data_compression_desc
ORDER BY SUM(Rows) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you what tables and indexes are using the most memory in the buffer cache
// It can help identify possible candidates for data compression


// Get Table names, row counts, and compression status for clustered index or heap  (Query 65) (Table Sizes)-->
    <Query id="65" name="Table Sizes" description="Get Table names, row counts, and compression status for clustered index or heap" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(object_id) AS [ObjectName], 
SUM(Rows) AS [RowCount], data_compression_desc AS [CompressionType]
FROM sys.partitions WITH (NOLOCK)
WHERE index_id < 2 --ignore the partitions from the non-clustered index if any
AND OBJECT_NAME(object_id) NOT LIKE N'sys%'
AND OBJECT_NAME(object_id) NOT LIKE N'queue_%' 
AND OBJECT_NAME(object_id) NOT LIKE N'filestream_tombstone%' 
AND OBJECT_NAME(object_id) NOT LIKE N'fulltext%'
AND OBJECT_NAME(object_id) NOT LIKE N'ifts_comp_fragment%'
AND OBJECT_NAME(object_id) NOT LIKE N'filetable_updates%'
AND OBJECT_NAME(object_id) NOT LIKE N'xml_index_nodes%'
AND OBJECT_NAME(object_id) NOT LIKE N'sqlagent_job%'  
AND OBJECT_NAME(object_id) NOT LIKE N'plan_persist%'  
GROUP BY object_id, data_compression_desc
ORDER BY SUM(Rows) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you what tables and indexes are using the most memory in the buffer cache
// It can help identify possible candidates for data compression


// Get Table names, row counts, and compression status for clustered index or heap  (Query 65) (Table Sizes)-->
    <Query id="65" name="Table Sizes" description="Get Table names, row counts, and compression status for clustered index or heap" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(object_id) AS [ObjectName], 
SUM(Rows) AS [RowCount], data_compression_desc AS [CompressionType]
FROM sys.partitions WITH (NOLOCK)
WHERE index_id < 2 --ignore the partitions from the non-clustered index if any
AND OBJECT_NAME(object_id) NOT LIKE N'sys%'
AND OBJECT_NAME(object_id) NOT LIKE N'queue_%' 
AND OBJECT_NAME(object_id) NOT LIKE N'filestream_tombstone%' 
AND OBJECT_NAME(object_id) NOT LIKE N'fulltext%'
AND OBJECT_NAME(object_id) NOT LIKE N'ifts_comp_fragment%'
AND OBJECT_NAME(object_id) NOT LIKE N'filetable_updates%'
AND OBJECT_NAME(object_id) NOT LIKE N'xml_index_nodes%'
AND OBJECT_NAME(object_id) NOT LIKE N'sqlagent_job%'  
AND OBJECT_NAME(object_id) NOT LIKE N'plan_persist%'  
GROUP BY object_id, data_compression_desc
ORDER BY SUM(Rows) DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This will not return any rows if you have 
// not had any memory dumps (which is a good thing)

// sys.dm_server_memory_dumps (Transact-SQL)
// http://bit.ly/2elwWll


// Get number of data files in tempdb database (Query 24) (Tempdb Data Files)-->
    <Query id="24" name="Tempdb Data Files" description="Get number of data files in tempdb database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
EXEC sys.xp_readerrorlog 0, 1, N'The tempdb database has';
]]></Query>
    <!--//////
   
// This will not return any rows if you have 
// not had any memory dumps (which is a good thing)

// sys.dm_server_memory_dumps (Transact-SQL)
// http://bit.ly/2elwWll


// Get number of data files in tempdb database (Query 24) (TempDB Data Files)-->
    <Query id="24" name="TempDB Data Files" description="Get number of data files in tempdb database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
EXEC sys.xp_readerrorlog 0, 1, N'The tempdb database has';
]]></Query>
    <!--//////
   
// This will not return any rows if you have 
// not had any memory dumps (which is a good thing)

// sys.dm_server_memory_dumps (Transact-SQL)
// http://bit.ly/2elwWll


// Get number of data files in tempdb database (Query 24) (TempDB Data Files)-->
    <Query id="24" name="TempDB Data Files" description="Get number of data files in tempdb database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
EXEC sys.xp_readerrorlog 0, 1, N'The tempdb database has';
]]></Query>
    <!--//////
   

// Helps you find the most expensive queries from a memory perspective across the entire instance
// Can also help track down parameter sniffing issues


// Get top average elapsed time queries for entire instance (Query 42) (Top Avg Elapsed Time Queries)-->
    <Query id="42" name="Top Avg Elapsed Time Queries" description="Get top average elapsed time queries for entire instance" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name], 
REPLACE(REPLACE(LEFT(t.[text], 255), CHAR(10),''), CHAR(13),'') AS [Short Query Text],  
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time],
qs.min_elapsed_time, qs.max_elapsed_time, qs.last_elapsed_time,
qs.execution_count AS [Execution Count],  
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads], 
qs.total_physical_reads/qs.execution_count AS [Avg Physical Reads], 
qs.total_worker_time/qs.execution_count AS [Avg Worker Time],
qs.creation_time AS [Creation Time],
qp.query_plan AS [QueryPlan] -- comment out this column if copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
ORDER BY qs.total_elapsed_time/qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// Helps you find the most expensive queries from a memory perspective across the entire instance
// Can also help track down parameter sniffing issues


// Get top average elapsed time queries for entire instance (Query 47) (Top Avg Elapsed Time Queries)
// drop table #QueryStat
-->
    <Query id="47" name="Top Avg Elapsed Time Queries" description="Get top average elapsed time queries for entire instance" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) 
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time],
qs.min_elapsed_time, qs.max_elapsed_time, qs.last_elapsed_time,
qs.execution_count AS [Execution Count],  
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads], 
qs.total_physical_reads/qs.execution_count AS [Avg Physical Reads], 
qs.total_worker_time/qs.execution_count AS [Avg Worker Time],
qs.creation_time AS [Creation Time],
qs.plan_handle
into #QueryStat
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
ORDER BY qs.total_elapsed_time/qs.execution_count DESC OPTION (RECOMPILE);

select 
qs.*,
DB_NAME(t.[dbid]) AS [Database Name],
t.[text] as [QueryText],
qp.query_plan AS [QueryPlan] 

from #QueryStat qs
CROSS APPLY sys.dm_exec_sql_text(qs.plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) AS qp


]]></Query>
    <!--//////
   

// Helps you find the most expensive queries from a memory perspective across the entire instance
// Can also help track down parameter sniffing issues


// Get top average elapsed time queries for entire instance (Query 47) (Top Avg Elapsed Time Queries)-->
    <Query id="47" name="Top Avg Elapsed Time Queries" description="Get top average elapsed time queries for entire instance" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name], 
REPLACE(REPLACE(LEFT(t.[text], 255), CHAR(10),''), CHAR(13),'') AS [Short Query Text],  
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time],
qs.min_elapsed_time, qs.max_elapsed_time, qs.last_elapsed_time,
qs.execution_count AS [Execution Count],  
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads], 
qs.total_physical_reads/qs.execution_count AS [Avg Physical Reads], 
qs.total_worker_time/qs.execution_count AS [Avg Worker Time],
qs.creation_time AS [Creation Time],
qp.query_plan AS [QueryPlan] -- comment out this column if copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
ORDER BY qs.total_elapsed_time/qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   

// Helps you find the most expensive queries from a memory perspective across the entire instance
// Can also help track down parameter sniffing issues


// Get top average elapsed time queries for entire instance (Query 47) (Top Avg Elapsed Time Queries)-->
    <Query id="47" name="Top Avg Elapsed Time Queries" description="Get top average elapsed time queries for entire instance" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name], 
REPLACE(REPLACE(LEFT(t.[text], 255), CHAR(10),''), CHAR(13),'') AS [Short Query Text],  
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time],
qs.min_elapsed_time, qs.max_elapsed_time, qs.last_elapsed_time,
qs.execution_count AS [Execution Count],  
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads], 
qs.total_physical_reads/qs.execution_count AS [Avg Physical Reads], 
qs.total_worker_time/qs.execution_count AS [Avg Worker Time],
qs.creation_time AS [Creation Time], 
qp.query_plan AS [QueryPlan] -- comment out this column if copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
ORDER BY qs.total_elapsed_time/qs.execution_count DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a write I/O perspective
// You should look at this if you see signs of I/O pressure or of memory pressure


// Lists the top statements by average input/output usage for the current database  (Query 39) (Top IO Statements)-->
    <Query id="39" name="Top IO Statements" description="Lists the top statements by average input/output usage for the current database" file="SQL Server 2005.sql" fileVersion="9.0.0" level="db" longTextColumns="Query Text"><![CDATA[
SELECT TOP(50) OBJECT_NAME(qt.objectid, dbid) AS [SP Name],
(qs.total_logical_reads + qs.total_logical_writes) /qs.execution_count AS [Avg IO], qs.execution_count AS [Execution Count],
SUBSTRING(qt.[text],qs.statement_start_offset/2, 
	(CASE 
		WHEN qs.statement_end_offset = -1 
	 THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
		ELSE qs.statement_end_offset 
	 END - qs.statement_start_offset)/2) AS [Query Text]	
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS qt
WHERE qt.[dbid] = DB_ID()
ORDER BY [Avg IO] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a write I/O perspective
// You should look at this if you see signs of I/O pressure or of memory pressure


// Lists the top statements by average input/output usage for the current database  (Query 50) (Top IO Statements)-->
    <Query id="50" name="Top IO Statements" description="Lists the top statements by average input/output usage for the current database" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db" longTextColumns="Query Text"><![CDATA[
SELECT TOP(50) OBJECT_NAME(qt.objectid, dbid) AS [SP Name],
(qs.total_logical_reads + qs.total_logical_writes) /qs.execution_count AS [Avg IO], qs.execution_count AS [Execution Count],
SUBSTRING(qt.[text],qs.statement_start_offset/2, 
	(CASE 
		WHEN qs.statement_end_offset = -1 
	 THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
		ELSE qs.statement_end_offset 
	 END - qs.statement_start_offset)/2) AS [Query Text]	
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS qt
WHERE qt.[dbid] = DB_ID()
ORDER BY [Avg IO] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a write I/O perspective
// You should look at this if you see signs of I/O pressure or of memory pressure


// Lists the top statements by average input/output usage for the current database  (Query 46) (Top IO Statements)-->
    <Query id="46" name="Top IO Statements" description="Lists the top statements by average input/output usage for the current database" file="SQL Server 2008.sql" fileVersion="10.0.0" level="db" longTextColumns="Query Text"><![CDATA[
SELECT TOP(50) OBJECT_NAME(qt.objectid, dbid) AS [SP Name],
(qs.total_logical_reads + qs.total_logical_writes) /qs.execution_count AS [Avg IO], qs.execution_count AS [Execution Count],
SUBSTRING(qt.[text],qs.statement_start_offset/2, 
	(CASE 
		WHEN qs.statement_end_offset = -1 
	 THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
		ELSE qs.statement_end_offset 
	 END - qs.statement_start_offset)/2) AS [Query Text]	
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS qt
WHERE qt.[dbid] = DB_ID()
ORDER BY [Avg IO] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a write I/O perspective
// You should look at this if you see signs of I/O pressure or of memory pressure


// Lists the top statements by average input/output usage for the current database  (Query 52) (Top IO Statements)-->
    <Query id="52" name="Top IO Statements" description="Lists the top statements by average input/output usage for the current database" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db" longTextColumns="Query Text"><![CDATA[
SELECT TOP(50) OBJECT_NAME(qt.objectid, dbid) AS [SP Name],
(qs.total_logical_reads + qs.total_logical_writes) /qs.execution_count AS [Avg IO], qs.execution_count AS [Execution Count],
SUBSTRING(qt.[text],qs.statement_start_offset/2, 
	(CASE 
		WHEN qs.statement_end_offset = -1 
	 THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
		ELSE qs.statement_end_offset 
	 END - qs.statement_start_offset)/2) AS [Query Text]	
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS qt
WHERE qt.[dbid] = DB_ID()
ORDER BY [Avg IO] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a write I/O perspective
// You should look at this if you see signs of I/O pressure or of memory pressure


// Lists the top statements by average input/output usage for the current database  (Query 58) (Top IO Statements)-->
    <Query id="58" name="Top IO Statements" description="Lists the top statements by average input/output usage for the current database" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db" longTextColumns="Query Text"><![CDATA[
SELECT TOP(50) OBJECT_NAME(qt.objectid, dbid) AS [SP Name],
(qs.total_logical_reads + qs.total_logical_writes) /qs.execution_count AS [Avg IO], qs.execution_count AS [Execution Count],
SUBSTRING(qt.[text],qs.statement_start_offset/2, 
	(CASE 
		WHEN qs.statement_end_offset = -1 
	 THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
		ELSE qs.statement_end_offset 
	 END - qs.statement_start_offset)/2) AS [Query Text]	
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS qt
WHERE qt.[dbid] = DB_ID()
ORDER BY [Avg IO] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a write I/O perspective
// You should look at this if you see signs of I/O pressure or of memory pressure


// Lists the top statements by average input/output usage for the current database  (Query 60) (Top IO Statements)-->
    <Query id="60" name="Top IO Statements" description="Lists the top statements by average input/output usage for the current database" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db" longTextColumns="Query Text"><![CDATA[
SELECT TOP(50) OBJECT_NAME(qt.objectid, dbid) AS [SP Name],
(qs.total_logical_reads + qs.total_logical_writes) /qs.execution_count AS [Avg IO], qs.execution_count AS [Execution Count],
SUBSTRING(qt.[text],qs.statement_start_offset/2, 
	(CASE 
		WHEN qs.statement_end_offset = -1 
	 THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
		ELSE qs.statement_end_offset 
	 END - qs.statement_start_offset)/2) AS [Query Text]	
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS qt
WHERE qt.[dbid] = DB_ID()
ORDER BY [Avg IO] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This helps you find the most expensive cached stored procedures from a write I/O perspective
// You should look at this if you see signs of I/O pressure or of memory pressure


// Lists the top statements by average input/output usage for the current database  (Query 60) (Top IO Statements)-->
    <Query id="60" name="Top IO Statements" description="Lists the top statements by average input/output usage for the current database" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db" longTextColumns="Query Text"><![CDATA[
SELECT TOP(50) OBJECT_NAME(qt.objectid, dbid) AS [SP Name],
(qs.total_logical_reads + qs.total_logical_writes) /qs.execution_count AS [Avg IO], qs.execution_count AS [Execution Count],
SUBSTRING(qt.[text],qs.statement_start_offset/2, 
	(CASE 
		WHEN qs.statement_end_offset = -1 
	 THEN LEN(CONVERT(nvarchar(max), qt.[text])) * 2 
		ELSE qs.statement_end_offset 
	 END - qs.statement_start_offset)/2) AS [Query Text]	
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS qt
WHERE qt.[dbid] = DB_ID()
ORDER BY [Avg IO] DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you the text, type and size of single-use ad-hoc and prepared queries that waste space in the plan cache
// Enabling 'optimize for ad hoc workloads' for the instance can help (SQL Server 2008 and above only)
// Running DBCC FREESYSTEMCACHE ('SQL Plans') periodically may be required to better control this
// Enabling forced parameterization for the database can help, but test first!

// Plan cache, adhoc workloads and clearing the single-use plan cache bloat
// http://www.sqlskills.com/blogs/kimberly/plan-cache-adhoc-workloads-and-clearing-the-single-use-plan-cache-bloat/


// Get top total logical reads queries for entire instance (Query 41) (Top Logical Reads Queries)-->
    <Query id="41" name="Top Logical Reads Queries" description="Get top total logical reads queries for entire instance" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name],
qs.total_logical_reads AS [Total Logical Reads],
qs.min_logical_reads AS [Min Logical Reads],
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads],
qs.max_logical_reads AS [Max Logical Reads],   
qs.min_worker_time AS [Min Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.max_worker_time AS [Max Worker Time], 
qs.min_elapsed_time AS [Min Elapsed Time], 
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.max_elapsed_time AS [Max Elapsed Time],
qs.execution_count AS [Execution Count], qs.creation_time AS [Creation Time],
t.[text] AS [QueryText], 
qp.query_plan AS [QueryPlan] -- uncomment out these columns if not copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
ORDER BY qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you the text, type and size of single-use ad-hoc and prepared queries that waste space in the plan cache
// Enabling 'optimize for ad hoc workloads' for the instance can help (SQL Server 2008 and above only)
// Running DBCC FREESYSTEMCACHE ('SQL Plans') periodically may be required to better control this
// Enabling forced parameterization for the database can help, but test first!

// Plan cache, adhoc workloads and clearing the single-use plan cache bloat
// http://www.sqlskills.com/blogs/kimberly/plan-cache-adhoc-workloads-and-clearing-the-single-use-plan-cache-bloat/


// Get top total logical reads queries for entire instance (Query 46) (Top Logical Reads Queries)-->
    <Query id="46" name="Top Logical Reads Queries" description="Get top total logical reads queries for entire instance" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name],
qs.total_logical_reads AS [Total Logical Reads],
qs.min_logical_reads AS [Min Logical Reads],
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads],
qs.max_logical_reads AS [Max Logical Reads],   
qs.min_worker_time AS [Min Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.max_worker_time AS [Max Worker Time], 
qs.min_elapsed_time AS [Min Elapsed Time], 
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.max_elapsed_time AS [Max Elapsed Time],
qs.execution_count AS [Execution Count],
qs.creation_time AS [Creation Time],
t.[text] AS [QueryText], 
qp.query_plan AS [QueryPlan] -- uncomment out these columns if not copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
ORDER BY qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you the text, type and size of single-use ad-hoc and prepared queries that waste space in the plan cache
// Enabling 'optimize for ad hoc workloads' for the instance can help (SQL Server 2008 and above only)
// Running DBCC FREESYSTEMCACHE ('SQL Plans') periodically may be required to better control this
// Enabling forced parameterization for the database can help, but test first!

// Plan cache, adhoc workloads and clearing the single-use plan cache bloat
// http://www.sqlskills.com/blogs/kimberly/plan-cache-adhoc-workloads-and-clearing-the-single-use-plan-cache-bloat/


// Get top total logical reads queries for entire instance (Query 46) (Top Logical Reads Queries)-->
    <Query id="46" name="Top Logical Reads Queries" description="Get top total logical reads queries for entire instance" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name],
qs.total_logical_reads AS [Total Logical Reads],
qs.min_logical_reads AS [Min Logical Reads],
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads],
qs.max_logical_reads AS [Max Logical Reads],   
qs.min_worker_time AS [Min Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.max_worker_time AS [Max Worker Time], 
qs.min_elapsed_time AS [Min Elapsed Time], 
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.max_elapsed_time AS [Max Elapsed Time],
qs.execution_count AS [Execution Count], qs.creation_time AS [Creation Time],
t.[text] AS [QueryText],
qp.query_plan AS [QueryPlan] -- uncomment out these columns if not copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
ORDER BY qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you the text, type and size of single-use ad-hoc and prepared queries that waste space in the plan cache
// Enabling 'optimize for ad hoc workloads' for the instance can help (SQL Server 2008 and above only)
// Running DBCC FREESYSTEMCACHE ('SQL Plans') periodically may be required to better control this
// Enabling forced parameterization for the database can help, but test first!

// Plan cache, adhoc workloads and clearing the single-use plan cache bloat
// http://www.sqlskills.com/blogs/kimberly/plan-cache-adhoc-workloads-and-clearing-the-single-use-plan-cache-bloat/


// Get top total logical reads queries for entire instance (Query 46) (Top Logical Reads Queries)-->
    <Query id="46" name="Top Logical Reads Queries" description="Get top total logical reads queries for entire instance" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name],
qs.total_logical_reads AS [Total Logical Reads],
qs.min_logical_reads AS [Min Logical Reads],
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads],
qs.max_logical_reads AS [Max Logical Reads],   
qs.min_worker_time AS [Min Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.max_worker_time AS [Max Worker Time], 
qs.min_elapsed_time AS [Min Elapsed Time], 
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.max_elapsed_time AS [Max Elapsed Time],
qs.execution_count AS [Execution Count], qs.creation_time AS [Creation Time],
t.[text] AS [QueryText], 
qp.query_plan AS [QueryPlan] -- uncomment out these columns if not copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
ORDER BY qs.total_logical_reads DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you how much memory (in the buffer pool) 
// is being used by each database on the instance


// Clear Wait Stats with this command
// DBCC SQLPERF('sys.dm_os_wait_stats', CLEAR);

// Isolate top waits for server instance since last restart or wait statistics clear (Query 21) (Top Waits)-->
    <Query id="21" name="Top Waits" description="Isolate top waits for server instance since last restart or wait statistics clear" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
WITH [Waits] 
AS (SELECT wait_type, wait_time_ms/ 1000.0 AS [WaitS],
          (wait_time_ms - signal_wait_time_ms) / 1000.0 AS [ResourceS],
           signal_wait_time_ms / 1000.0 AS [SignalS],
           waiting_tasks_count AS [WaitCount],
           100.0 *  wait_time_ms / SUM (wait_time_ms) OVER() AS [Percentage],
           ROW_NUMBER() OVER(ORDER BY wait_time_ms DESC) AS [RowNum]
    FROM sys.dm_os_wait_stats WITH (NOLOCK)
    WHERE [wait_type] NOT IN (
        N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP',
		N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE',
        N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE',
        N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE',
		N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE',
        N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX',
        N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', 
		N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE',
        N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', N'ONDEMAND_TASK_QUEUE',
        N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
        N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH',
		N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP',
		N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY',
        N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK',
        N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP',
		N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES',
		N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT',
		N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'XE_DISPATCHER_JOIN',
        N'XE_DISPATCHER_WAIT', N'XE_TIMER_EVENT')
    AND waiting_tasks_count > 0)
SELECT
    MAX (W1.wait_type) AS [WaitType],
    CAST (MAX (W1.WaitS) AS DECIMAL (16,2)) AS [Wait_Sec],
    CAST (MAX (W1.ResourceS) AS DECIMAL (16,2)) AS [Resource_Sec],
    CAST (MAX (W1.SignalS) AS DECIMAL (16,2)) AS [Signal_Sec],
    MAX (W1.WaitCount) AS [Wait Count],
    CAST (MAX (W1.Percentage) AS DECIMAL (5,2)) AS [Wait Percentage],
    CAST ((MAX (W1.WaitS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgWait_Sec],
    CAST ((MAX (W1.ResourceS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgRes_Sec],
    CAST ((MAX (W1.SignalS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgSig_Sec]
FROM Waits AS W1
INNER JOIN Waits AS W2
ON W2.RowNum <= W1.RowNum
GROUP BY W1.RowNum
HAVING SUM (W2.Percentage) - MAX (W1.Percentage) < 99 -- percentage threshold
OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you how much memory (in the buffer pool) 
// is being used by each database on the instance


// Clear Wait Stats with this command
// DBCC SQLPERF('sys.dm_os_wait_stats', CLEAR);

// Isolate top waits for server instance since last restart or wait statistics clear (Query 27) (Top Waits)-->
    <Query id="27" name="Top Waits" description="Isolate top waits for server instance since last restart or wait statistics clear" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
WITH [Waits] 
AS (SELECT wait_type, wait_time_ms/ 1000.0 AS [WaitS],
          (wait_time_ms - signal_wait_time_ms) / 1000.0 AS [ResourceS],
           signal_wait_time_ms / 1000.0 AS [SignalS],
           waiting_tasks_count AS [WaitCount],
           100.0 *  wait_time_ms / SUM (wait_time_ms) OVER() AS [Percentage],
           ROW_NUMBER() OVER(ORDER BY wait_time_ms DESC) AS [RowNum]
    FROM sys.dm_os_wait_stats WITH (NOLOCK)
    WHERE [wait_type] NOT IN (
        N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP',
		N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE',
        N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE',
        N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE',
		N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE',
        N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX',
        N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', 
		N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE',
        N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', N'ONDEMAND_TASK_QUEUE',
        N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
        N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH',
		N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP',
		N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY',
        N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK',
        N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP',
		N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES',
		N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT',
		N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'XE_DISPATCHER_JOIN',
        N'XE_DISPATCHER_WAIT', N'XE_TIMER_EVENT')
    AND waiting_tasks_count > 0)
SELECT
    MAX (W1.wait_type) AS [WaitType],
    CAST (MAX (W1.WaitS) AS DECIMAL (16,2)) AS [Wait_Sec],
    CAST (MAX (W1.ResourceS) AS DECIMAL (16,2)) AS [Resource_Sec],
    CAST (MAX (W1.SignalS) AS DECIMAL (16,2)) AS [Signal_Sec],
    MAX (W1.WaitCount) AS [Wait Count],
    CAST (MAX (W1.Percentage) AS DECIMAL (5,2)) AS [Wait Percentage],
    CAST ((MAX (W1.WaitS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgWait_Sec],
    CAST ((MAX (W1.ResourceS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgRes_Sec],
    CAST ((MAX (W1.SignalS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgSig_Sec]
FROM Waits AS W1
INNER JOIN Waits AS W2
ON W2.RowNum <= W1.RowNum
GROUP BY W1.RowNum
HAVING SUM (W2.Percentage) - MAX (W1.Percentage) < 99 -- percentage threshold
OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you how much memory (in the buffer pool) 
// is being used by each database on the instance


// Clear Wait Stats with this command
// DBCC SQLPERF('sys.dm_os_wait_stats', CLEAR);

// Isolate top waits for server instance since last restart or wait statistics clear (Query 23) (Top Waits)-->
    <Query id="23" name="Top Waits" description="Isolate top waits for server instance since last restart or wait statistics clear" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
WITH [Waits] 
AS (SELECT wait_type, wait_time_ms/ 1000.0 AS [WaitS],
          (wait_time_ms - signal_wait_time_ms) / 1000.0 AS [ResourceS],
           signal_wait_time_ms / 1000.0 AS [SignalS],
           waiting_tasks_count AS [WaitCount],
           100.0 *  wait_time_ms / SUM (wait_time_ms) OVER() AS [Percentage],
           ROW_NUMBER() OVER(ORDER BY wait_time_ms DESC) AS [RowNum]
    FROM sys.dm_os_wait_stats WITH (NOLOCK)
    WHERE [wait_type] NOT IN (
        N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP',
		N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE',
        N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE',
        N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE',
		N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE',
        N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX',
        N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', 
		N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE',
        N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', N'ONDEMAND_TASK_QUEUE',
        N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
        N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH',
		N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP',
		N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY',
        N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK',
        N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP',
		N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES',
		N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT',
		N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'XE_DISPATCHER_JOIN',
        N'XE_DISPATCHER_WAIT', N'XE_TIMER_EVENT')
    AND waiting_tasks_count > 0)
SELECT
    MAX (W1.wait_type) AS [WaitType],
    CAST (MAX (W1.WaitS) AS DECIMAL (16,2)) AS [Wait_Sec],
    CAST (MAX (W1.ResourceS) AS DECIMAL (16,2)) AS [Resource_Sec],
    CAST (MAX (W1.SignalS) AS DECIMAL (16,2)) AS [Signal_Sec],
    MAX (W1.WaitCount) AS [Wait Count],
    CAST (MAX (W1.Percentage) AS DECIMAL (5,2)) AS [Wait Percentage],
    CAST ((MAX (W1.WaitS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgWait_Sec],
    CAST ((MAX (W1.ResourceS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgRes_Sec],
    CAST ((MAX (W1.SignalS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgSig_Sec]
FROM Waits AS W1
INNER JOIN Waits AS W2
ON W2.RowNum <= W1.RowNum
GROUP BY W1.RowNum
HAVING SUM (W2.Percentage) - MAX (W1.Percentage) < 99 -- percentage threshold
OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you how much memory (in the buffer pool) 
// is being used by each database on the instance


// Clear Wait Stats with this command
// DBCC SQLPERF('sys.dm_os_wait_stats', CLEAR);

// Isolate top waits for server instance since last restart or wait statistics clear  (Query 31) (Top Waits)-->
    <Query id="31" name="Top Waits" description="Isolate top waits for server instance since last restart or wait statistics clear" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
WITH [Waits] 
AS (SELECT wait_type, wait_time_ms/ 1000.0 AS [WaitS],
          (wait_time_ms - signal_wait_time_ms) / 1000.0 AS [ResourceS],
           signal_wait_time_ms / 1000.0 AS [SignalS],
           waiting_tasks_count AS [WaitCount],
           100.0 *  wait_time_ms / SUM (wait_time_ms) OVER() AS [Percentage],
           ROW_NUMBER() OVER(ORDER BY wait_time_ms DESC) AS [RowNum]
    FROM sys.dm_os_wait_stats WITH (NOLOCK)
    WHERE [wait_type] NOT IN (
        N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP',
		N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE',
        N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE',
        N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE',
		N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE',
        N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX',
        N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', 
		N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE',
        N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', N'ONDEMAND_TASK_QUEUE',
        N'PREEMPTIVE_OS_QUERYREGISTRY', 
		N'PWAIT_ALL_COMPONENTS_INITIALIZED', 
		N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
        N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH',
		N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP',
		N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY',
        N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK',
        N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP',
		N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES',
		N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT',
		N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'XE_DISPATCHER_JOIN',
        N'XE_DISPATCHER_WAIT', N'XE_TIMER_EVENT')
    AND waiting_tasks_count > 0)
SELECT
    MAX (W1.wait_type) AS [WaitType],
    CAST (MAX (W1.WaitS) AS DECIMAL (16,2)) AS [Wait_Sec],
    CAST (MAX (W1.ResourceS) AS DECIMAL (16,2)) AS [Resource_Sec],
    CAST (MAX (W1.SignalS) AS DECIMAL (16,2)) AS [Signal_Sec],
    MAX (W1.WaitCount) AS [Wait Count],
    CAST (MAX (W1.Percentage) AS DECIMAL (5,2)) AS [Wait Percentage],
    CAST ((MAX (W1.WaitS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgWait_Sec],
    CAST ((MAX (W1.ResourceS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgRes_Sec],
    CAST ((MAX (W1.SignalS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgSig_Sec]
FROM Waits AS W1
INNER JOIN Waits AS W2
ON W2.RowNum <= W1.RowNum
GROUP BY W1.RowNum
HAVING SUM (W2.Percentage) - MAX (W1.Percentage) < 99 -- percentage threshold
OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you how much memory (in the buffer pool) 
// is being used by each database on the instance


// Clear Wait Stats with this command
// DBCC SQLPERF('sys.dm_os_wait_stats', CLEAR);

// Isolate top waits for server instance since last restart or wait statistics clear  (Query 36) (Top Waits)-->
    <Query id="36" name="Top Waits" description="Isolate top waits for server instance since last restart or wait statistics clear" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
WITH [Waits] 
AS (SELECT wait_type, wait_time_ms/ 1000.0 AS [WaitS],
          (wait_time_ms - signal_wait_time_ms) / 1000.0 AS [ResourceS],
           signal_wait_time_ms / 1000.0 AS [SignalS],
           waiting_tasks_count AS [WaitCount],
           100.0 *  wait_time_ms / SUM (wait_time_ms) OVER() AS [Percentage],
           ROW_NUMBER() OVER(ORDER BY wait_time_ms DESC) AS [RowNum]
    FROM sys.dm_os_wait_stats WITH (NOLOCK)
    WHERE [wait_type] NOT IN (
        N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP',
		N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE',
        N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE',
        N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE',
		N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE',
        N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX',
        N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', 
		N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE',
        N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', N'ONDEMAND_TASK_QUEUE',
        N'PWAIT_ALL_COMPONENTS_INITIALIZED', 
		N'PREEMPTIVE_OS_AUTHENTICATIONOPS', N'PREEMPTIVE_OS_CREATEFILE', N'PREEMPTIVE_OS_GENERICOPS',
		N'PREEMPTIVE_OS_LIBRARYOPS', N'PREEMPTIVE_OS_QUERYREGISTRY',
		N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
        N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'QDS_SHUTDOWN_QUEUE', N'REQUEST_FOR_DEADLOCK_SEARCH',
		N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP',
		N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY',
        N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK',
        N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP',
		N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES',
		N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT',
		N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'XE_DISPATCHER_JOIN',
        N'XE_DISPATCHER_WAIT', N'XE_TIMER_EVENT')
    AND waiting_tasks_count > 0)
SELECT
    MAX (W1.wait_type) AS [WaitType],
    CAST (MAX (W1.WaitS) AS DECIMAL (16,2)) AS [Wait_Sec],
    CAST (MAX (W1.ResourceS) AS DECIMAL (16,2)) AS [Resource_Sec],
    CAST (MAX (W1.SignalS) AS DECIMAL (16,2)) AS [Signal_Sec],
    MAX (W1.WaitCount) AS [Wait Count],
    CAST (MAX (W1.Percentage) AS DECIMAL (5,2)) AS [Wait Percentage],
    CAST ((MAX (W1.WaitS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgWait_Sec],
    CAST ((MAX (W1.ResourceS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgRes_Sec],
    CAST ((MAX (W1.SignalS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgSig_Sec]
FROM Waits AS W1
INNER JOIN Waits AS W2
ON W2.RowNum <= W1.RowNum
GROUP BY W1.RowNum
HAVING SUM (W2.Percentage) - MAX (W1.Percentage) < 99 -- percentage threshold
OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you how much memory (in the buffer pool) 
// is being used by each database on the instance


// Clear Wait Stats with this command
// DBCC SQLPERF('sys.dm_os_wait_stats', CLEAR);

// Isolate top waits for server instance since last restart or wait statistics clear  (Query 36) (Top Waits)-->
    <Query id="36" name="Top Waits" description="Isolate top waits for server instance since last restart or wait statistics clear" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
WITH [Waits] 
AS (SELECT wait_type, wait_time_ms/ 1000.0 AS [WaitS],
          (wait_time_ms - signal_wait_time_ms) / 1000.0 AS [ResourceS],
           signal_wait_time_ms / 1000.0 AS [SignalS],
           waiting_tasks_count AS [WaitCount],
           100.0 *  wait_time_ms / SUM (wait_time_ms) OVER() AS [Percentage],
           ROW_NUMBER() OVER(ORDER BY wait_time_ms DESC) AS [RowNum]
    FROM sys.dm_os_wait_stats WITH (NOLOCK)
    WHERE [wait_type] NOT IN (
        N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP',
		N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE',
        N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE',
        N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE',
		N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE',
        N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX',
        N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', 
		N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE',
        N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', 
		N'MEMORY_ALLOCATION_EXT', N'ONDEMAND_TASK_QUEUE',
		N'PREEMPTIVE_OS_LIBRARYOPS', N'PREEMPTIVE_OS_COMOPS', N'PREEMPTIVE_OS_CRYPTOPS',
		N'PREEMPTIVE_OS_PIPEOPS', N'PREEMPTIVE_OS_AUTHENTICATIONOPS',
		N'PREEMPTIVE_OS_GENERICOPS', N'PREEMPTIVE_OS_VERIFYTRUST',
		N'PREEMPTIVE_OS_FILEOPS', N'PREEMPTIVE_OS_DEVICEOPS', N'PREEMPTIVE_OS_QUERYREGISTRY',
		N'PREEMPTIVE_OS_WRITEFILE',
		N'PREEMPTIVE_XE_CALLBACKEXECUTE', N'PREEMPTIVE_XE_DISPATCHER',
		N'PREEMPTIVE_XE_GETTARGETSTATE', N'PREEMPTIVE_XE_SESSIONCOMMIT',
		N'PREEMPTIVE_XE_TARGETINIT', N'PREEMPTIVE_XE_TARGETFINALIZE',
        N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'PWAIT_DIRECTLOGCONSUMER_GETNEXT',
		N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
		N'QDS_ASYNC_QUEUE',
        N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH',
		N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP',
		N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY',
        N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK',
        N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP',
		N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES',
		N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT',
		N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'WAIT_XTP_RECOVERY',
		N'XE_BUFFERMGR_ALLPROCESSED_EVENT', N'XE_DISPATCHER_JOIN',
        N'XE_DISPATCHER_WAIT', N'XE_LIVE_TARGET_TVF', N'XE_TIMER_EVENT')
    AND waiting_tasks_count > 0)
SELECT
    MAX (W1.wait_type) AS [WaitType],
    CAST (MAX (W1.WaitS) AS DECIMAL (16,2)) AS [Wait_Sec],
    CAST (MAX (W1.ResourceS) AS DECIMAL (16,2)) AS [Resource_Sec],
    CAST (MAX (W1.SignalS) AS DECIMAL (16,2)) AS [Signal_Sec],
    MAX (W1.WaitCount) AS [Wait Count],
    CAST (MAX (W1.Percentage) AS DECIMAL (5,2)) AS [Wait Percentage],
    CAST ((MAX (W1.WaitS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgWait_Sec],
    CAST ((MAX (W1.ResourceS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgRes_Sec],
    CAST ((MAX (W1.SignalS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgSig_Sec]
FROM Waits AS W1
INNER JOIN Waits AS W2
ON W2.RowNum <= W1.RowNum
GROUP BY W1.RowNum
HAVING SUM (W2.Percentage) - MAX (W1.Percentage) < 99 -- percentage threshold
OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Tells you how much memory (in the buffer pool) 
// is being used by each database on the instance


// Clear Wait Stats with this command
// DBCC SQLPERF('sys.dm_os_wait_stats', CLEAR);

// Isolate top waits for server instance since last restart or wait statistics clear  (Query 36) (Top Waits)-->
    <Query id="36" name="Top Waits" description="Isolate top waits for server instance since last restart or wait statistics clear" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
WITH [Waits] 
AS (SELECT wait_type, wait_time_ms/ 1000.0 AS [WaitS],
          (wait_time_ms - signal_wait_time_ms) / 1000.0 AS [ResourceS],
           signal_wait_time_ms / 1000.0 AS [SignalS],
           waiting_tasks_count AS [WaitCount],
           100.0 *  wait_time_ms / SUM (wait_time_ms) OVER() AS [Percentage],
           ROW_NUMBER() OVER(ORDER BY wait_time_ms DESC) AS [RowNum]
    FROM sys.dm_os_wait_stats WITH (NOLOCK)
    WHERE [wait_type] NOT IN (
        N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP',
		N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE',
        N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE',
        N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE',
		N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE',
        N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX',
        N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', 
		N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE',
        N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', 
		N'MEMORY_ALLOCATION_EXT', N'ONDEMAND_TASK_QUEUE',
		N'PREEMPTIVE_OS_LIBRARYOPS', N'PREEMPTIVE_OS_COMOPS', N'PREEMPTIVE_OS_CRYPTOPS',
		N'PREEMPTIVE_OS_PIPEOPS', N'PREEMPTIVE_OS_AUTHENTICATIONOPS',
		N'PREEMPTIVE_OS_GENERICOPS', N'PREEMPTIVE_OS_VERIFYTRUST',
		N'PREEMPTIVE_OS_FILEOPS', N'PREEMPTIVE_OS_DEVICEOPS', N'PREEMPTIVE_OS_QUERYREGISTRY',
		N'PREEMPTIVE_OS_WRITEFILE',
		N'PREEMPTIVE_XE_CALLBACKEXECUTE', N'PREEMPTIVE_XE_DISPATCHER',
		N'PREEMPTIVE_XE_GETTARGETSTATE', N'PREEMPTIVE_XE_SESSIONCOMMIT',
		N'PREEMPTIVE_XE_TARGETINIT', N'PREEMPTIVE_XE_TARGETFINALIZE',
        N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'PWAIT_DIRECTLOGCONSUMER_GETNEXT',
		N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP',
		N'QDS_ASYNC_QUEUE',
        N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH',
		N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP',
		N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY',
        N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK',
        N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP',
		N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES',
		N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT',
		N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'WAIT_XTP_RECOVERY',
		N'XE_BUFFERMGR_ALLPROCESSED_EVENT', N'XE_DISPATCHER_JOIN',
        N'XE_DISPATCHER_WAIT', N'XE_LIVE_TARGET_TVF', N'XE_TIMER_EVENT')
    AND waiting_tasks_count > 0)
SELECT
    MAX (W1.wait_type) AS [WaitType],
    CAST (MAX (W1.WaitS) AS DECIMAL (16,2)) AS [Wait_Sec],
    CAST (MAX (W1.ResourceS) AS DECIMAL (16,2)) AS [Resource_Sec],
    CAST (MAX (W1.SignalS) AS DECIMAL (16,2)) AS [Signal_Sec],
    MAX (W1.WaitCount) AS [Wait Count],
    CAST (MAX (W1.Percentage) AS DECIMAL (5,2)) AS [Wait Percentage],
    CAST ((MAX (W1.WaitS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgWait_Sec],
    CAST ((MAX (W1.ResourceS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgRes_Sec],
    CAST ((MAX (W1.SignalS) / MAX (W1.WaitCount)) AS DECIMAL (16,4)) AS [AvgSig_Sec]
FROM Waits AS W1
INNER JOIN Waits AS W2
ON W2.RowNum <= W1.RowNum
GROUP BY W1.RowNum
HAVING SUM (W2.Percentage) - MAX (W1.Percentage) < 99 -- percentage threshold
OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at the trend over the entire period. 
// Also look at high sustained Other Process CPU Utilization values


// Get top total worker time queries for entire instance (Query 33) (Top Worker Time Queries)-->
    <Query id="33" name="Top Worker Time Queries" description="Get top total worker time queries for entire instance" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server" longTextColumns="Query Text,QueryPlan"><![CDATA[
SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name], t.[text] AS [Query Text],  
qs.total_worker_time AS [Total Worker Time], qs.min_worker_time AS [Min Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.max_worker_time AS [Max Worker Time], qs.execution_count AS [Execution Count], 
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads], 
qs.total_physical_reads/qs.execution_count AS [Avg Physical Reads], qs.creation_time AS [Creation Time]
, qp.query_plan AS [QueryPlan] -- comment out this column if copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
ORDER BY qs.total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at the trend over the entire period. 
// Also look at high sustained Other Process CPU Utilization values


// Get top total worker time queries for entire instance (Query 29) (Top Worker Time Queries)-->
    <Query id="29" name="Top Worker Time Queries" description="Get top total worker time queries for entire instance" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server" longTextColumns="Query Text,QueryPlan"><![CDATA[
SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name], t.[text] AS [Query Text],  
qs.total_worker_time AS [Total Worker Time], qs.min_worker_time AS [Min Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.max_worker_time AS [Max Worker Time], qs.execution_count AS [Execution Count], 
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads], 
qs.total_physical_reads/qs.execution_count AS [Avg Physical Reads], qs.creation_time AS [Creation Time]
, qp.query_plan AS [QueryPlan] -- comment out this column if copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
ORDER BY qs.total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at the trend over the entire period 
// Also look at high sustained 'Other Process' CPU Utilization values



// Get top total worker time queries for entire instance (Query 36) (Top Worker Time Queries)-->
    <Query id="36" name="Top Worker Time Queries" description="Get top total worker time queries for entire instance" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name], 
qs.total_worker_time AS [Total Worker Time], qs.min_worker_time AS [Min Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.max_worker_time AS [Max Worker Time], 
qs.min_elapsed_time AS [Min Elapsed Time], 
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.max_elapsed_time AS [Max Elapsed Time],
qs.min_logical_reads AS [Min Logical Reads],
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads],
qs.max_logical_reads AS [Max Logical Reads], 
qs.execution_count AS [Execution Count], 
qs.creation_time AS [Creation Time],
t.[text] AS [QueryText], 
qp.query_plan AS [QueryPlan] -- uncomment out these columns if not copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
ORDER BY qs.total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at the trend over the entire period 
// Also look at high sustained 'Other Process' CPU Utilization values



// Get top total worker time queries for entire instance (Query 41) (Top Worker Time Queries)-->
    <Query id="41" name="Top Worker Time Queries" description="Get top total worker time queries for entire instance" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name], 
qs.total_worker_time AS [Total Worker Time], qs.min_worker_time AS [Min Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.max_worker_time AS [Max Worker Time], 
qs.min_elapsed_time AS [Min Elapsed Time], 
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.max_elapsed_time AS [Max Elapsed Time],
qs.min_logical_reads AS [Min Logical Reads],
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads],
qs.max_logical_reads AS [Max Logical Reads], 
qs.execution_count AS [Execution Count], qs.creation_time AS [Creation Time],
t.[text] AS [QueryText], 
qp.query_plan AS [QueryPlan] -- uncomment out these columns if not copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
ORDER BY qs.total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at the trend over the entire period 
// Also look at high sustained 'Other Process' CPU Utilization values



// Get top total worker time queries for entire instance (Query 41) (Top Worker Time Queries)-->
    <Query id="41" name="Top Worker Time Queries" description="Get top total worker time queries for entire instance" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name], 
qs.total_worker_time AS [Total Worker Time], qs.min_worker_time AS [Min Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.max_worker_time AS [Max Worker Time], 
qs.min_elapsed_time AS [Min Elapsed Time], 
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.max_elapsed_time AS [Max Elapsed Time],
qs.min_logical_reads AS [Min Logical Reads],
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads],
qs.max_logical_reads AS [Max Logical Reads], 
qs.execution_count AS [Execution Count], qs.creation_time AS [Creation Time],
t.[text] AS [QueryText], 
qp.query_plan AS [QueryPlan] -- uncomment out these columns if not copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
ORDER BY qs.total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Look at the trend over the entire period 
// Also look at high sustained 'Other Process' CPU Utilization values



// Get top total worker time queries for entire instance (Query 41) (Top Worker Time Queries)-->
    <Query id="41" name="Top Worker Time Queries" description="Get top total worker time queries for entire instance" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server" longTextColumns="QueryText,QueryPlan"><![CDATA[
SELECT TOP(50) DB_NAME(t.[dbid]) AS [Database Name], 
REPLACE(REPLACE(LEFT(t.[text], 255), CHAR(10),''), CHAR(13),'') AS [Short Query Text],  
qs.total_worker_time AS [Total Worker Time], qs.min_worker_time AS [Min Worker Time],
qs.total_worker_time/qs.execution_count AS [Avg Worker Time], 
qs.max_worker_time AS [Max Worker Time], 
qs.min_elapsed_time AS [Min Elapsed Time], 
qs.total_elapsed_time/qs.execution_count AS [Avg Elapsed Time], 
qs.max_elapsed_time AS [Max Elapsed Time],
qs.min_logical_reads AS [Min Logical Reads],
qs.total_logical_reads/qs.execution_count AS [Avg Logical Reads],
qs.max_logical_reads AS [Max Logical Reads], 
qs.execution_count AS [Execution Count], qs.creation_time AS [Creation Time],
t.[text] AS [QueryText],
qp.query_plan AS [QueryPlan] -- uncomment out these columns if not copying results to Excel
FROM sys.dm_exec_query_stats AS qs WITH (NOLOCK)
CROSS APPLY sys.dm_exec_sql_text(plan_handle) AS t 
CROSS APPLY sys.dm_exec_query_plan(plan_handle) AS qp 
ORDER BY qs.total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most I/O resources on the instance


// Get total buffer usage by database for current instance (Query 20) (Total Buffer Usage by Database)
// This make take some time to run on a busy instance-->
    <Query id="20" name="Total Buffer Usage by Database" description="Get total buffer usage by database for current instance" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
WITH AggregateBufferPoolUsage
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(COUNT(*) * 8/1024.0 AS DECIMAL (10,2))  AS [CachedSize]
FROM sys.dm_os_buffer_descriptors WITH (NOLOCK)
WHERE database_id <> 32767 -- ResourceDB
GROUP BY DB_NAME(database_id))
SELECT ROW_NUMBER() OVER(ORDER BY CachedSize DESC) AS [Buffer Pool Rank], [Database Name], CachedSize AS [Cached Size (MB)],
       CAST(CachedSize / SUM(CachedSize) OVER() * 100.0 AS DECIMAL(5,2)) AS [Buffer Pool Percent]
FROM AggregateBufferPoolUsage
ORDER BY [Buffer Pool Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most I/O resources on the instance


// Get total buffer usage by database for current instance  (Query 26) (Total Buffer Usage by Database)
// This make take some time to run on a busy instance-->
    <Query id="26" name="Total Buffer Usage by Database" description="Get total buffer usage by database for current instance" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
WITH AggregateBufferPoolUsage
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(COUNT(*) * 8/1024.0 AS DECIMAL (10,2))  AS [CachedSize]
FROM sys.dm_os_buffer_descriptors WITH (NOLOCK)
WHERE database_id <> 32767 -- ResourceDB
GROUP BY DB_NAME(database_id))
SELECT ROW_NUMBER() OVER(ORDER BY CachedSize DESC) AS [Buffer Pool Rank], [Database Name], CachedSize AS [Cached Size (MB)],
       CAST(CachedSize / SUM(CachedSize) OVER() * 100.0 AS DECIMAL(5,2)) AS [Buffer Pool Percent]
FROM AggregateBufferPoolUsage
ORDER BY [Buffer Pool Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most I/O resources on the instance


// Get total buffer usage by database for current instance  (Query 22) (Total Buffer Usage by Database)
// This make take some time to run on a busy instance-->
    <Query id="22" name="Total Buffer Usage by Database" description="Get total buffer usage by database for current instance" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
WITH AggregateBufferPoolUsage
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(COUNT(*) * 8/1024.0 AS DECIMAL (10,2))  AS [CachedSize]
FROM sys.dm_os_buffer_descriptors WITH (NOLOCK)
WHERE database_id <> 32767 -- ResourceDB
GROUP BY DB_NAME(database_id))
SELECT ROW_NUMBER() OVER(ORDER BY CachedSize DESC) AS [Buffer Pool Rank], [Database Name], CachedSize AS [Cached Size (MB)],
       CAST(CachedSize / SUM(CachedSize) OVER() * 100.0 AS DECIMAL(5,2)) AS [Buffer Pool Percent]
FROM AggregateBufferPoolUsage
ORDER BY [Buffer Pool Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most I/O resources on the instance


// Get total buffer usage by database for current instance  (Query 30) (Total Buffer Usage by Database)
// This make take some time to run on a busy instance-->
    <Query id="30" name="Total Buffer Usage by Database" description="Get total buffer usage by database for current instance" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
WITH AggregateBufferPoolUsage
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(COUNT(*) * 8/1024.0 AS DECIMAL (10,2))  AS [CachedSize]
FROM sys.dm_os_buffer_descriptors WITH (NOLOCK)
WHERE database_id <> 32767 -- ResourceDB
GROUP BY DB_NAME(database_id))
SELECT ROW_NUMBER() OVER(ORDER BY CachedSize DESC) AS [Buffer Pool Rank], [Database Name], CachedSize AS [Cached Size (MB)],
       CAST(CachedSize / SUM(CachedSize) OVER() * 100.0 AS DECIMAL(5,2)) AS [Buffer Pool Percent]
FROM AggregateBufferPoolUsage
ORDER BY [Buffer Pool Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most I/O resources on the instance


// Get total buffer usage by database for current instance  (Query 35) (Total Buffer Usage by Database)
// This make take some time to run on a busy instance-->
    <Query id="35" name="Total Buffer Usage by Database" description="Get total buffer usage by database for current instance" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
WITH AggregateBufferPoolUsage
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(COUNT(*) * 8/1024.0 AS DECIMAL (10,2))  AS [CachedSize]
FROM sys.dm_os_buffer_descriptors WITH (NOLOCK)
WHERE database_id <> 32767 -- ResourceDB
GROUP BY DB_NAME(database_id))
SELECT ROW_NUMBER() OVER(ORDER BY CachedSize DESC) AS [Buffer Pool Rank], [Database Name], CachedSize AS [Cached Size (MB)],
       CAST(CachedSize / SUM(CachedSize) OVER() * 100.0 AS DECIMAL(5,2)) AS [Buffer Pool Percent]
FROM AggregateBufferPoolUsage
ORDER BY [Buffer Pool Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most I/O resources on the instance


// Get total buffer usage by database for current instance  (Query 35) (Total Buffer Usage by Database)
// This make take some time to run on a busy instance-->
    <Query id="35" name="Total Buffer Usage by Database" description="Get total buffer usage by database for current instance" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
WITH AggregateBufferPoolUsage
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(COUNT(*) * 8/1024.0 AS DECIMAL (10,2))  AS [CachedSize]
FROM sys.dm_os_buffer_descriptors WITH (NOLOCK)
WHERE database_id <> 32767 -- ResourceDB
GROUP BY DB_NAME(database_id))
SELECT ROW_NUMBER() OVER(ORDER BY CachedSize DESC) AS [Buffer Pool Rank], [Database Name], CachedSize AS [Cached Size (MB)],
       CAST(CachedSize / SUM(CachedSize) OVER() * 100.0 AS DECIMAL(5,2)) AS [Buffer Pool Percent]
FROM AggregateBufferPoolUsage
ORDER BY [Buffer Pool Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps determine which database is using the most I/O resources on the instance


// Get total buffer usage by database for current instance  (Query 35) (Total Buffer Usage by Database)
// This make take some time to run on a busy instance-->
    <Query id="35" name="Total Buffer Usage by Database" description="Get total buffer usage by database for current instance" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
WITH AggregateBufferPoolUsage
AS
(SELECT DB_NAME(database_id) AS [Database Name],
CAST(COUNT(*) * 8/1024.0 AS DECIMAL (10,2))  AS [CachedSize]
FROM sys.dm_os_buffer_descriptors WITH (NOLOCK)
WHERE database_id <> 32767 -- ResourceDB
GROUP BY DB_NAME(database_id))
SELECT ROW_NUMBER() OVER(ORDER BY CachedSize DESC) AS [Buffer Pool Rank], [Database Name], CachedSize AS [Cached Size (MB)],
       CAST(CachedSize / SUM(CachedSize) OVER() * 100.0 AS DECIMAL(5,2)) AS [Buffer Pool Percent]
FROM AggregateBufferPoolUsage
ORDER BY [Buffer Pool Rank] OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// This query is helpful for troubleshooting blocking and deadlocking issues



// Look at UDF execution statistics (Query 75) (UDF Statistics)-->
    <Query id="75" name="UDF Statistics" description="Look at UDF execution statistics" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(object_id) AS [Function Name], execution_count,
	   total_worker_time, total_logical_reads, total_physical_reads,
       total_elapsed_time
FROM sys.dm_exec_function_stats WITH (NOLOCK) 
WHERE database_id = DB_ID()
ORDER BY total_worker_time DESC OPTION (RECOMPILE); 
]]></Query>
    <!--//////
   
// This query is helpful for troubleshooting blocking and deadlocking issues



// Look at UDF execution statistics (Query 75) (UDF Statistics)-->
    <Query id="75" name="UDF Statistics" description="Look at UDF execution statistics" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(object_id) AS [Function Name], execution_count,
	   total_worker_time, total_logical_reads, total_physical_reads,
       total_elapsed_time
FROM sys.dm_exec_function_stats WITH (NOLOCK) 
WHERE database_id = DB_ID()
ORDER BY total_worker_time DESC OPTION (RECOMPILE); 
]]></Query>
    <!--//////
   
// Helps you find the highest average elapsed time queries across the entire instance
// Can also help track down parameter sniffing issues


// Look at UDF execution statistics (Query 48) (UDF Stats by DB)-->
    <Query id="48" name="UDF Stats by DB" description="Look at UDF execution statistics" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT TOP (25) DB_NAME(database_id) AS [Database Name], 
		   OBJECT_NAME(object_id, database_id) AS [Function Name],
		   total_worker_time, execution_count, total_elapsed_time,  
           total_elapsed_time/execution_count AS [avg_elapsed_time],  
           last_elapsed_time, last_execution_time, cached_time 
FROM sys.dm_exec_function_stats WITH (NOLOCK) 
ORDER BY total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Helps you find the highest average elapsed time queries across the entire instance
// Can also help track down parameter sniffing issues


// Look at UDF execution statistics (Query 48) (UDF Stats by DB)-->
    <Query id="48" name="UDF Stats by DB" description="Look at UDF execution statistics" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT TOP (25) DB_NAME(database_id) AS [Database Name], 
		   OBJECT_NAME(object_id, database_id) AS [Function Name],
		   total_worker_time, execution_count, total_elapsed_time,  
           total_elapsed_time/execution_count AS [avg_elapsed_time],  
           last_elapsed_time, last_execution_time, cached_time 
FROM sys.dm_exec_function_stats WITH (NOLOCK) 
ORDER BY total_worker_time DESC OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Getting missing index information for all of the databases on the instance is very useful
// Look at last user seek time, number of user seeks to help determine source and importance
// Also look at avg_user_impact and avg_total_user_cost to help determine importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!



// Get VLF Counts for all databases on the instance (Query 17) (VLF Counts)
// (adapted from Michelle Ufford) -->
    <Query id="17" name="VLF Counts" description="Get VLF Counts for all databases on the instance" file="SQL Server 2005.sql" fileVersion="9.0.0" level="server"><![CDATA[
CREATE TABLE #VLFInfo (FileID  int,
					   FileSize bigint, StartOffset bigint,
					   FSeqNo      bigint, [Status]    bigint,
					   Parity      bigint, CreateLSN   numeric(38));
	 
CREATE TABLE #VLFCountResults(DatabaseName sysname, VLFCount int);
	 
EXEC sp_MSforeachdb N'Use [?]; 

				INSERT INTO #VLFInfo 
				EXEC sp_executesql N''DBCC LOGINFO([?])''; 
	 
				INSERT INTO #VLFCountResults 
				SELECT DB_NAME(), COUNT(*) 
				FROM #VLFInfo; 

				TRUNCATE TABLE #VLFInfo;'
	 
SELECT DatabaseName, VLFCount  
FROM #VLFCountResults
ORDER BY VLFCount DESC;
	 
DROP TABLE #VLFInfo;
DROP TABLE #VLFCountResults;
]]></Query>
    <!--//////
   
// Getting missing index information for all of the databases on the instance is very useful
// Look at last user seek time, number of user seeks to help determine source and importance
// Also look at avg_user_impact and avg_total_user_cost to help determine importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!



// Get VLF Counts for all databases on the instance (Query 23) (VLF Counts)
// (adapted from Michelle Ufford) -->
    <Query id="23" name="VLF Counts" description="Get VLF Counts for all databases on the instance" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
CREATE TABLE #VLFInfo (FileID  int,
					   FileSize bigint, StartOffset bigint,
					   FSeqNo      bigint, [Status]    bigint,
					   Parity      bigint, CreateLSN   numeric(38));
	 
CREATE TABLE #VLFCountResults(DatabaseName sysname, VLFCount int);
	 
EXEC sp_MSforeachdb N'Use [?]; 

				INSERT INTO #VLFInfo 
				EXEC sp_executesql N''DBCC LOGINFO([?])''; 
	 
				INSERT INTO #VLFCountResults 
				SELECT DB_NAME(), COUNT(*) 
				FROM #VLFInfo; 

				TRUNCATE TABLE #VLFInfo;'
	 
SELECT DatabaseName, VLFCount  
FROM #VLFCountResults
ORDER BY VLFCount DESC;
	 
DROP TABLE #VLFInfo;
DROP TABLE #VLFCountResults;
]]></Query>
    <!--//////
   
// Getting missing index information for all of the databases on the instance is very useful
// Look at last user seek time, number of user seeks to help determine source and importance
// Also look at avg_user_impact and avg_total_user_cost to help determine importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!



// Get VLF Counts for all databases on the instance (Query 19) (VLF Counts)
// (adapted from Michelle Ufford) -->
    <Query id="19" name="VLF Counts" description="Get VLF Counts for all databases on the instance" file="SQL Server 2008.sql" fileVersion="10.0.0" level="server"><![CDATA[
CREATE TABLE #VLFInfo (FileID  int,
					   FileSize bigint, StartOffset bigint,
					   FSeqNo      bigint, [Status]    bigint,
					   Parity      bigint, CreateLSN   numeric(38));
	 
CREATE TABLE #VLFCountResults(DatabaseName sysname, VLFCount int);
	 
EXEC sp_MSforeachdb N'Use [?]; 

				INSERT INTO #VLFInfo 
				EXEC sp_executesql N''DBCC LOGINFO([?])''; 
	 
				INSERT INTO #VLFCountResults 
				SELECT DB_NAME(), COUNT(*) 
				FROM #VLFInfo; 

				TRUNCATE TABLE #VLFInfo;'
	 
SELECT DatabaseName, VLFCount  
FROM #VLFCountResults
ORDER BY VLFCount DESC;
	 
DROP TABLE #VLFInfo;
DROP TABLE #VLFCountResults;
]]></Query>
    <!--//////
   
// Getting missing index information for all of the databases on the instance is very useful
// Look at last user seek time, number of user seeks to help determine source and importance
// Also look at avg_user_impact and avg_total_user_cost to help determine importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!



// Get VLF Counts for all databases on the instance (Query 27) (VLF Counts)
// (adapted from Michelle Ufford) -->
    <Query id="27" name="VLF Counts" description="Get VLF Counts for all databases on the instance" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
CREATE TABLE #VLFInfo (RecoveryUnitID int, FileID  int,
					   FileSize bigint, StartOffset bigint,
					   FSeqNo      bigint, [Status]    bigint,
					   Parity      bigint, CreateLSN   numeric(38));
	 
CREATE TABLE #VLFCountResults(DatabaseName sysname, VLFCount int);
	 
EXEC sp_MSforeachdb N'Use [?]; 

				INSERT INTO #VLFInfo 
				EXEC sp_executesql N''DBCC LOGINFO([?])''; 
	 
				INSERT INTO #VLFCountResults 
				SELECT DB_NAME(), COUNT(*) 
				FROM #VLFInfo; 

				TRUNCATE TABLE #VLFInfo;'
	 
SELECT DatabaseName, VLFCount  
FROM #VLFCountResults
ORDER BY VLFCount DESC;
	 
DROP TABLE #VLFInfo;
DROP TABLE #VLFCountResults;
]]></Query>
    <!--//////
   
// Getting missing index information for all of the databases on the instance is very useful
// Look at last user seek time, number of user seeks to help determine source and importance
// Also look at avg_user_impact and avg_total_user_cost to help determine importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!



// Get VLF Counts for all databases on the instance (Query 32) (VLF Counts)
// (adapted from Michelle Ufford) -->
    <Query id="32" name="VLF Counts" description="Get VLF Counts for all databases on the instance" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
CREATE TABLE #VLFInfo (RecoveryUnitID int, FileID  int,
					   FileSize bigint, StartOffset bigint,
					   FSeqNo      bigint, [Status]    bigint,
					   Parity      bigint, CreateLSN   numeric(38));
	 
CREATE TABLE #VLFCountResults(DatabaseName sysname, VLFCount int);
	 
EXEC sp_MSforeachdb N'Use [?]; 

				INSERT INTO #VLFInfo 
				EXEC sp_executesql N''DBCC LOGINFO([?])''; 
	 
				INSERT INTO #VLFCountResults 
				SELECT DB_NAME(), COUNT(*) 
				FROM #VLFInfo; 

				TRUNCATE TABLE #VLFInfo;'
	 
SELECT DatabaseName, VLFCount  
FROM #VLFCountResults
ORDER BY VLFCount DESC;
	 
DROP TABLE #VLFInfo;
DROP TABLE #VLFCountResults;
]]></Query>
    <!--//////
   
// Getting missing index information for all of the databases on the instance is very useful
// Look at last user seek time, number of user seeks to help determine source and importance
// Also look at avg_user_impact and avg_total_user_cost to help determine importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!



// Get VLF Counts for all databases on the instance (Query 32) (VLF Counts)
// (adapted from Michelle Ufford) -->
    <Query id="32" name="VLF Counts" description="Get VLF Counts for all databases on the instance" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
CREATE TABLE #VLFInfo (RecoveryUnitID int, FileID  int,
					   FileSize bigint, StartOffset bigint,
					   FSeqNo      bigint, [Status]    bigint,
					   Parity      bigint, CreateLSN   numeric(38));
	 
CREATE TABLE #VLFCountResults(DatabaseName sysname, VLFCount int);
	 
EXEC sp_MSforeachdb N'Use [?]; 

				INSERT INTO #VLFInfo 
				EXEC sp_executesql N''DBCC LOGINFO([?])''; 
	 
				INSERT INTO #VLFCountResults 
				SELECT DB_NAME(), COUNT(*) 
				FROM #VLFInfo; 

				TRUNCATE TABLE #VLFInfo;'
	 
SELECT DatabaseName, VLFCount  
FROM #VLFCountResults
ORDER BY VLFCount DESC;
	 
DROP TABLE #VLFInfo;
DROP TABLE #VLFCountResults;
]]></Query>
    <!--//////
   
// Getting missing index information for all of the databases on the instance is very useful
// Look at last user seek time, number of user seeks to help determine source and importance
// Also look at avg_user_impact and avg_total_user_cost to help determine importance
// SQL Server is overly eager to add included columns, so beware
// Do not just blindly add indexes that show up from this query!!!



// Get VLF Counts for all databases on the instance (Query 32) (VLF Counts)
// (adapted from Michelle Ufford) -->
    <Query id="32" name="VLF Counts" description="Get VLF Counts for all databases on the instance" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
CREATE TABLE #VLFInfo (RecoveryUnitID int, FileID  int,
					   FileSize bigint, StartOffset bigint,
					   FSeqNo      bigint, [Status]    bigint,
					   Parity      bigint, CreateLSN   numeric(38));
	 
CREATE TABLE #VLFCountResults(DatabaseName sysname, VLFCount int);
	 
EXEC sp_MSforeachdb N'Use [?]; 

				INSERT INTO #VLFInfo 
				EXEC sp_executesql N''DBCC LOGINFO([?])''; 
	 
				INSERT INTO #VLFCountResults 
				SELECT DB_NAME(), COUNT(*) 
				FROM #VLFInfo; 

				TRUNCATE TABLE #VLFInfo;'
	 
SELECT DatabaseName, VLFCount  
FROM #VLFCountResults
ORDER BY VLFCount DESC;
	 
DROP TABLE #VLFInfo;
DROP TABLE #VLFCountResults;
]]></Query>
    <!--//////  
   
// Helps discover possible problems with out-of-date statistics
// Also gives you an idea which indexes are the most active


// Look at most frequently modified indexes and statistics (Query 59) (Volatile Indexes)
// Requires SQL Server 2008 R2 SP2 or newer-->
    <Query id="59" name="Volatile Indexes" description="Look at most frequently modified indexes and statistics" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="db"><![CDATA[
SELECT o.name AS [Object Name], o.[object_id], o.type_desc, s.name AS [Statistics Name], 
       s.stats_id, s.no_recompute, s.auto_created, 
	   sp.modification_counter, sp.rows, sp.rows_sampled, sp.last_updated
FROM sys.objects AS o WITH (NOLOCK)
INNER JOIN sys.stats AS s WITH (NOLOCK)
ON s.object_id = o.object_id
CROSS APPLY sys.dm_db_stats_properties(s.object_id, s.stats_id) AS sp
WHERE o.type_desc NOT IN (N'SYSTEM_TABLE', N'INTERNAL_TABLE')
AND sp.modification_counter > 0
ORDER BY sp.modification_counter DESC, o.name OPTION (RECOMPILE);
]]></Query>
    <!--//////  
   
// Helps discover possible problems with out-of-date statistics
// Also gives you an idea which indexes are the most active

// sys.stats (Transact-SQL)
// https://msdn.microsoft.com/en-us/library/ms177623.aspx



// Look at most frequently modified indexes and statistics (Query 60) (Volatile Indexes)-->
    <Query id="60" name="Volatile Indexes" description="Look at most frequently modified indexes and statistics" file="SQL Server 2012.sql" fileVersion="11.0.0" level="db"><![CDATA[
SELECT o.[name] AS [Object Name], o.[object_id], o.[type_desc], s.[name] AS [Statistics Name], 
       s.stats_id, s.no_recompute, s.auto_created, s.is_temporary,
	   sp.modification_counter, sp.[rows], sp.rows_sampled, sp.last_updated
FROM sys.objects AS o WITH (NOLOCK)
INNER JOIN sys.stats AS s WITH (NOLOCK)
ON s.object_id = o.object_id
CROSS APPLY sys.dm_db_stats_properties(s.object_id, s.stats_id) AS sp
WHERE o.[type_desc] NOT IN (N'SYSTEM_TABLE', N'INTERNAL_TABLE')
AND sp.modification_counter > 0
ORDER BY sp.modification_counter DESC, o.name OPTION (RECOMPILE);
]]></Query>
    <!--//////  
   
// Helps discover possible problems with out-of-date statistics
// Also gives you an idea which indexes are the most active

// sys.stats (Transact-SQL)
// https://msdn.microsoft.com/en-us/library/ms177623.aspx



// Look at most frequently modified indexes and statistics (Query 66) (Volatile Indexes)-->
    <Query id="66" name="Volatile Indexes" description="Look at most frequently modified indexes and statistics" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT o.[name] AS [Object Name], o.[object_id], o.[type_desc], s.[name] AS [Statistics Name], 
       s.stats_id, s.no_recompute, s.auto_created, s.is_incremental, s.is_temporary,
	   sp.modification_counter, sp.[rows], sp.rows_sampled, sp.last_updated
FROM sys.objects AS o WITH (NOLOCK)
INNER JOIN sys.stats AS s WITH (NOLOCK)
ON s.object_id = o.object_id
CROSS APPLY sys.dm_db_stats_properties(s.object_id, s.stats_id) AS sp
WHERE o.[type_desc] NOT IN (N'SYSTEM_TABLE', N'INTERNAL_TABLE')
AND sp.modification_counter > 0
ORDER BY sp.modification_counter DESC, o.name OPTION (RECOMPILE);
]]></Query>
    <!--//////  
   
// Helps discover possible problems with out-of-date statistics
// Also gives you an idea which indexes are the most active

// sys.stats (Transact-SQL)
// https://msdn.microsoft.com/en-us/library/ms177623.aspx



// Look at most frequently modified indexes and statistics (Query 68) (Volatile Indexes)-->
    <Query id="68" name="Volatile Indexes" description="Look at most frequently modified indexes and statistics" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT o.[name] AS [Object Name], o.[object_id], o.[type_desc], s.[name] AS [Statistics Name], 
       s.stats_id, s.no_recompute, s.auto_created, s.is_incremental, s.is_temporary,
	   sp.modification_counter, sp.[rows], sp.rows_sampled, sp.last_updated
FROM sys.objects AS o WITH (NOLOCK)
INNER JOIN sys.stats AS s WITH (NOLOCK)
ON s.object_id = o.object_id
CROSS APPLY sys.dm_db_stats_properties(s.object_id, s.stats_id) AS sp
WHERE o.[type_desc] NOT IN (N'SYSTEM_TABLE', N'INTERNAL_TABLE')
AND sp.modification_counter > 0
ORDER BY sp.modification_counter DESC, o.name OPTION (RECOMPILE);
]]></Query>
    <!--//////  
   
// Helps discover possible problems with out-of-date statistics
// Also gives you an idea which indexes are the most active

// sys.stats (Transact-SQL)
// https://msdn.microsoft.com/en-us/library/ms177623.aspx



// Look at most frequently modified indexes and statistics (Query 68) (Volatile Indexes)-->
    <Query id="68" name="Volatile Indexes" description="Look at most frequently modified indexes and statistics" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT o.[name] AS [Object Name], o.[object_id], o.[type_desc], s.[name] AS [Statistics Name], 
       s.stats_id, s.no_recompute, s.auto_created, s.is_incremental, s.is_temporary,
	   sp.modification_counter, sp.[rows], sp.rows_sampled, sp.last_updated
FROM sys.objects AS o WITH (NOLOCK)
INNER JOIN sys.stats AS s WITH (NOLOCK)
ON s.object_id = o.object_id
CROSS APPLY sys.dm_db_stats_properties(s.object_id, s.stats_id) AS sp
WHERE o.[type_desc] NOT IN (N'SYSTEM_TABLE', N'INTERNAL_TABLE')
AND sp.modification_counter > 0
ORDER BY sp.modification_counter DESC, o.name OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Things to look at:
// Are data files and log files on different drives?
// Is everything on the C: drive?
// Is TempDB on dedicated drives?
// Is there only one TempDB data file?
// Are all of the TempDB data files the same size?
// Are there multiple data files for user databases?
// Is percent growth enabled for any files (which is bad)?


// Volume info for all LUNS that have database files on the current instance (SQL Server 2008 R2 SP1 or greater)  (Query 17) (Volume Info)-->
    <Query id="17" name="Volume Info" description="Volume info for all LUNS that have database files on the current instance (SQL Server 2008 R2 SP1 or greater)" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT DISTINCT vs.volume_mount_point, vs.file_system_type, 
vs.logical_volume_name, CONVERT(DECIMAL(18,2),vs.total_bytes/1073741824.0) AS [Total Size (GB)],
CONVERT(DECIMAL(18,2),vs.available_bytes/1073741824.0) AS [Available Size (GB)],  
CAST(CAST(vs.available_bytes AS FLOAT)/ CAST(vs.total_bytes AS FLOAT) AS DECIMAL(18,2)) * 100 AS [Space Free %] 
FROM sys.master_files AS f WITH (NOLOCK)
CROSS APPLY sys.dm_os_volume_stats(f.database_id, f.[file_id]) AS vs OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Things to look at:
// Are data files and log files on different drives?
// Is everything on the C: drive?
// Is tempdb on dedicated drives?
// Is there only one tempdb data file?
// Are all of the tempdb data files the same size?
// Are there multiple data files for user databases?
// Is percent growth enabled for any files (which is bad)?


// Volume info for all LUNS that have database files on the current instance (Query 21) (Volume Info)-->
    <Query id="21" name="Volume Info" description="Volume info for all LUNS that have database files on the current instance" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT DISTINCT vs.volume_mount_point, vs.file_system_type, 
vs.logical_volume_name, CONVERT(DECIMAL(18,2),vs.total_bytes/1073741824.0) AS [Total Size (GB)],
CONVERT(DECIMAL(18,2), vs.available_bytes/1073741824.0) AS [Available Size (GB)],  
CONVERT(DECIMAL(18,2), vs.available_bytes * 1. / vs.total_bytes * 100.) AS [Space Free %]
FROM sys.master_files AS f WITH (NOLOCK)
CROSS APPLY sys.dm_os_volume_stats(f.database_id, f.[file_id]) AS vs 
ORDER BY vs.volume_mount_point OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Things to look at:
// Are data files and log files on different drives?
// Is everything on the C: drive?
// Is tempdb on dedicated drives?
// Is there only one tempdb data file?
// Are all of the tempdb data files the same size?
// Are there multiple data files for user databases?
// Is percent growth enabled for any files (which is bad)?


// Volume info for all LUNS that have database files on the current instance (Query 26) (Volume Info)-->
    <Query id="26" name="Volume Info" description="Volume info for all LUNS that have database files on the current instance" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT DISTINCT vs.volume_mount_point, vs.file_system_type, 
vs.logical_volume_name, CONVERT(DECIMAL(18,2),vs.total_bytes/1073741824.0) AS [Total Size (GB)],
CONVERT(DECIMAL(18,2), vs.available_bytes/1073741824.0) AS [Available Size (GB)],  
CONVERT(DECIMAL(18,2), vs.available_bytes * 1. / vs.total_bytes * 100.) AS [Space Free %]
FROM sys.master_files AS f WITH (NOLOCK)
CROSS APPLY sys.dm_os_volume_stats(f.database_id, f.[file_id]) AS vs 
ORDER BY vs.volume_mount_point OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Things to look at:
// Are data files and log files on different drives?
// Is everything on the C: drive?
// Is tempdb on dedicated drives?
// Is there only one tempdb data file?
// Are all of the tempdb data files the same size?
// Are there multiple data files for user databases?
// Is percent growth enabled for any files (which is bad)?


// Volume info for all LUNS that have database files on the current instance (Query 26) (Volume Info)-->
    <Query id="26" name="Volume Info" description="Volume info for all LUNS that have database files on the current instance" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT DISTINCT vs.volume_mount_point, vs.file_system_type, 
vs.logical_volume_name, CONVERT(DECIMAL(18,2),vs.total_bytes/1073741824.0) AS [Total Size (GB)],
CONVERT(DECIMAL(18,2), vs.available_bytes/1073741824.0) AS [Available Size (GB)],  
CONVERT(DECIMAL(18,2), vs.available_bytes * 1. / vs.total_bytes * 100.) AS [Space Free %]
FROM sys.master_files AS f WITH (NOLOCK)
CROSS APPLY sys.dm_os_volume_stats(f.database_id, f.[file_id]) AS vs 
ORDER BY vs.volume_mount_point OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Things to look at:
// Are data files and log files on different drives?
// Is everything on the C: drive?
// Is tempdb on dedicated drives?
// Is there only one tempdb data file?
// Are all of the tempdb data files the same size?
// Are there multiple data files for user databases?
// Is percent growth enabled for any files (which is bad)?


// Volume info for all LUNS that have database files on the current instance (Query 26) (Volume Info)-->
    <Query id="26" name="Volume Info" description="Volume info for all LUNS that have database files on the current instance" file="SQL Server vNext.sql" fileVersion="14.0.0" level="server"><![CDATA[
SELECT DISTINCT vs.volume_mount_point, vs.file_system_type, 
vs.logical_volume_name, CONVERT(DECIMAL(18,2),vs.total_bytes/1073741824.0) AS [Total Size (GB)],
CONVERT(DECIMAL(18,2), vs.available_bytes/1073741824.0) AS [Available Size (GB)],  
CONVERT(DECIMAL(18,2), vs.available_bytes * 1. / vs.total_bytes * 100.) AS [Space Free %]
FROM sys.master_files AS f WITH (NOLOCK)
CROSS APPLY sys.dm_os_volume_stats(f.database_id, f.[file_id]) AS vs 
ORDER BY vs.volume_mount_point OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// If no global trace flags are enabled, no results will be returned.
// It is very useful to know what global trace flags are currently enabled as part of the diagnostic process.

// Common trace flags that should be enabled in most cases
// TF 1117 - When growing a data file, grow all files at the same time so they remain the same size, reducing allocation contention points
//           http://support2.microsoft.com/kb/2154845
// 
// TF 1118 - Helps alleviate allocation contention in tempdb, SQL Server allocates full extents to each database object, 
//           thereby eliminating the contention on SGAM pages (more important with older versions of SQL Server)
//           Recommendations to reduce allocation contention in SQL Server tempdb database
//           http://support2.microsoft.com/kb/2154845

// TF 2371 - Lowers auto update statistics threshold for large tables
//           http://blogs.msdn.com/b/saponsqlserver/archive/2011/09/07/changes-to-automatic-update-statistics-in-sql-server-traceflag-2371.aspx

// TF 3226 - Supresses logging of successful database backup messages to the SQL Server Error Log
//           http://www.sqlskills.com/blogs/paul/fed-up-with-backup-success-messages-bloating-your-error-logs/


// Windows information (SQL Server 2008 R2 SP1 or greater)  (Query 7) (Windows Info)-->
    <Query id="7" name="Windows Info" description="Windows information (SQL Server 2008 R2 SP1 or greater)" file="SQL Server 2008 R2.sql" fileVersion="10.50.0" level="server"><![CDATA[
SELECT windows_release, windows_service_pack_level, 
       windows_sku, os_language_version
FROM sys.dm_os_windows_info WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent Alerts (which are different from SQL Server Agent jobs)
// Read more about Agent Alerts here: http://www.sqlskills.com/blogs/glenn/creating-sql-server-agent-alerts-for-critical-errors/



// Windows information (Query 10) (Windows Info)-->
    <Query id="10" name="Windows Info" description="Windows information" file="SQL Server 2012.sql" fileVersion="11.0.0" level="server"><![CDATA[
SELECT windows_release, windows_service_pack_level, 
       windows_sku, os_language_version
FROM sys.dm_os_windows_info WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent Alerts (which are different from SQL Server Agent jobs)
// Read more about Agent Alerts here: http://www.sqlskills.com/blogs/glenn/creating-sql-server-agent-alerts-for-critical-errors/



// Windows information (Query 11) (Windows Info)-->
    <Query id="11" name="Windows Info" description="Windows information" file="SQL Server 2014.sql" fileVersion="12.0.0" level="server"><![CDATA[
SELECT windows_release, windows_service_pack_level, 
       windows_sku, os_language_version
FROM sys.dm_os_windows_info WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Gives you some basic information about your SQL Server Agent Alerts (which are different from SQL Server Agent jobs)
// Read more about Agent Alerts here: http://www.sqlskills.com/blogs/glenn/creating-sql-server-agent-alerts-for-critical-errors/



// Windows information (Query 11) (Windows Info)-->
    <Query id="11" name="Windows Info" description="Windows information" file="SQL Server 2016.sql" fileVersion="13.0.0" level="server"><![CDATA[
SELECT windows_release, windows_service_pack_level, 
       windows_sku, os_language_version
FROM sys.dm_os_windows_info WITH (NOLOCK) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Show which indexes in the current database are most active for Writes


// Get in-memory OLTP index usage (Query 70) (XTP Index Usage)-->
    <Query id="70" name="XTP Index Usage" description="Get in-memory OLTP index usage" file="SQL Server 2014.sql" fileVersion="12.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(i.[object_id]) AS [Object Name], i.index_id, i.[name] AS [Index Name],
       i.[type_desc], xis.scans_started, xis.scans_retries, 
	   xis.rows_touched, xis.rows_returned
FROM sys.dm_db_xtp_index_stats AS xis WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON i.[object_id] = xis.[object_id] 
AND i.index_id = xis.index_id 
ORDER BY OBJECT_NAME(i.[object_id]) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Show which indexes in the current database are most active for Writes


// Get in-memory OLTP index usage (Query 72) (XTP Index Usage)-->
    <Query id="72" name="XTP Index Usage" description="Get in-memory OLTP index usage" file="SQL Server 2016.sql" fileVersion="13.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(i.[object_id]) AS [Object Name], i.index_id, i.[name] AS [Index Name],
       i.[type_desc], xis.scans_started, xis.scans_retries, 
	   xis.rows_touched, xis.rows_returned
FROM sys.dm_db_xtp_index_stats AS xis WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON i.[object_id] = xis.[object_id] 
AND i.index_id = xis.index_id 
ORDER BY OBJECT_NAME(i.[object_id]) OPTION (RECOMPILE);
]]></Query>
    <!--//////
   
// Show which indexes in the current database are most active for Writes


// Get in-memory OLTP index usage (Query 72) (XTP Index Usage)-->
    <Query id="72" name="XTP Index Usage" description="Get in-memory OLTP index usage" file="SQL Server vNext.sql" fileVersion="14.0.0" level="db"><![CDATA[
SELECT OBJECT_NAME(i.[object_id]) AS [Object Name], i.index_id, i.[name] AS [Index Name],
       i.[type_desc], xis.scans_started, xis.scans_retries, 
	   xis.rows_touched, xis.rows_returned
FROM sys.dm_db_xtp_index_stats AS xis WITH (NOLOCK)
INNER JOIN sys.indexes AS i WITH (NOLOCK)
ON i.[object_id] = xis.[object_id] 
AND i.index_id = xis.index_id 
ORDER BY OBJECT_NAME(i.[object_id]) OPTION (RECOMPILE);
]]></Query>
</Queries>